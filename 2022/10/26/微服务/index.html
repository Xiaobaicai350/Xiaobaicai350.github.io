<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>微服务 | 是小白菜哦</title><meta name="keywords" content="spring cloud"><meta name="author" content="小白菜"><meta name="copyright" content="小白菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微服务技术栈认识微服务单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。  优点：架构简单，部署成本低 缺点：耦合度高（维护困难、升级困难） 分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。  优点：降低服务耦合，有利于服务升级和拓展 缺点：服务调用关系错综复杂 分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务">
<meta property="og:url" content="http://example.com/2022/10/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.html">
<meta property="og:site_name" content="是小白菜哦">
<meta property="og:description" content="微服务技术栈认识微服务单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。  优点：架构简单，部署成本低 缺点：耦合度高（维护困难、升级困难） 分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。  优点：降低服务耦合，有利于服务升级和拓展 缺点：服务调用关系错综复杂 分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hakaimg.com/i/2022/08/08/nytkjo.png">
<meta property="article:published_time" content="2022-10-26T09:10:37.000Z">
<meta property="article:modified_time" content="2023-03-27T03:50:03.892Z">
<meta property="article:author" content="小白菜">
<meta property="article:tag" content="spring cloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hakaimg.com/i/2022/08/08/nytkjo.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/132124.png"><link rel="canonical" href="http://example.com/2022/10/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 11:50:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://hakaimg.com/i/2022/08/08/nytkjo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">是小白菜哦</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">微服务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-26T09:10:37.000Z" title="发表于 2022-10-26 17:10:37">2022-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T03:50:03.892Z" title="更新于 2023-03-27 11:50:03">2023-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微服务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h1><h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901083809.png"><img src="/../pic/20210901083809.png" alt="img"></a></p>
<p><strong>优点</strong>：架构简单，部署成本低</p>
<p><strong>缺点</strong>：耦合度高（维护困难、升级困难）</p>
<h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092921.png"><img src="/../pic/20210901092921.png" alt="img"></a></p>
<p><strong>优点</strong>：降低服务耦合，有利于服务升级和拓展</p>
<p><strong>缺点</strong>：服务调用关系错综复杂</p>
<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p>
<ul>
<li>服务拆分的粒度如何界定？</li>
<li>服务之间如何调用？</li>
<li>服务集群地址如何维护?</li>
<li>服务的健康状态如何感知?</li>
<li>服务的调用关系如何管理？</li>
</ul>
<p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205162352847.png"><img src="/../pic/202205162352847.png" alt="img"></a></p>
<p>微服务的上述特性<strong>其实是在给分布式架构制定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到<strong>高内聚，低耦合</strong>。</p>
<p><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</strong></p>
<p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p>
<p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<p>其中常见的组件包括：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901083717.png"><img src="/../pic/20210901083717.png" alt="img"></a></p>
<p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901084050.png"><img src="/../pic/20210901084050.png" alt="img"></a></p>
<h2 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h2><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092925.png"><img src="/../pic/20210901092925.png" alt="需要学习的微服务知识内容"></a></p>
<p>需要学习的微服务技术</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901084131.png"><img src="/../pic/20210901084131.png" alt="技术栈"></a></p>
<p>技术栈</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090737.png"><img src="/../pic/20210901090737.png" alt="自动化部署"></a></p>
<p>自动化部署</p>
<h2 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h2><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090726.png"><img src="/../pic/20210901090726.png" alt="img"></a></p>
<h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p><strong>服务拆分注意事项</strong></p>
<p>单一职责：不同微服务，不要重复开发相同业务</p>
<p>数据独立：不要访问其它微服务的数据库</p>
<p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p>
<p>我们下面做一个demo来初识微服务</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090745.png"><img src="/../pic/20210901090745.png" alt="img"></a></p>
<p>cloud-demo：父工程，管理依赖</p>
<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
</ul>
<p>要求：</p>
<ul>
<li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li>
<li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li>
<li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li>
</ul>
<p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090750.png"><img src="/../pic/20210901090750.png" alt="img"></a></p>
<p>启动完成后，访问 <a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090757.png"><img src="/../pic/20210901090757.png" alt="img"></a></p>
<h1 id="RestTemplate远程调用"><a href="#RestTemplate远程调用" class="headerlink" title="RestTemplate远程调用"></a>RestTemplate远程调用</h1><p>正如上面的服务拆分要求中所提到，</p>
<blockquote>
<p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</p>
</blockquote>
<p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p>
<p><img src="/../pic/image-20220913165748011.png" alt="image-20220913165748011"></p>
<p>发送请求，自动序列化为 Java 对象。</p>
<p><img src="/../pic/20210901090846.png" alt="img"></p>
<p>这里面需要注意的是getForObject方法，和里面的参数，这个restTemplate非常智能，可以把返回回来的json数据，直接转换为pojo类对象</p>
<p>启动完成后，访问：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090909.png"><img src="/../pic/20210901090909.png" alt="img"></a></p>
<p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>最广为人知的注册中心就是 Eureka，其结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090919.png"><img src="/../pic/20210901090919.png" alt="img"></a></p>
<p><strong>order-service 如何得知 user-service 实例地址？</strong></p>
<ul>
<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li>
<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service <em>根据服务名称，拉取实例地址列表</em>，这个叫<strong>服务发现</strong>或服务拉取</li>
</ul>
<p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p>
<p>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</p>
<p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p>
<ul>
<li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li>
<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service 拉取服务时，就能将故障实例排除了</li>
</ul>
<hr>
<p>接下来我们动手实践的步骤包括</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090932.png"><img src="/../pic/20210901090932.png" alt="img"></a></p>
<h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>搭建 eureka-server</strong></p>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写启动类</strong></p>
<p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写配置文件</strong></p>
<p>编写一个 application.yml 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p>
<p>启动完成后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090945.png"><img src="/../pic/20210901090945.png" alt="img"></a></p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote>
<p>将 user-service、order-service 都注册到 eureka</p>
</blockquote>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>client</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动类上添加注解：<code>@EnableEurekaClient</code></p>
<p>在 application.yml 文件，添加下面的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">  	<span class="comment">#name：orderservice #第一个</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment">#第二个</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http:127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>

<p>3个项目启动后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901090958.png"><img src="/../pic/20210901090958.png" alt="img"></a></p>
<p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，开两个userservice，来查看 Eureka 的集群效果。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091005.png"><img src="/../pic/20210901091005.png" alt="img"></a></p>
<p>4个项目启动后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091015.png"><img src="/../pic/20210901091015.png" alt="img"></a></p>
<h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><blockquote>
<p>在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</p>
</blockquote>
<p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>
<p>首先给 <code>RestTemplate</code> （这个就是之前导入的那个Bean）这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p>
<p> <code>@LoadBalanced</code> 的意思是我们根据RestTemplate发出的请求，会被ribbon去拦截和处理啦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091216.png"><img src="/../pic/20210901091216.png" alt="img"></a></p>
<p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。（很神奇，但这就是他的特性）</p>
<p>需要注意的是服务名称是我们配置到yml文件里面的名称，也就是这个</p>
<p><img src="/../pic/image-20220913174428473.png" alt="image-20220913174428473"></p>
<p>而不是整个项目的名称</p>
<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>本节主要是来讲解LoadBalanced的原理是Ribbon，没有新的东西</p>
<p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p>
<p><strong>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091242.png"><img src="/../pic/20210901091242.png" alt="img"></a></p>
<h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。</p>
<p>它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>
<p>我们进行源码跟踪：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091323.png"><img src="/../pic/20210901091323.png" alt="img"></a></p>
<p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，即 <a target="_blank" rel="noopener" href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务名 <code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务名称，和用户请求</li>
</ul>
<p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p>
<p>继续跟入 <code>execute()</code> 方法：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091330.png"><img src="/../pic/20210901091330.png" alt="img"></a></p>
<ul>
<li><code>getLoadBalancer(serviceId)</code>：根据服务名称获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务名称 去 eureka 中获取服务列表。</li>
<li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li>
</ul>
<p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091345.png"><img src="/../pic/20210901091345.png" alt="img"></a></p>
<p>我们继续跟入：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091355.png"><img src="/../pic/20210901091355.png" alt="img"></a></p>
<p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091414.png"><img src="/../pic/20210901091414.png" alt="img"></a></p>
<p>我们看看这个 <code>rule</code> 是谁：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091432.png"><img src="/../pic/20210901091432.png" alt="img"></a></p>
<p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091442.png"><img src="/../pic/20210901091442.png" alt="img"></a></p>
<p>负载均衡默认使用了轮询算法，当然我们也可以自定义。</p>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的 <code>RestTemplate</code> 请求 <a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li>
<li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li>
<li>eureka 返回列表，localhost:8081、localhost:8082</li>
<li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>
<li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<p><img src="/../pic/20210901091755.png" alt="img"></p>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091811.png"><img src="/../pic/20210901091811.png" alt="img"></a></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>内置负载均衡规则类</strong></th>
<th align="left"><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">RoundRobinRule</td>
<td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td align="left"><strong>ZoneAvoidanceRule</strong></td>
<td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td align="left">随机选择一个可用的服务器。</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p>
<h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有<strong>两种</strong>方式：</p>
<p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p>
<p>里面的RandomRule也是一种负载均衡策略，上表有</p>
<p><img src="/../pic/image-20220914145336418.png" alt="image-20220914145336418"></p>
<p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p>
<h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091850.png"><img src="/../pic/20210901091850.png" alt="img"></a></p>
<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<p>下面的是在order-service的yml配置文件下做的修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启饥饿加载</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span></span><br></pre></td></tr></table></figure>

<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，在国外也有大量的使用。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091857.png"><img src="/../pic/20210901091857.png" alt="img"></a></p>
<p>nacos可以去github上下载安装包，之后直接解压到非中文目录下就可以了</p>
<p>启动：</p>
<p>在nacos的bin目录下输入下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220917151129077.png" alt="image-20220917151129077"></p>
<p>但是其实这样是正常的，虽然ip不对，但是不知道为啥，知道了会回来填坑</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091904.png"><img src="/../pic/20210901091904.png" alt="img"></a></p>
<p>注意登录账号和密码都是nacos</p>
<h2 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。</p>
<p><strong>引入依赖</strong></p>
<p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p>
<p>这个是nacos的版本依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置nacos地址</strong></p>
<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>

<p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091918.png"><img src="/../pic/20210901091918.png" alt="img"></a></p>
<p>浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，可以正常访问，同时负载均衡也正常。</a></p>
<h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091928.png"><img src="/../pic/20210901091928.png" alt="img"></a></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091937.png"><img src="/../pic/20210901091937.png" alt="img"></a></p>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>接下来我们给 user-service <strong>配置集群</strong></p>
<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称可以随便 HZ杭州</span></span><br></pre></td></tr></table></figure>

<p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p>
<p>需要修改yml配置文件再启动一个就可以了</p>
<p>查看 nacos 控制台</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901091957.png"><img src="/../pic/20210901091957.png" alt="img"></a></p>
<h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> ，并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p>
<p><strong>第一种方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">iRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//默认为轮询规则，这里自定义为随机规则</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种方式：</strong>你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment">#负载均衡规则 </span></span><br></pre></td></tr></table></figure>

















<p>然后，再对 orderservice 配置集群。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>

<p>现在我启动了四个服务，分别是：</p>
<ul>
<li>orderservice - HZ</li>
<li>userservice1 - HZ</li>
<li>userservice2 - HZ</li>
<li>userservice3 - SH</li>
</ul>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p>
<p>我们试着把 userservice1、userservice2 停掉。依旧可以访问。</p>
<p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p>
<h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p>
<p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092020.png"><img src="/../pic/20210901092020.png" alt="img"></a></p>
<p>在弹出的编辑窗口，修改权重</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092026.png"><img src="/../pic/20210901092026.png" alt="img"></a></p>
<p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到 0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p>
<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p>
<ul>
<li>Nacos 中可以有多个 namespace</li>
<li>namespace 下可以有 group、service 等</li>
<li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092032.png"><img src="/../pic/20210901092032.png" alt="img"></a></p>
<h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092038.png"><img src="/../pic/20210901092038.png" alt="img"></a></p>
<p>我们可以点击页面新增按钮，添加一个 namespace：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092050.png"><img src="/../pic/20210901092050.png" alt="img"></a></p>
<p>然后，填写表单：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092059.png"><img src="/../pic/20210901092059.png" alt="img"></a></p>
<p>就能在页面看到一个新的 namespace：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092114.png"><img src="/../pic/20210901092114.png" alt="img"></a></p>
<h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p>
<p>例如，修改 order-service 的 application.yml 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间ID</span></span><br></pre></td></tr></table></figure>

<p>重启 order-service 后，访问控制台。</p>
<p><strong>public</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092143.png"><img src="/../pic/20210901092143.png" alt="img"></a></p>
<p><strong>dev</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092130.png"><img src="/../pic/20210901092130.png" alt="img"></a></p>
<p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092138.png"><img src="/../pic/20210901092138.png" alt="img"></a></p>
<h2 id="Nacos和Eureka的比较"><a href="#Nacos和Eureka的比较" class="headerlink" title="Nacos和Eureka的比较"></a>Nacos和Eureka的比较</h2><p><img src="/../pic/image-20220914152926611.png" alt="image-20220914152926611"></p>
<p><img src="/../pic/image-20220914153302146.png" alt="image-20220914153302146"></p>
<h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>服务实例默认就是临时实例</p>
<p>Nacos 的服务实例分为两种类型：</p>
<ul>
<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure>

<p>另外，Nacos 集群**默认采用AP方式(可用性)<strong>，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p>
<h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092150.png"><img src="/../pic/20210901092150.png" alt="img"></a></p>
<p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p>
<h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092159.png"><img src="/../pic/20210901092159.png" alt="img"></a></p>
<p>然后在弹出的表单中，填写配置信息：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092206.png"><img src="/../pic/20210901092206.png" alt="img"></a></p>
<p><strong>注意</strong>：</p>
<p>项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。</p>
<p>基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。</p>
<h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092215.png"><img src="/../pic/20210901092215.png" alt="img"></a></p>
<p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092223.png"><img src="/../pic/20210901092223.png" alt="img"></a></p>
<p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p>
<p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092228.png"><img src="/../pic/20210901092228.png" alt="img"></a></p>
<p>​                                                                                                                                                      </p>
<p><strong>引入 nacos-config 依赖</strong></p>
<p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加 bootstrap.yml</strong></p>
<p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>



<p>在这个例子  中，就是去读取 <code>userservice-dev.yaml</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092237.png"><img src="/../pic/20210901092237.png" alt="img"></a></p>
<p>使用代码来验证是否拉取成功</p>
<p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String dateformat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//格式化时间</span></span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>启动服务后，访问：<a target="_blank" rel="noopener" href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p>
<h2 id="一个微服务中配置多个配置文件"><a href="#一个微服务中配置多个配置文件" class="headerlink" title="一个微服务中配置多个配置文件"></a>一个微服务中配置多个配置文件</h2><p>多配置文件加载</p>
<p>在一些情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：service-statistics.properties、redis.properties、jdbc.properties</p>
<p><img src="/../pic/image-20221020094822524.png" alt="image-20221020094822524"></p>
<p>修改bootstrap.properties添加如下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId，之前已经配置过</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-statistics</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">13b5c197-de5b-47e7-9903-ec0538c9db01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#第一个</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#di&#x27;er&#x27;ge</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">jdbc.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>
<p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p>
<h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在<strong>类</strong>上添加注解 <code>@RefreshScope</code></p>
<p><img src="/../pic/image-20220914192142180.png" alt="image-20220914192142180"></p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。通过这个注解可以完成配置的自动加载</p>
<p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码写在usercontroller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;now2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">now2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//格式化时间</span></span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p>
<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>
</ul>
<p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p>
<p><strong>添加一个环境共享配置</strong></p>
<p>我们在 nacos 中添加一个 userservice.yaml 文件： </p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092323.png"><img src="/../pic/20210901092323.png" alt="img"></a></p>
<p><strong>在 user-service 中读取共享配置</strong></p>
<p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092314.png"><img src="/../pic/20210901092314.png" alt="img"></a></p>
<p>在 user-service 服务中，修改 UserController，添加一个方法：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092331.png"><img src="/../pic/20210901092331.png" alt="img"></a></p>
<p><strong>运行两个 UserApplication，使用不同的profile</strong></p>
<p>修改 UserApplication2 这个启动项，改变其profile值：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092345.png"><img src="/../pic/20210901092345.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092338.png"><img src="/../pic/20210901092338.png" alt="img"></a></p>
<p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p>
<p>启动 UserApplication 和 UserApplication2</p>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092400.png"><img src="/../pic/20210901092400.png" alt="img"></a></p>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092419.png"><img src="/../pic/20210901092419.png" alt="img"></a></p>
<p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p>
<p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p>
<p>通过下面的两种方式来指定：</p>
<ul>
<li>extension-configs</li>
<li>shared-configs</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">extends-configs:</span> <span class="comment"># 多微服务间共享的配置列表</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">common.yaml</span> <span class="comment"># 要共享的配置文件id</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 多微服务间共享的配置列表</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">common.yaml</span> <span class="comment"># 要共享的配置文件id</span></span><br></pre></td></tr></table></figure>

<h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092501.png"><img src="/../pic/20210901092501.png" alt="img"></a></p>
<p>更细致的配置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092520.png"><img src="/../pic/20210901092520.png" alt="img"></a></p>
<h1 id="Nacos集群"><a href="#Nacos集群" class="headerlink" title="Nacos集群"></a>Nacos集群</h1><h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p><img src="/../pic/image-20220917141157375.png" alt="image-20220917141157375"></p>
<p>其中包含 3 个Nacos 节点，然后一个负载均衡器 Nginx 代理 3 个 Nacos，我们计划的 Nacos 集群如下图，MySQL 的主从复制后续再添加。</p>
<p>下面比较形象</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108182000220.png"><img src="/../pic/202108182000220.png" alt="img"></a></p>
<p>三个 Nacos 节点的地址</p>
<table>
<thead>
<tr>
<th align="left">节点</th>
<th align="left">ip</th>
<th align="left">port</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nacos1</td>
<td align="left">192.168.150.1</td>
<td align="left">8845</td>
</tr>
<tr>
<td align="left">nacos2</td>
<td align="left">192.168.150.1</td>
<td align="left">8846</td>
</tr>
<tr>
<td align="left">nacos3</td>
<td align="left">192.168.150.1</td>
<td align="left">8847</td>
</tr>
</tbody></table>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库。这里我们以单点的数据库为例。</p>
<p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">	`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">	`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h2><ol>
<li>进入 nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</li>
</ol>
<p><img src="/../pic/image-20220917141609224.png" alt="image-20220917141609224"></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108182004564.png"><img src="/../pic/202108182004564.png" alt="img"></a></p>
<p>添加内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure>





<p>2. </p>
<p>然后修改 application.properties 文件，添加数据库配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>



<p>3. </p>
<p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108182004103.png"><img src="/../pic/202108182004103.png" alt="img"></a></p>
<p>4. </p>
<p>然后分别修改三个文件夹中的 application.properties，</p>
<p>nacos1</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure>

<p>nacos2</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure>

<p>nacos3</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure>



<hr>
<p>到现在就配置好啦</p>
<p>然后分别启动三个 nacos，就是在<strong>每个</strong>nacos的bin目录下执行这个指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure>

<p>之后我们就需要对nginx做反向代理</p>
<h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>修改 nginx 文件夹下的 conf&#x2F;nginx.conf 文件，配置如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码的意思是只要访问&#x2F;nacos这个路径，就会代理到上面 127.0.0.1:8845;那三个的路径</p>
</blockquote>
<p>启动 nginx，在浏览器访问：<a target="_blank" rel="noopener" href="http://localhost/nacos">http://localhost/nacos</a></p>
<p>那我们可以想，如果想使用nacos，我们只需要配置到80端口就可以了，之后nginx就会自动为我们分配nacos了</p>
<p>在代码中的 application.yml 文件配置改为如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure>

<p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 ，Nacos 的客户端也无需更改配置。Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离工作。</p>
<h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092616.png"><img src="/../pic/20210901092616.png" alt="img"></a></p>
<p>缺点：</p>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护，太长的参数，不好维护</li>
</ul>
<p>Feign 是一个<strong>声明式</strong>的 http 客户端</p>
<p>官方地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092639.png"><img src="/../pic/20210901092639.png" alt="img"></a></p>
<p>发送一个http请求需要的信息</p>
<p><img src="/../pic/20210901092616.png" alt="img"></p>
<ul>
<li><p>服务名称: userservice</p>
</li>
<li><p>请求方式:GET</p>
</li>
<li><p>请求路径:&#x2F;user&#x2F;{id}</p>
</li>
<li><p>请求参数:Long id</p>
</li>
<li><p>返回值类型:User</p>
<p>下面是feign的使用</p>
<p><img src="/../pic/image-20220917144009019.png" alt="image-20220917144009019"></p>
</li>
</ul>
<h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p>
<p>我们在 order-service 引入 feign 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加注解</strong></p>
<p>在 order-service 启动类添加注解开启 Feign</p>
<p><img src="/../pic/image-20220917144618521.png" alt="image-20220917144618521"></p>
<p><strong>请求接口</strong></p>
<p>在 order-service 中新建一个接口，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p>
<p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p>
<p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p>
<p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>
<p>所以我们就可以把restTemplate的代码给注掉啦</p>
<p><img src="/../pic/image-20220917145035952.png" alt="image-20220917145035952"></p>
<p>我们既然要用feign，那就要使用刚刚我们创建的feign的接口</p>
<p><img src="/../pic/image-20220917150209401.png" alt="image-20220917150209401"></p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderAndUserById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2.使用feign远程调用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findById(order.getUserId());</span><br><span class="line">    <span class="comment">// 3. 将用户信息封装进订单</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>feign.Logger.Level</strong></td>
<td align="left">修改日志级别</td>
<td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td align="left">feign.codec.Decoder</td>
<td align="left">响应结果的解析器</td>
<td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td align="left">feign.codec.Encoder</td>
<td align="left">请求参数编码</td>
<td align="left">将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td align="left">feign.Contract</td>
<td align="left">支持的注解格式</td>
<td align="left">默认是SpringMVC的注解</td>
</tr>
<tr>
<td align="left">feign.Retryer</td>
<td align="left">失败重试机制</td>
<td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。</p>
<p>下面以日志为例来演示如何自定义配置。</p>
<p>基于配置文件修改 feign 的日志级别可以针对<strong>单个服务</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>

<p><strong>也可以针对所有服务</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>

<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li>
</ul>
<p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要<strong>全局生效</strong>，将其放到<strong>启动类</strong>的 <code>@EnableFeignClients</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>

<p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p>
<ul>
<li><strong>URLConnection</strong>：默认实现，不支持连接池</li>
<li><strong>Apache HttpClient</strong> ：支持连接池</li>
<li><strong>OKHttp</strong>：支持连接池</li>
</ul>
<p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p>
<p>另外，日志级别应该尽量用 basic&#x2F;none，可以有效提高性能。</p>
<p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p>
<p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置连接池</strong></p>
<p>在 order-service 的 application.yml 中添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>我们可以发现，因为我们发的请求和响应的接收的请求的代码是差不多的，所以可以进行利用（但是官方并不建议我们这样做）</p>
<p>一样的代码可以通过继承来共享：</p>
<p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p>
<p>2）Feign 客户端、Controller 都集成该接口</p>
<p><img src="/../pic/20210901092803.png" alt="img"></p>
<p><strong>优点</strong></p>
<ul>
<li>简单</li>
<li>实现了代码共享</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>服务提供方、服务消费方紧耦合</li>
<li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li>
</ul>
<h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 pojo、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>
<p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092811.png"><img src="/../pic/20210901092811.png" alt="img"></a></p>
<p>接下来我们就用该方法在代码中实现</p>
<p><strong>首先创建一个 module，命名为 feign-api</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092835.png"><img src="/../pic/20210901092835.png" alt="img"></a></p>
<p>在 feign-api 中然后引入feign的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>order-service中 的 UserClient、User 都复制到 feign-api 项目中</p>
<p><img src="/../pic/image-20220917153931415.png" alt="image-20220917153931415"></p>
<p>接下来在 order-service 中使用 feign-api</p>
<p>由于我们已经将 UserClient、User 放在 fegin-api 中共享了 ，所以可以删除 order-service 中的 UserClient、User，然后在 order-service 中引入 feign-api</p>
<p><img src="/../pic/image-20220917154034726.png" alt="image-20220917154034726"></p>
<p><strong>修改注解</strong></p>
<p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient (UserClient)就不能使用。</p>
<p>第一种</p>
<p>修改 order-service 启动类上的 <code>@EnableFeignClients</code> 注解</p>
<p><img src="/../pic/image-20220917154352411.png" alt="image-20220917154352411"></p>
<p>需要注意的是，引入的pom依赖，相当于把代码就导入进项目了，也就是说，在另一个项目下的路径，也可以被spring扫描</p>
<p>第二种</p>
<p><img src="/../pic/image-20220917154552660.png" alt="image-20220917154552660"></p>
<h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li>请求路由</li>
<li>权限控制</li>
<li>限流</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210901092857.png"><img src="/../pic/20210901092857.png" alt="img"></a></p>
<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
<p>在 SpringCloud 中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul 是基于 Servlet 实现，属于阻塞式编程。</p>
<p>而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。 </p>
<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol>
<li>创建 SpringBoot（用Maven就可以） 工程 gateway，引入网关依赖</li>
<li>编写启动类</li>
<li>编写基础配置和路由规则</li>
<li>启动网关服务进行测试</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建 application.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure>

<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p>
<p>重启网关，访问 <a target="_blank" rel="noopener" href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108220125749.png"><img src="/../pic/202108220125749.png" alt="img"></a></p>
<p>多个 predicates 的话，要同时满足规则，下文有例子。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108220127419.png"><img src="/../pic/202108220127419.png" alt="img"></a></p>
<p>路由配置包括：</p>
<ol>
<li>路由id：路由的唯一标示</li>
<li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li>
<li>路由断言（predicates）：判断路由的规则</li>
<li>路由过滤器（filters）：对请求或响应做处理（这个还没做笔记，之后会做）</li>
</ol>
<h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p>
<p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">After</td>
<td align="left">是某个时间点后的请求</td>
<td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">是某个时间点之前的请求</td>
<td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">是某两个时间点之前的请求</td>
<td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">请求必须包含某些cookie</td>
<td align="left">- Cookie&#x3D;chocolate, ch.p</td>
</tr>
<tr>
<td align="left">Header</td>
<td align="left">请求必须包含某些header</td>
<td align="left">- Header&#x3D;X-Request-Id, \d+</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求必须是访问某个host（域名）</td>
<td align="left">- Host&#x3D;<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td>
</tr>
<tr>
<td align="left">Method</td>
<td align="left">请求方式必须是指定方式</td>
<td align="left">- Method&#x3D;GET,POST</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">请求路径必须符合指定规则</td>
<td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td>
</tr>
<tr>
<td align="left">Query</td>
<td align="left">请求参数必须包含指定参数</td>
<td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td>
</tr>
<tr>
<td align="left">RemoteAddr</td>
<td align="left">请求者的ip必须是指定范围</td>
<td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td>
</tr>
<tr>
<td align="left">Weight</td>
<td align="left">权重处理</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>
</blockquote>
<p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">After=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p>
<h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108220133487.png"><img src="/../pic/202108220133487.png" alt="img"></a></p>
<p>Spring提供了31种不同的路由过滤器工厂。</p>
<blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">AddRequestHeader</td>
<td align="left">给当前请求添加一个请求头</td>
</tr>
<tr>
<td align="left">RemoveRequestHeader</td>
<td align="left">移除请求中的一个请求头</td>
</tr>
<tr>
<td align="left">AddResponseHeader</td>
<td align="left">给响应结果中添加一个响应头</td>
</tr>
<tr>
<td align="left">RemoveResponseHeader</td>
<td align="left">从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td align="left">RequestRateLimiter</td>
<td align="left">限制请求的流量</td>
</tr>
</tbody></table>
<p>下面我们以 AddRequestHeader 为例：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108220139913.png"><img src="/../pic/202108220139913.png" alt="img"></a></p>
<p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=hhh.com is eternal</code></p>
<p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=sign,</span> <span class="string">hhh.com</span> <span class="string">is</span> <span class="string">eternal</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>

<p>如何验证，我们修改 userservice 中的一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@RequestHeader(value = &quot;sign&quot;, required = false)</span> String sign)</span> &#123;</span><br><span class="line">    log.warn(sign);</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启两个服务，访问：<a target="_blank" rel="noopener" href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p>
<p>可以看到控制台打印出了这个请求头</p>
<p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=sign,</span> <span class="string">hhh.com</span> <span class="string">is</span> <span class="string">eternal</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>

<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p>
<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p>
<p><strong>需求</strong>：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p>
<ul>
<li>参数中是否有 authorization</li>
<li>authorization 参数值是否为 admin</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试：http://localhost:10010/order/101?authorization=admin</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取第一个 authorization 参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(authorization))&#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置拦截状态码信息</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 设置拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过滤器优先级，值越低优先级越高</span></span><br><span class="line">    <span class="comment">// 也可以使用 @Order 注解</span></span><br><span class="line">    <span class="comment">//@Order注解的使用是放在类上，看下面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220917174424836.png" alt="image-20220917174424836"></p>
<h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p>
<p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/202108230002747.png"><img src="/../pic/202108230002747.png" alt="img"></a></p>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li>
<li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p><img src="/../pic/image-20220917175314552.png" alt="image-20220917175314552"></p>
<p>在 Gateway 网关中解决跨域问题还是比较方便的。基本都是cv，以后会深究一下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>

<h2 id="网关相关配置"><a href="#网关相关配置" class="headerlink" title="网关相关配置"></a>网关相关配置</h2><p>网关解决跨域问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">UrlBasedCorsConfigurationSource</span>(<span class="keyword">new</span> <span class="title class_">PathPatternParser</span>());</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局Filter，统一处理会员登录与外部不允许访问的服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 全局Filter，统一处理会员登录与外部不允许访问的服务</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">        <span class="comment">//谷粒学院api接口，校验用户必须登录</span></span><br><span class="line">        <span class="keyword">if</span>(antPathMatcher.match(<span class="string">&quot;/api/**/auth/**&quot;</span>, path)) &#123;</span><br><span class="line">            List&lt;String&gt; tokenList = request.getHeaders().get(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> == tokenList) &#123;</span><br><span class="line">                <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">                <span class="keyword">return</span> out(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Boolean isCheck = JwtUtils.checkToken(tokenList.get(0));</span></span><br><span class="line">                <span class="comment">// if(!isCheck) &#123;</span></span><br><span class="line">                <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">                <span class="keyword">return</span> out(response);</span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部服务接口，不允许外部访问</span></span><br><span class="line">        <span class="keyword">if</span>(antPathMatcher.match(<span class="string">&quot;/**/inner/**&quot;</span>, path)) &#123;</span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            <span class="keyword">return</span> out(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">out</span><span class="params">(ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="type">JsonObject</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonObject</span>();</span><br><span class="line">        message.addProperty(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        message.addProperty(<span class="string">&quot;code&quot;</span>, <span class="number">28004</span>);</span><br><span class="line">        message.addProperty(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;鉴权失败&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bits = message.toString().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(bits);</span><br><span class="line">        <span class="comment">//response.setStatusCode(HttpStatus.UNAUTHORIZED);</span></span><br><span class="line">        <span class="comment">//指定编码，否则在浏览器中会中文乱码</span></span><br><span class="line">        response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义异常处理</p>
<p>服务网关调用服务时可能会有一些异常或服务不可用，它返回错误信息不友好，需要我们覆盖处理</p>
<p>ErrorHandlerConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 覆盖默认的异常处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class, ResourceProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandlerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorHandlerConfig</span><span class="params">(ServerProperties serverProperties,</span></span><br><span class="line"><span class="params">                              ResourceProperties resourceProperties,</span></span><br><span class="line"><span class="params">                              ObjectProvider&lt;List&lt;ViewResolver&gt;&gt;</span></span><br><span class="line"><span class="params">                              viewResolversProvider,</span></span><br><span class="line"><span class="params">                              ServerCodecConfigurer</span></span><br><span class="line"><span class="params">                              serverCodecConfigurer,</span></span><br><span class="line"><span class="params">                              ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverProperties = serverProperties;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="built_in">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">        <span class="built_in">this</span>.viewResolvers =</span><br><span class="line">            viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="built_in">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorWebExceptionHandler <span class="title function_">errorWebExceptionHandler</span><span class="params">(ErrorAttributes</span></span><br><span class="line"><span class="params">                                                             errorAttributes)</span> &#123;</span><br><span class="line">        <span class="type">JsonExceptionHandler</span> <span class="variable">exceptionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonExceptionHandler</span>(</span><br><span class="line">            errorAttributes,</span><br><span class="line">            <span class="built_in">this</span>.resourceProperties,</span><br><span class="line">            <span class="built_in">this</span>.serverProperties.getError(),</span><br><span class="line">            <span class="built_in">this</span>.applicationContext);</span><br><span class="line">        exceptionHandler.setViewResolvers(<span class="built_in">this</span>.viewResolvers);</span><br><span class="line">        exceptionHandler.setMessageWriters(<span class="built_in">this</span>.serverCodecConfigurer.getWriters());</span><br><span class="line">        exceptionHandler.setMessageReaders(<span class="built_in">this</span>.serverCodecConfigurer.getReaders());</span><br><span class="line">        <span class="keyword">return</span> exceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JsonExceptionHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义异常处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;异常时用JSON代替HTML异常信息&lt;p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonExceptionHandler</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorWebExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes,</span></span><br><span class="line"><span class="params">                                ResourceProperties resourceProperties,</span></span><br><span class="line"><span class="params">                                ErrorProperties errorProperties,</span></span><br><span class="line"><span class="params">                                ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorAttributes, resourceProperties, errorProperties,</span><br><span class="line">              applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取异常属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(ServerRequest request,</span></span><br><span class="line"><span class="params">                                                     <span class="type">boolean</span> includeStackTrace)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">20005</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;网关失败&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指定响应处理方法为JSON处理的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">getRoutingFunction</span><span class="params">(ErrorAttributes</span></span><br><span class="line"><span class="params">                                                                errorAttributes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.all(),</span><br><span class="line">                                     <span class="built_in">this</span>::renderErrorResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据code获取对应的HttpStatus</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HttpStatus <span class="title function_">getHttpStatus</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="RabbitMQ消息中间件"><a href="#RabbitMQ消息中间件" class="headerlink" title="RabbitMQ消息中间件"></a>RabbitMQ消息中间件</h1><h2 id="同步异步通讯"><a href="#同步异步通讯" class="headerlink" title="同步异步通讯"></a>同步异步通讯</h2><p><strong>微服务间通讯有同步和异步两种方式</strong></p>
<p>同步通讯：就像打电话，需要实时响应。</p>
<p>异步通讯：就像发邮件，不需要马上回复。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904133345.png"><img src="/../pic/20210904133345.png" alt="img"></a></p>
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<p>我们之前学习的 <strong>Feign 调用</strong>就属于<strong>同步方式</strong>，虽然调用可以实时得到结果，但存在下面的问题：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904133517.png"><img src="/../pic/20210904133517.png" alt="img"></a></p>
<p><strong>同步调用的优点</strong>：</p>
<ul>
<li>时效性较强，可以立即得到结果</li>
</ul>
<p><strong>同步调用的缺点</strong>：</p>
<ul>
<li><p>耦合度高</p>
</li>
<li><p>性能和吞吐能力下降</p>
</li>
<li><p>有额外的资源消耗</p>
</li>
<li><p>有级联失败问题</p>
<hr>
</li>
</ul>
<p>异步调用则可以避免上述问题，我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。在事件模式中，支付服务是事件发布者（publisher），在支付完成后<strong>只需要发布一个支付成功的事件</strong>（event），事件中带上订单id。订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904144714.png"><img src="/../pic/20210904144714.png" alt="img"></a></p>
<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904145001.png"><img src="/../pic/20210904145001.png" alt="img"></a></p>
<p><strong>异步调用好处</strong>：</p>
<ul>
<li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li>
<li>故障隔离：服务没有直接调用，不存在级联失败问题</li>
<li>调用间没有阻塞，不会造成无效的资源占用</li>
<li>耦合度极低，每个服务都可以灵活插拔，可替换</li>
<li>流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件</li>
</ul>
<p><strong>异步调用缺点</strong>：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于 Broker 的可靠、安全、性能</li>
</ul>
<h2 id="MQ消息队列"><a href="#MQ消息队列" class="headerlink" title="MQ消息队列"></a>MQ消息队列</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列，也就是事件驱动架构中的 <strong>Broker</strong></p>
<p>比较常见的 MQ 实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>RabbitMQ</strong></th>
<th align="left"><strong>ActiveMQ</strong></th>
<th align="left"><strong>RocketMQ</strong></th>
<th align="left"><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">公司&#x2F;社区</td>
<td align="left">Rabbit</td>
<td align="left">Apache</td>
<td align="left">阿里</td>
<td align="left">Apache</td>
</tr>
<tr>
<td align="left">开发语言</td>
<td align="left">Erlang</td>
<td align="left">Java</td>
<td align="left">Java</td>
<td align="left">Scala&amp;Java</td>
</tr>
<tr>
<td align="left">协议支持</td>
<td align="left">AMQP、XMPP、SMTP、STOMP</td>
<td align="left">OpenWire、STOMP、REST、XMPP、AMQP</td>
<td align="left">自定义协议</td>
<td align="left">自定义协议</td>
</tr>
<tr>
<td align="left">可用性</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">单机吞吐量</td>
<td align="left">一般</td>
<td align="left">差</td>
<td align="left">高</td>
<td align="left">非常高</td>
</tr>
<tr>
<td align="left">消息延迟</td>
<td align="left">微秒级</td>
<td align="left">毫秒级</td>
<td align="left">毫秒级</td>
<td align="left">毫秒以内</td>
</tr>
<tr>
<td align="left">消息可靠性</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">高</td>
<td align="left">一般</td>
</tr>
</tbody></table>
<blockquote>
<h1 id="RabbitMQ部署指南"><a href="#RabbitMQ部署指南" class="headerlink" title="RabbitMQ部署指南"></a>RabbitMQ部署指南</h1><h1 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h1><p>我们在Centos7虚拟机中使用Docker来安装。</p>
<h2 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h2><p>方式一：在线拉取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker pull rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>



<p>方式二：从本地加载</p>
<p>在课前资料已经提供了镜像包：</p>
<p><img src="/../pic/image-20210423191210349.png" alt="image-20210423191210349"> </p>
<p>上传到虚拟机中后，使用命令加载镜像即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker load -i mq.tar</span><br></pre></td></tr></table></figure>





<h2 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h2><p>执行下面的命令来运行MQ容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">-v mq-plugins:/plugins \</span><br><span class="line">--name mq \</span><br><span class="line">--hostname mq1 \</span><br><span class="line">-p 15672:15672 \</span><br><span class="line">-p 5672:5672 \</span><br><span class="line">-d \</span><br><span class="line">rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<p>15672是管理平台的ui界面端口</p>
<p>5672是消息通信的端口</p>
<p>启动成功后访问地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;http://192.168.30.128:15672</span><br></pre></td></tr></table></figure>

</blockquote>
<p><strong>RabbitMQ 中的一些角色</strong></p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，<strong>隔离不同租户</strong>的 exchange、queue、消息的隔离</li>
</ul>
<p><strong>MQ 的基本结构</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904172912.png"><img src="/../pic/20210904172912.png" alt="img"></a></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>RabbitMQ 官方提供了 5 个不同的 Demo 示例，对应了不同的消息模型。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904173739.png"><img src="/../pic/20210904173739.png" alt="img"></a></p>
<p>Hello World 模型</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904200637.png"><img src="/../pic/20210904200637.png" alt="img"></a></p>
<p>官方的 HelloWorld 是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<h3 id="publisher实现"><a href="#publisher实现" class="headerlink" title="publisher实现"></a>publisher实现</h3><ul>
<li>建立连接</li>
<li>创建 channel</li>
<li>声明队列</li>
<li>发送消息</li>
<li>关闭连接和 channel</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.211.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitMQ！&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：[&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="consumer实现"><a href="#consumer实现" class="headerlink" title="consumer实现"></a>consumer实现</h3><ul>
<li>建立连接</li>
<li>创建 channel</li>
<li>声明队列</li>
<li>订阅消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.211.128&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：[&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><p>SpringAMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 SpringBoot 对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAMQP 的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904202046.png"><img src="/../pic/20210904202046.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904202056.png"><img src="/../pic/20210904202056.png" alt="img"></a></p>
<p>SpringAMQP 提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了 RabbitTemplate 工具，用于发送消息</li>
</ul>
<p>在父工程增加这个pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="BasicQueue"><a href="#BasicQueue" class="headerlink" title="BasicQueue"></a>BasicQueue</h3><p>首先配置 MQ地址，在 publisher、consumer 服务中的 application.yml 中添加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">120.48</span><span class="number">.132</span><span class="number">.242</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>

<p>在 consumer 服务中添加监听队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 publisher 服务中添加发送消息的测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;哈喽啊&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904211238.png"><img src="/../pic/20210904211238.png" alt="img"></a></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>
<p>此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>
<p>我们循环发送，模拟大量消息堆积现象，在 publisher 服务中的 SpringAmqpTest 类中添加一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * workQueue</span></span><br><span class="line"><span class="comment"> * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息接收</strong></p>
<p>要模拟多个消费者绑定同一个队列，我们在 consumer 服务的 RabbitMQListener 中添加2个新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 ConsumerApplication 后，在执行 publisher 服务中刚刚编写的发送测试方法 testWorkQueue</p>
<p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p>
<p>也就是说消息是<strong>平均分配给每个消费者</strong>，并没有考虑到消费者的处理能力。这是因为 RabbitMQ 默认有一个消息预取机制（就是先直接分配），显然这不是我们想要的结果，我们需要的是能者多劳嘛，所以去限制每次只能取一条消息，可以解决这个问题。</p>
<p>在 spring 中有一个简单的配置，设置 prefetch 属性，我们修改 consumer 服务的 application.yml 文件，添加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>

<p>Work 模型的使用：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置 prefetch 来控制消费者预取的消息数量</li>
</ul>
<h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><p>在之前我们提出了一个问题，如果想把消息都发送给消费者，目前是不可取的，因为一个消费者吸收了这条消息就没有了，所以我们引入了<strong>一个exchange角色</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904213455.png"><img src="/../pic/20210904213455.png" alt="img"></a></p>
<p>图中可以看到，在订阅模型中，多了一个 exchange 角色，而且过程略有变化</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，<strong>而是发给 exchange（交换机）</strong></li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息</li>
<li>Exchange：交换机，一方面，接收生产者发送的消息；另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange 的类型。Exchange 有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定 routing key 的队列</li>
<li>Topic：通配符，把消息交给符合 routing pattern（路由模式） 的队列</li>
</ul>
</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>Fanout，英文翻译是扇出，在 MQ 中我们也可以称为广播。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912160350.png"><img src="/../pic/20210912160350.png" alt="img"></a></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>可以有多个队列</li>
<li>每个队列都要绑定到 Exchange（交换机）</li>
<li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ul>
<p>接下里我们用 SpringAMQP 来简单实现 FanoutExchange</p>
<ol>
<li>在 consumer 服务中，利用代码声明队列、交换机，并将两者绑定</li>
<li>在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2</li>
<li>在 publisher 中编写测试方法，向 fanout发送消息</li>
</ol>
<p><strong>声明队列和交换机</strong></p>
<p>Spring 提供了一个接口 Exchange，来表示所有不同类型的交换机。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210904213809.png"><img src="/../pic/20210904213809.png" alt="img"></a></p>
<p>在 consumer 中创建一个类，声明队列、交换机、<strong>绑定对象 Binding</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hh.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(FanoutExchange fanoutExchange,Queue fanoutQueue1)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(FanoutExchange fanoutExchange,Queue fanoutQueue2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>通过这样 <code>@Bean</code> 的方式来申明确</p>
<p>实比较麻烦，其实我们也是可以直接通过 <code>@RabbitListener</code> 注解来完成的，代码如下：</p>
<p>在 consumer 服务的 SpringRabbitListener 中添加三个方法，作为消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到fanout.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;接收到fanout.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(value = &quot;fanout.queue3&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(value = &quot;xn2001.fanout&quot;,type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue3</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到fanout.queue3的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fanout</span></span><br><span class="line"><span class="comment"> * 向交换机发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hh.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, every one!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);<span class="comment">//第二个参数还没学，为空就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该方法，可以发现 fanout.queue1、fanout.queue2 都收到了交换机的消息。</p>
<p><img src="/../pic/image-20220918160354167.png" alt="image-20220918160354167"></p>
<p>总结一下：</p>
<p>交换机的作用是什么？</p>
<ul>
<li>接收 publisher 发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，消息丢失</li>
<li>FanoutExchange 会将所有消息路由到<strong>每个</strong>绑定的队列</li>
</ul>
<h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><p>在 Fanout 模式中，一条消息，会被所有订阅的队列都消费。</p>
<p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 DirectExchange</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912182822.png"><img src="/../pic/20210912182822.png" alt="img"></a></p>
<p>在 Direct 模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key），但是<code>RoutingKey</code>可能并不只有一个,所以说，Direct仍然可以实现Fanout的功能</li>
<li>消息的发送方向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code> 与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p>在 consumer 的 SpringRabbitListener 中添加两个消费者，同时基于注解来声明队列和交换机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(value = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(value = &quot;hh.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;a&quot;,&quot;b&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(value = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(value = &quot; hh.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;a&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个的方法交换机是一个，但是队列和key是不同的</p>
<p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * direct</span></span><br><span class="line"><span class="comment"> * 向交换机发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchangeToA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hh.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, i am direct to a!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;a&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * direct</span></span><br><span class="line"><span class="comment"> * 向交换机发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchangeToB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hh.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, i am direct to b!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;b&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><code>Topic </code> 与 <code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p>
<p>只不过<code>Topic </code>类型可以让队列在绑定<code>Routing key</code> 的时候使用通配符</p>
<p>通配符规则：</p>
<p><code>#</code>：匹配一个或多个词</p>
<p><code>*</code>：只能匹配一个词</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item.#`：能够匹配`item.spu.insert` 或者 `item.spu</span><br><span class="line">item.*`：只能匹配`item.spu</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912194016.png"><img src="/../pic/20210912194016.png" alt="img"></a></p>
<ul>
<li>Queue1：绑定的是 <code>china.#</code> ，因此凡是以 <code>china.</code> 开头的 <code>routing key</code> 都会被匹配到。包括 china.news 和 china.weather</li>
<li>Queue2：绑定的是 <code>#.news</code> ，因此凡是以 <code>.news </code> 结尾的 <code>routing key</code> 都会被匹配。包括 china.news 和 japan.news</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(value = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(value = &quot;hh.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;china.#&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(value = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(value = &quot;hh.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;china.*&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topic</span></span><br><span class="line"><span class="comment"> * 向交换机发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hh.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message1</span> <span class="operator">=</span> <span class="string">&quot;hello, i am topic form china.news&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> <span class="string">&quot;hello, i am topic form china.news.2&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message1);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news.2&quot;</span>, message2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912200012.png"><img src="/../pic/20210912200012.png" alt="img"></a></p>
<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。</p>
<p><strong>默认情况下 Spring 采用的序列化方式是 JDK 序列化。</strong></p>
<p>我们可以去试一下效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;object.queue&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenObjectQueue</span><span class="params">(Map&lt;String,Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;object接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912204117.png"><img src="/../pic/20210912204117.png" alt="img"></a></p>
<p>众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>我们推荐可以使用 JSON 来序列化</p>
<p>在 publisher 和 consumer 两个服务中都引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置消息转换器。</p>
<p>在各自的启动类中添加一个 Bean 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210912204512.png"><img src="/../pic/20210912204512.png" alt="img"></a></p>
<h1 id="ELasticsearch搜索引擎"><a href="#ELasticsearch搜索引擎" class="headerlink" title="ELasticsearch搜索引擎"></a>ELasticsearch搜索引擎</h1><p>ELasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容，可以用来实现搜索、日志统计、分析、系统监控等功能。</p>
<p><img src="/../pic/20210918202359.png" alt="img"></p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><strong>首先，倒排索引的概念是基于 MySQL 这样的正向索引而言的。</strong></p>
<p>那么我们先讲何为正向索引。例如给下表（tb_goods）中的 id 创建索引</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918202527.png"><img src="/../pic/20210918202527.png" alt="img"></a></p>
<p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p>
<ol>
<li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li>
<li>逐行获取数据，比如 id 为 1 的数据</li>
<li>判断数据中的 title 是否符合用户搜索条件</li>
<li>如果符合则放入结果集，不符合则丢弃。然后回到步骤1</li>
</ol>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就会很慢很慢。。。。</p>
<p>而倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li>
</ul>
<p>如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918203514.png"><img src="/../pic/20210918203514.png" alt="img"></a></p>
<p><strong>倒排索引的搜索流程</strong>如下（以搜索”华为手机”为例）</p>
<ol>
<li>用户输入条件<code>&quot;华为手机&quot;</code>进行搜索</li>
<li>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code></li>
<li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id 有 1、2、3</li>
<li>拿着文档 id 到正向索引中查找具体文档</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918203815.png"><img src="/../pic/20210918203815.png" alt="img"></a></p>
<p><strong>虽然要先查询倒排索引，再查询正向索引，但是词条和文档id 都建立了索引，查询速度非常快！无需全表扫描。</strong></p>
<p>为什么一个叫做正向索引，一个叫做倒排索引呢？</p>
<p><strong>正向索引</strong>是最传统的，根据 id 索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong></p>
<p><strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据得到的文档 id 获取该文档。是<strong>根据词条找文档的过程</strong></p>
<h2 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h2><p>elasticsearch 是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 json 格式后存储在 elasticsearch</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918212707.png"><img src="/../pic/20210918212707.png" alt="img"></a></p>
<p>而 JSON 文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h2 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h2><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918213357.png"><img src="/../pic/20210918213357.png" alt="img"></a></p>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<p><strong>mysql 与 elasticsearch</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL</strong></th>
<th align="left"><strong>Elasticsearch</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Table</td>
<td align="left">Index</td>
<td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td align="left">Row</td>
<td align="left">Document</td>
<td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td align="left">Column</td>
<td align="left">Field</td>
<td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td align="left">Schema</td>
<td align="left">Mapping</td>
<td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td align="left">SQL</td>
<td align="left">DSL</td>
<td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<ul>
<li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li>
<li>Elasticsearch：擅长海量数据的搜索、分析、计算</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li>对安全性要求较高的写操作，使用 MySQL 实现</li>
<li>对查询性能要求较高的搜索需求，使用 ELasticsearch 实现</li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918213631.png"><img src="/../pic/20210918213631.png" alt="img"></a></p>
<h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><p>因为我们还需要部署 kibana 容器，需要让 es 和 kibana 容器互联。这里先创建一个网络：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker network create es-net </span><br></pre></td></tr></table></figure>

<p>之后运行命令加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i es.tar</span><br></pre></td></tr></table></figure>

<p>同理还有kibana的tar包也需要这样做</p>
<p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">-e <span class="string">&quot;ES_JAVA_OPTS=-Xms216m -Xmx216m&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">-v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">--privileged \</span><br><span class="line">--network es-net \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为 es-net 的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>访问地址：<a href="http://120.48.132.242:9200即可看到">http://120.48.132.242:9200即可看到</a> elasticsearch 的响应结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918214620.png"><img src="/../pic/20210918214620.png" alt="img"></a></p>
<h2 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h2><p>kibana 可以给我们提供一个 elasticsearch 的可视化界面，便于我们学习命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=es-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--network es-net</code> ：加入一个名为 es-net 的网络中，与 elasticsearch 在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置 elasticsearch 的地址，因为 kibana 已经与 elasticsearch 在一个网络，因此可以用容器名直接访问 elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>访问地址：<a href="http://120.48.132.242:5601，即可看到结果">http://120.48.132.242:5601，即可看到结果</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918214722.png"><img src="/../pic/20210918214722.png" alt="img"></a></p>
<p>控制面板：<a target="_blank" rel="noopener" href="http://120.48.132.242:5601/app/dev_tools#/console">http://120.48.132.242:5601/app/dev_tools#/console</a></p>
<h2 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h2><p>由于国内访问 GitHub 较慢，我们选择离线模式安装。</p>
<p>安装插件需要知道 elasticsearch 的 plugins 目录位置，而我们用了数据卷挂载，因此需要查看 elasticsearch 的数据卷目录，通过下面命令查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure>

<p>显示结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>说明 plugins 目录被挂载到了 <code>/var/lib/docker/volumes/es-plugins/_data </code> 这个目录中</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918215615.png"><img src="/../pic/20210918215615.png" alt="img"></a></p>
<p>重启容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、重启容器</span></span><br><span class="line">docker restart es</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看es日志</span></span><br><span class="line">docker logs -f es</span><br></pre></td></tr></table></figure>

<p>IK分词器包含两种模式：</p>
<ul>
<li><code>ik_smart</code>：智能切分，粗粒度</li>
<li><code>ik_max_word</code>：最细切分，细粒度</li>
</ul>
<p>我们在上面的 Kibana 控制台测试</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;钟老师你好菜啊&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h2><p>在上面的IK分词器我们可以随着热点词来扩展，可以自己添加，比如 ”钟老师应该是一个热点词“，另外你也可以配置一些停用掉的敏感词，让其不进行分词。</p>
<p>打开IK分词器 config 目录是 <code>IKAnalyzer.cfg.xml</code>，添加一个文件名，我们以 <code>ext.dic</code> 文件名为例。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918221159.png"><img src="/../pic/20210918221159.png" alt="img"></a></p>
<p>我们去创建 <code>ext.dic</code> ，在其中添加热点词就好了，一个词一行。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918220910.png"><img src="/../pic/20210918220910.png" alt="img"></a></p>
<p>重启 elasticsearch</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure>

<p>重新测试</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;钟老师你好菜啊&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210918221424.png"><img src="/../pic/20210918221424.png" alt="img"></a></p>
<h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><h3 id="Mapping属性映射"><a href="#Mapping属性映射" class="headerlink" title="Mapping属性映射"></a>Mapping属性映射</h3><p>索引库就类似数据库表，<strong>mapping 映射就类似表的结构</strong></p>
<p>我们要向 es 中存储数据，必须先创建“库”和“表”</p>
<p>mapping 是对索引库中文档的约束，常见的 mapping 属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li><strong>index：是否创建索引，默认为 true</strong></li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>我们以需要存储下面的 JSON 为例来讲解</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你是猪猪&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1499487526@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;白&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>首先对应的每个字段映射（mapping）情况如下：</p>
<ul>
<li>age：类型为 integer；参与搜索，index 为 true；无需分词器</li>
<li>weight：类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，index 为 true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是 text；参与搜索，index为true；分词器可以用 ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，index 为 false；无需分词器</li>
<li>score：虽然是数组，<strong>但是我们只看元素的类型</strong>，类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>name：类型为 object，需要定义多个子属性<ul>
<li>name.firstName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
<li>name.lastName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
</ul>
</li>
</ul>
<h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p>上面我们了解了 Mapping 属性映射，接下来我们就去看看如何创建索引库及映射。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /xiaoabaicai</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>我们用真实的数据库表来创建一个索引库</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210919164626.png"><img src="/../pic/20210919164626.png" alt="img"></a></p>
<ul>
<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>
<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>
<li>是否分词呢要看内容，内容如果是一个整体就无需分词</li>
<li>分词器，我们可以统一使用 <code>ik_max_word</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值利用 <code>copy_to</code> 合并，提供给用户搜索，这样一来就只需要搜索一个字段就可以得到结果，性能更好。</li>
</ul>
<p><img src="/../pic/image-20220924120108610.png" alt="image-20220924120108610"></p>
<blockquote>
<p>ES中支持两种地理坐标数据类型：</p>
<ul>
<li>geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：”32.8752345, 120.2981576”</li>
<li>geo_shape：有多个 geo_point 组成的复杂几何图形。例如一条直线，”LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</li>
</ul>
</blockquote>
<h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改 mapping</strong></p>
<p>&#x3D;&#x3D;虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，不会对倒排索引产生影响。&#x3D;&#x3D;</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure>

<h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /数据库名</span><br></pre></td></tr></table></figure>

<h2 id="DSL文档操作"><a href="#DSL文档操作" class="headerlink" title="DSL文档操作"></a>DSL文档操作</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST /xiaobaicai/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我不会Java&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1499487526@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;昊昊&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;天&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p><strong>全量修改</strong>是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的 id 删除文档</li>
<li>新增一个相同 id 的文档</li>
</ul>
<p><strong>注意</strong>：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就是变成了新增操作</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">PUT /xiaobaicai/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我不会敲代码&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1499487527@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;天&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;昊昊&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>









<p><strong>增量修改（局部修改）</strong>是只修改指定 id 匹配的文档中的部分字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST /heima/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;update@qq.com&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>







<h2 id="RestClient文档操作"><a href="#RestClient文档操作" class="headerlink" title="RestClient文档操作"></a>RestClient文档操作</h2><p>ES 官方提供了各种不同语言的客户端，用来操作 ES。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ES。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p>其中的Java Rest Client又包括两种：</p>
<ul>
<li>Java Low Level Rest Client</li>
<li>Java High Level Rest Client</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210919234405.png"><img src="/../pic/20210919234405.png" alt="img"></a></p>
<p>我们下面学习的是 <strong>Java HighLevel Rest Client 客户端 API</strong></p>
<h3 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h3><p>在 elasticsearch 提供的 API 中，elasticsearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 elasticsearch 的连接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot 默认的 ES 版本是 7.6.2，我们需要覆盖默认的ES版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>初始化 RestHighLevelClient，初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.211.128:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelIndexTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInit</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.restHighLevelClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.211.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><p><img src="/../pic/image-20220924125755838.png" alt="image-20220924125755838"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//指定索引库名</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">//写入JSON数据，这里是Mapping映射</span></span><br><span class="line">    hotel.source(HotelConstants.MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">//创建索引库</span></span><br><span class="line">    restHighLevelClient.indices().create(hotel, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    restHighLevelClient.indices().delete(hotel,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断索引库"><a href="#判断索引库" class="headerlink" title="判断索引库"></a>判断索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">existHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> restHighLevelClient.indices().exists(hotel, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><p><img src="/../pic/image-20220924130301152.png" alt="image-20220924130301152"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDocumentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//查询出来hotel对象</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">hotelIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        hotelIndex.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        restHighLevelClient.index(hotelIndex, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.211.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><p><img src="/../pic/image-20220924131817061.png" alt="image-20220924131817061"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">hotelResponse</span> <span class="operator">=</span> restHighLevelClient.get(hotel, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果,也就是得到_source里面的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hotelDocSourceAsString</span> <span class="operator">=</span> hotelResponse.getSourceAsString();</span><br><span class="line">    <span class="comment">// 4.json转实体类</span></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(hotelDocSourceAsString, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    restHighLevelClient.delete(hotel,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><p>前面我们说过，修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>所以全量修改写法与新增文档一样，下面我们主要是介绍增量修改。</p>
<p><img src="/../pic/image-20220924132204691.png" alt="image-20220924132204691"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">&quot;price&quot;</span>, <span class="string">&quot;952&quot;</span>,</span><br><span class="line">        <span class="string">&quot;starName&quot;</span>, <span class="string">&quot;四钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    restHighLevelClient.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h3><p>前情回归：</p>
<p>插入单个文档</p>
<p>案例需求：利用 <code>BulkRequest</code> 批量将数据库数据导入到索引库中。</p>
<ul>
<li>利用 mybatis-plus 查询酒店数据</li>
<li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li>
<li>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</li>
</ul>
<p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210919234350.png"><img src="/../pic/20210919234350.png" alt="img"></a></p>
<p>实例代码</p>
<p><img src="/../pic/image-20220924134059801.png" alt="image-20220924134059801"></p>
<hr>
<p>总之，在 Java 代码中，client 针对操作索引库还是文档，基本都是一样的代码</p>
<p>restHighLevelClient.indices().xxx，代表操作索引库</p>
<p>restHighLevelClient.xxx，代表操作文档</p>
<p>而其中所需要的参数，我们直接通过 <strong>ctrl+p</strong> 这样的快捷键去查看就可以，不需要单独记住。</p>
<h2 id="DSL文档查询"><a href="#DSL文档查询" class="headerlink" title="DSL文档查询"></a>DSL文档查询</h2><p>Elasticsearch 提供了基于 JSON 的 DSL(<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>)来定义查询。常见的查询类型包括：</p>
<p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p>
<p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
<p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
<p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
<p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
<hr>
<h3 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h3><p><img src="/../pic/image-20220924135536448.png" alt="image-20220924135536448"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>使用场景：全文检索查询的基本流程如下：</p>
<ul>
<li>对用户搜索的内容做分词，得到词条</li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户</li>
</ul>
<p>比较常用的场景包括： </p>
<ul>
<li>商城的输入框搜索</li>
<li>百度输入框搜索</li>
</ul>
<p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p>
<p>常见的全文检索查询包括：</p>
<ul>
<li>match 查询：单字段查询</li>
<li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>
</ul>
<p>match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>mulit_match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FIELD1&quot;</span><span class="punctuation">,</span> <span class="string">&quot; FIELD12&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为我们将 brand、name、business 值都利用 <strong>copy_to</strong> 复制到了 <strong>all</strong> 字段中，你根据三个字段搜索，和根据 all字段搜索效果是一样的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7天酒店&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7天酒店&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;brand&quot;</span><span class="punctuation">,</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span><span class="string">&quot;business&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>搜索字段越多，对查询性能影响越大，因此建议采用 copy_to 将多个字段合并为一个，然后使用单字段查询的方式。</strong></p>
<h3 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h3><p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以<strong>不会</strong>对搜索条件分词。</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>
<p>语法说明：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>下面搜索的是<code>brand</code>为<code>7天酒店</code>的文档数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7天酒店&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
<p>基本语法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>下面表示查询字段<code>price</code>在<code>1000和3000</code>之间的文档数据</p>
<p>gte是大于等于 </p>
<p>gt是大于</p>
<p>lte同理</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921182858.png"><img src="/../pic/20210921182858.png" alt="img"></a></p>
<p>精确查询常见的有哪些？</p>
<ul>
<li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li>
<li>range 查询：根据数值范围查询，可以是数值、日期的范围</li>
</ul>
<h3 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p>地理坐标查询，其实就是根据经纬度查询，官方文档：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p>
<p>常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人</li>
</ul>
<p>附近的酒店：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921183030.png"><img src="/../pic/20210921183030.png" alt="img"></a></p>
<p>附近的车：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921183033.png"><img src="/../pic/20210921183033.png" alt="img"></a></p>
<blockquote>
<p>矩形范围查询</p>
</blockquote>
<p>矩形范围查询，也就是 <code>geo_bounding_box</code> 查询，查询坐标落在某个矩形范围的所有文档</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921183124.gif"><img src="/../pic/20210921183124.gif" alt="img"></a></p>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.7</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>附近查询</p>
</blockquote>
<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档</p>
<p>在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921183215.gif"><img src="/../pic/20210921183215.gif" alt="img"></a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;distance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15km&quot;</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>搜索陆家嘴附近15km的酒店（需要注意的是location字段是和文档中的字段是一致的）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921183228.png"><img src="/../pic/20210921183228.png" alt="img"></a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.034661,121.612282&quot;</span><span class="punctuation">,</span> <span class="comment">//圆心</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span> <span class="comment">//排序</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span> <span class="comment">//单位</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;hotel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2056298828&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">4.8541199685347785</span> <span class="comment">//这里的结果为离圆心的距离</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>注意：输出结果中的 <strong>sort</strong> 为距离，比较常用。</p>
<p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211019011334.png"><img src="/../pic/20211019011334.png" alt="img"></a></p>
<h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
<h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><blockquote>
<p>这部分内容作为了解即可。</p>
</blockquote>
<p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;虹桥如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;外滩如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;迪士尼如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>elasticsearch 早期使用的打分算法是 <strong>TF-IDF 算法</strong>，公式如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921205752.png"><img src="/../pic/20210921205752.png" alt="img"></a></p>
<p>在后来的5.1版本升级中，elasticsearch 将算法改进为 <strong>BM25 算法</strong>，公式如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921205757.png"><img src="/../pic/20210921205757.png" alt="img"></a></p>
<p>TF-IDF 算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而 BM25 则会让单个词条的算分有一个上限，曲线更加平滑：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921205831.png"><img src="/../pic/20210921205831.png" alt="img"></a></p>
<h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><p>根据相关度打分是比较合理的需求，但有时候也不能够满足我们的需求。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁给的钱多排名就越靠前。</p>
<p><strong>要想认为控制相关性算分，就需要利用 elasticsearch 中的 function score 查询了。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921210256.png"><img src="/../pic/20210921210256.png" alt="img"></a></p>
<p>function score 查询中包含四部分内容：</p>
<ul>
<li><p><strong>原始查询</strong>条件：query 部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</p>
</li>
<li><p><strong>过滤条件</strong>：filter 部分，符合该条件的文档才会<strong>重新算分</strong></p>
</li>
<li><p>算分函数：符合 filter 条件的文档要根据这个函数做运算，得到的</p>
<p>函数算分（function score），有四种函数</p>
<ul>
<li>weight：函数结果是常量</li>
<li>field_value_factor：以文档中的某个字段值作为函数结果</li>
<li>random_score：以随机数作为函数结果</li>
<li>script_score：自定义算分函数算法</li>
</ul>
</li>
<li><p>运算模式 ：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：</p>
<ul>
<li>multiply：相乘</li>
<li>replace：用 function score 替换 query score</li>
<li>sum、avg、max、min</li>
</ul>
</li>
</ul>
<p>function score 的运行流程如下：</p>
<ol>
<li>根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>根据<strong>过滤条件</strong>，过滤文档</li>
<li>符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ol>
<p>因此，其中的关键点是</p>
<ul>
<li>过滤条件：决定哪些文档的算分被修改</li>
<li>算分函数：决定函数算分的算法</li>
<li>运算模式：决定最终算分结果</li>
</ul>
<p>例如：我们给“如家”这个品牌的酒店排名靠前一些</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  .... <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 算分函数</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// 算分权重为10</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试，在未添加算分函数时，如家得分如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921231508.png"><img src="/../pic/20210921231508.png" alt="img"></a></p>
<p>添加了算分函数后，如家得分就提升了</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921231513.png"><img src="/../pic/20210921231513.png" alt="img"></a></p>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong></li>
</ul>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤</p>
<p><strong>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool查询了。</strong></p>
<p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li>
<li>其它过滤条件，采用 filter 查询，不参与算分</li>
</ul>
<p>下面这个查询语句的意思是：city必须为上海，brand可以是皇冠假日也可以是华美达，lte是小于等于，price要大于500，score要大于45</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;上海&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;皇冠假日&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华美达&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">500</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">45</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>







<p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分，放到 must 中</li>
<li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分，放到 must_not 中</li>
<li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分，放到 filter 中</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921233252.png"><img src="/../pic/20210921233252.png" alt="img"></a></p>
<p>bool 查询的几种逻辑关系</p>
<ul>
<li>must：必须匹配的条件，可以理解为“与”</li>
<li>should：选择性匹配的条件，可以理解为“或”</li>
<li>must_not：必须不匹配的条件，不参与打分</li>
<li>filter：必须匹配的条件，不参与打分</li>
</ul>
<h2 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>elasticsearch 默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等</p>
<p>keyword、数值、日期类型排序的语法基本一致。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序。</p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921233829.png"><img src="/../pic/20210921233829.png" alt="img"></a></p>
<p>地理坐标排序略有不同</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;纬度，经度&quot;</span><span class="punctuation">,</span> <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.034661,121.612282&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span> </span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取你的位置的经纬度的方式：<a target="_blank" rel="noopener" href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat</a></p>
</blockquote>
<p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921233931.png"><img src="/../pic/20210921233931.png" alt="img"></a></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>elasticsearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。</p>
<p>elasticsearch 通过修改 from、size 参数来控制要返回的分页结果：</p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的<code>limit ?, ?</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>深度分页问题</p>
</blockquote>
<p>现在，我要查询990~1000的数据，查询逻辑要这么写</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p>注意：elasticsearch 内部分页时，必须先查询 0~1000条，然后截取其中的 990 ~ 1000 的这10条</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921234503.png"><img src="/../pic/20210921234503.png" alt="img"></a></p>
<p>查询TOP1000，如果 es 是单点模式，这并无太大影响。</p>
<p>但是 elasticsearch 将来一定是集群，例如我集群有5个节点，我要查询 TOP1000 的数据，并不是每个节点查询200条就可以了。节点A的 TOP200，在另一个节点可能排到10000名以外了。</p>
<p><strong>因此要想获取整个集群的 TOP1000，必须先查询出每个节点的 TOP1000，汇总结果后，重新排名，重新截取 TOP1000。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921234555.png"><img src="/../pic/20210921234555.png" alt="img"></a></p>
<p><strong>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此 elasticsearch 会禁止from+ size 超过10000的请求。</strong></p>
<p>针对深度分页，ES提供了两种解决方案，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p>
<ul>
<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li>
<li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li>
</ul>
<hr>
<p>分页查询的常见实现方案以及优缺点</p>
<ul>
<li><code>from + size</code><ul>
<li>优点：支持随机翻页</li>
<li>缺点：深度分页问题，默认查询上限（from + size）是10000</li>
<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li>
</ul>
</li>
<li><code>after search</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：只能向后逐页查询，不支持随机翻页</li>
<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li>
</ul>
</li>
<li><code>scroll</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li>
</ul>
</li>
</ul>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921234711.png"><img src="/../pic/20210921234711.png" alt="img"></a></p>
<p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span>  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：<code>required_field_match=false</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921234739.png"><img src="/../pic/20210921234739.png" alt="img"></a></p>
<blockquote>
<p>DSL 总体结构如下：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20210921235330.png"><img src="/../pic/20210921235330.png" alt="img"></a></p>
<h2 id="RestClient文档查询"><a href="#RestClient文档查询" class="headerlink" title="RestClient文档查询"></a>RestClient文档查询</h2><h3 id="发起查询请求"><a href="#发起查询请求" class="headerlink" title="发起查询请求"></a>发起查询请求</h3><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016170057.png"><img src="/../pic/20211016170057.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelSearchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">match_All</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        request.source()</span><br><span class="line">                .query(QueryBuilders.matchAllQuery());</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.211.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p>
</li>
<li><p>第二步，利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.source()</span><br></pre></td></tr></table></figure>

<p>构建 DSL，DSL 中可以包含查询、分页、排序、高亮等</p>
<ul>
<li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li>
</ul>
</li>
<li><p>第三步，利用 <code>client.search()</code> 发送请求，得到响应</p>
</li>
</ul>
<p>关键的 API 有两个，一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016170203.png"><img src="/../pic/20211016170203.png" alt="img"></a></p>
<p>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016170234.png"><img src="/../pic/20211016170234.png" alt="img"></a></p>
<h3 id="解析查询响应"><a href="#解析查询响应" class="headerlink" title="解析查询响应"></a>解析查询响应</h3><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016174631.png"><img src="/../pic/20211016174631.png" alt="img"></a></p>
<p>Elasticsearch 返回的结果是一个 JSON 字符串，结构包含</p>
<ul>
<li><p>&#96;&#96;&#96;<br>hits</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：命中的结果</span><br><span class="line"></span><br><span class="line">- `total`：总条数，其中的value是具体的总条数值</span><br><span class="line"></span><br><span class="line">- `max_score`：所有结果中得分最高的文档的相关性算分</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  hits</span><br></pre></td></tr></table></figure>

<p>  ：搜索结果的文档数组，其中的每个文档都是一个 json 对象</p>
<ul>
<li><code>_source</code>：文档中的原始数据，也是 json 对象</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下</p>
<ul>
<li><p>&#96;&#96;&#96;<br>SearchHits</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：通过</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>response.getHits()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">获取，就是 json 中的最外层的 hits，代表命中的结果</span><br><span class="line"></span><br><span class="line">- `SearchHits.getTotalHits().value`：获取总条数信息</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  SearchHits.getHits()</span><br></pre></td></tr></table></figure>

<p>  ：获取 SearchHit 数组，也就是文档数组</p>
<ul>
<li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的 <code>_source</code>，也就是原始的 json 文档数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelSearchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">match_All</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        request.source()</span><br><span class="line">                .query(QueryBuilders.matchAllQuery());</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">        System.out.println(<span class="string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);</span><br><span class="line">        SearchHit[] hits = searchHits.getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">            <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);</span><br><span class="line">            System.out.println(hotelDoc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.211.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.restHighLevelClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016182859.png"><img src="/../pic/20211016182859.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    request.source()</span><br><span class="line">            .query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>,<span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    System.out.println(<span class="string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiMatchQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    request.source()</span><br><span class="line">            .query(QueryBuilders.multiMatchQuery(<span class="string">&quot;如家&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    System.out.println(<span class="string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询主要是两者</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016192658.png"><img src="/../pic/20211016192658.png" alt="img"></a></p>
<h3 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是用 must、must_not、filter等方式组合其它查询，代码示例如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016192745.png"><img src="/../pic/20211016192745.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">            .query(</span><br><span class="line">                    QueryBuilders.boolQuery()</span><br><span class="line">                            .must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;上海&quot;</span>))</span><br><span class="line">                            .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">300</span>))</span><br><span class="line">            );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    System.out.println(<span class="string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序、分页"><a href="#排序、分页" class="headerlink" title="排序、分页"></a>排序、分页</h3><p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p>
<p>对应的API如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016202447.png"><img src="/../pic/20211016202447.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    System.out.println(<span class="string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);</span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);</span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h3><ul>
<li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li>
<li>结果解析：结果除了要解析 <code>_source</code> 文档数据，还要解析高亮结果</li>
</ul>
<p><strong>高亮请求的构建 API</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211016202707.png"><img src="/../pic/20211016202707.png" alt="img"></a></p>
<p>上述代码省略了查询条件部分，但是高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response); <span class="comment">//代码在下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>高亮结果解析</strong></p>
<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p>[<img src="/../pic/20211016202853.png" alt="img"> </p>
<ul>
<li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json 字符串，需要反序列为 HotelDoc 对象</li>
<li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是HighlightField 对象，代表高亮值</li>
<li>第三步：从 map 中根据高亮字段名称，获取高亮字段值对象 HighlightField</li>
<li>第四步：从 HighlightField 中获取 Fragments，并且转为字符串。<strong>这部分是真正的高亮字符串</strong></li>
<li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="地理坐标查询-1"><a href="#地理坐标查询-1" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211019000540.png"><img src="/../pic/20211019000540.png" alt="img"></a></p>
<h3 id="相关性得分"><a href="#相关性得分" class="headerlink" title="相关性得分"></a>相关性得分</h3><p>function_score 查询结构如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211019011433.png"><img src="/../pic/20211019011433.png" alt="img"></a></p>
<p>对应的 JavaAPI 如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211019011439.png"><img src="/../pic/20211019011439.png" alt="img"></a></p>
<h2 id="DSL数据聚合"><a href="#DSL数据聚合" class="headerlink" title="DSL数据聚合"></a>DSL数据聚合</h2><p>**<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。</p>
<ul>
<li>什么品牌的手机最受欢迎？</li>
<li>这些手机的平均价格、最高价格、最低价格？</li>
<li>这些手机每月的销售情况如何？</li>
</ul>
<p>在 Elasticsearch 实现这些统计功能比数据库的 sql 要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p>
<p>聚合常见的有三类</p>
<ul>
<li><strong>桶（Bucket）</strong>聚合：用来对文档做分组<ul>
<li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li>
<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>
</ul>
</li>
<li><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul>
<li>Avg：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stats：同时求 max、min、avg、sum 等</li>
</ul>
</li>
<li><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</li>
</ul>
<blockquote>
<p><strong>注意</strong>：参加聚合的字段必须是keyword、日期、数值、布尔类型</p>
</blockquote>
<h3 id="Bucket聚合语法"><a href="#Bucket聚合语法" class="headerlink" title="Bucket聚合语法"></a>Bucket聚合语法</h3><p>例如：我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是 Bucket 聚合。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// 希望获取的聚合结果数量</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211022184007.png"><img src="/../pic/20211022184007.png" alt="img"></a></p>
<p>默认情况下，Bucket 聚合会统计 Bucket 内的文档数量，记为 <code>_count</code>，并且按照 <code>_count</code> 降序排序。</p>
<p>我们可以指定 order 属性，自定义聚合的排序方式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="comment">// 按照_count升序排列</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p>
<p>我们可以限定要聚合的文档范围，只要添加 query 条件即可；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这次，聚合得到的品牌明显变少了</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211022184549.png"><img src="/../pic/20211022184549.png" alt="img"></a></p>
<h3 id="Metric聚合语法"><a href="#Metric聚合语法" class="headerlink" title="Metric聚合语法"></a>Metric聚合语法</h3><p>上面，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的 min、max、avg 等值。</p>
<p>这就要用到 Metric 聚合了，例如 stats 聚合：就可以获取 min、max、avg 等结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这次的 score_stats 聚合是在 brandAgg 的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p>
<p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211022184847.png"><img src="/../pic/20211022184847.png" alt="img"></a></p>
<h2 id="RestAPI数据聚合"><a href="#RestAPI数据聚合" class="headerlink" title="RestAPI数据聚合"></a>RestAPI数据聚合</h2><p>聚合条件与 query 条件同级别，因此需要使用 <code>request.source()</code> 来指定聚合条件</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211022190429.png"><img src="/../pic/20211022190429.png" alt="img"></a></p>
<p>聚合的结果也与查询结果不同，API 也比较特殊。不过同样是 JSON 逐层解析</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211022190457.png"><img src="/../pic/20211022190457.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAggregation</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    request.source().aggregation(AggregationBuilders.terms(<span class="string">&quot;brandAgg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>).size(<span class="number">20</span>));</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandAgg</span> <span class="operator">=</span> response.getAggregations().get(<span class="string">&quot;brandAgg&quot;</span>);</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandAgg.getBuckets();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，提示完整词条的功能，就是自动补全了。</p>
<h3 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h3><p>如果我们需要根据拼音字母来推断，因此要用到拼音分词功能。</p>
<p>要实现根据字母做补全，就必须对文档按照拼音分词。插件地址：<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211023015636.png"><img src="/../pic/20211023015636.png" alt="img"></a></p>
<p>使用 <code>docker volume inspect es-plugins</code> 查看插件目录，将下载的文件解压上传，重启 Elasticsearch</p>
<p>测试用法如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家酒店还不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211023021713.png"><img src="/../pic/20211023021713.png" alt="img"></a></p>
<h3 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h3><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p>
<p>elasticsearch 中分词器（analyzer）的组成包含三部分：</p>
<ul>
<li>character filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如 keyword，就是不分词；还有 ik_smart</li>
<li>tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>
</ul>
<p>文档分词时会依次由这三部分来处理文档：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211023021451.png"><img src="/../pic/20211023021451.png" alt="img"></a></p>
<p>声明自定义分词器的语法如下：(这个自定义分词器可以不用自己写，直接copy会用就行)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 过滤器名称</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span> <span class="comment">// 过滤器类型，这里是pinyin</span></span><br><span class="line">		  <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_analyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211023021532.png"><img src="/../pic/20211023021532.png" alt="img"></a></p>
<p>注意<strong>：为了避免搜索到同音字，搜索时不要使用拼音分词器</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211023022355.png"><img src="/../pic/20211023022355.png" alt="img"></a></p>
<h3 id="自动补全查询"><a href="#自动补全查询" class="headerlink" title="自动补全查询"></a>自动补全查询</h3><p>elasticsearch 提供了 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a> 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回；为了提高补全查询的效率，对于文档中字段的类型有一些约束</p>
<ul>
<li>参与补全查询的字段必须是 completion 类型。</li>
<li>字段的内容一般是用来补全的多个词条形成的数组。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">PUT test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后插入下面的数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Sony&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WH-1000XM3&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;SK-II&quot;</span><span class="punctuation">,</span> <span class="string">&quot;PITERA&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Nintendo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;switch&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>查询的 DSL 语句如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动补全查询</span></span><br><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="comment">// 关键字</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span> <span class="comment">// 补全查询的字段</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 跳过重复的</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// 获取前10条结果</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如一个酒店的索引库完整案例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;text_anlyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;completion_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;suggestion&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion_analyzer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaAPI"><a href="#JavaAPI" class="headerlink" title="JavaAPI"></a>JavaAPI</h3><p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025113007.png"><img src="/../pic/20211025113007.png" alt="img"></a></p>
<p>解析响应的代码如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025113011.png"><img src="/../pic/20211025113011.png" alt="img"></a></p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>elasticsearch 中的数据来自于 mysql数据库，因此 mysql 数据发生改变时，elasticsearch 也必须跟着改变，这个就是 elasticsearch 与 mysql 之间的<strong>数据同步</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025163219.png"><img src="/../pic/20211025163219.png" alt="img"></a></p>
<p>常见的数据同步方案有三种</p>
<ul>
<li>同步调用</li>
<li>异步通知</li>
<li>监听 binlog</li>
</ul>
<h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>方案一：同步调用</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025163313.png"><img src="/../pic/20211025163313.png" alt="img"></a></p>
<ul>
<li>hotel-demo对外提供接口，用来修改 elasticsearch 中的数据</li>
<li>酒店管理服务在完成数据库操作后，直接调用 hotel-demo 提供的接口</li>
</ul>
<h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><p>方案二：异步通知</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025163346.png"><img src="/../pic/20211025163346.png" alt="img"></a></p>
<ul>
<li>hotel-admin 对 mysql 数据库数据完成增、删、改后，发送 MQ 消息</li>
<li>hotel-demo监听 MQ，接收到消息后完成 elasticsearch 数据修改</li>
</ul>
<h3 id="监听binlog"><a href="#监听binlog" class="headerlink" title="监听binlog"></a>监听binlog</h3><p>方案三：监听binlog</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025163428.png"><img src="/../pic/20211025163428.png" alt="img"></a></p>
<ul>
<li>mysql 开启 binlog 功能</li>
<li>mysql 完成增、删、改操作都会记录在 binlog 中</li>
<li>hotel-demo 基于canal 监听 binlog 变化，实时更新 elasticsearch 中的内容</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>方式一：同步调用</p>
<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高</li>
</ul>
<p>方式二：异步通知</p>
<ul>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖 mq 的可靠性</li>
</ul>
<p>方式三：监听binlog</p>
<ul>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启 binlog 增加数据库负担、实现复杂度高</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>我们以<strong>异步通知</strong>为例，使用 MQ 消息中间件</p>
<p>MQ结构如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2021/20211025163734.png"><img src="/../pic/20211025163734.png" alt="img"></a></p>
<p><strong>引入依赖</strong>，在 hotel-admin、hotel-demo 中引入 rabbitmq 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>声明队列交换机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConstants</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;hotel.topic&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.delete.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_KEY</span> <span class="operator">=</span> <span class="string">&quot;hotel.delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息接收方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;<span class="comment">//绑定交换机与队列的关系（也可以用注解实现）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertQueueBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteQueueBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息发送方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(MQConstants.HOTEL_EXCHANGE, MQConstants.HOTEL_INSERT_KEY, hotel.getId());</span><br><span class="line"></span><br><span class="line">rabbitTemplate.convertAndSend(MQConstants.HOTEL_EXCHANGE, MQConstants.HOTEL_DELETE_KEY, id);</span><br></pre></td></tr></table></figure>

<p>消息接收方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HotelService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据id查询酒店数据</span></span><br><span class="line">            <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">            <span class="comment">// 转换为文档类型</span></span><br><span class="line">            <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">            <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class="line">            request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">            client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, id.toString());</span><br><span class="line">            client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Elasticsearch集群"><a href="#Elasticsearch集群" class="headerlink" title="Elasticsearch集群"></a>Elasticsearch集群</h1><p>单机的 Elasticsearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>
<p>解决方案：</p>
<ul>
<li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li>
<li>单点故障问题：将分片数据在不同节点备份（replica ）</li>
</ul>
<p><strong>ES集群相关概念</strong>：</p>
<ul>
<li>集群（cluster）：一组拥有共同的 cluster name 的 节点。</li>
<li>节点（node) ：集群中的一个 Elasticearch 实例</li>
<li>分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。<strong>在集群环境下，一个索引的不同分片可以拆分到不同的节点中，解决数据量太大，单点存储量有限的问题。</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071006783.png"><img src="/../pic/202205071006783.png" alt="img"></a></p>
<blockquote>
<p>此处，我们把数据分成3片：shard0、shard1、shard2</p>
<p>主分片（Primary shard）：相对于副本分片的定义。</p>
<p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p>
</blockquote>
<p>数据备份可以保证高可用，但是每个分片备份一份在节点上，所需要的节点数量就会翻倍，成本太高。为了在高可用和成本间寻求平衡</p>
<ul>
<li>首先对数据分片，存储到不同节点</li>
<li>然后对每个分片进行备份，放到对方节点，<strong>完成互相备份</strong></li>
</ul>
<p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071006790.png"><img src="/../pic/202205071006790.png" alt="img"></a></p>
<p>现在，每个分片都有1个备份，存储在3个节点：</p>
<ul>
<li>node0：保存了分片0和1</li>
<li>node1：保存了分片0和2</li>
<li>node2：保存了分片1和2</li>
</ul>
<h2 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h2><h3 id="搭建Elasticsearch"><a href="#搭建Elasticsearch" class="headerlink" title="搭建Elasticsearch"></a>搭建Elasticsearch</h3><p>我们会在单机上利用 Docker 容器运行多个 Elasticsearch 实例来模拟集群。</p>
<p>可以直接使用 docker-compose 来完成，这要求你的Linux虚拟机至少有<strong>4G</strong>以上的内存空间。</p>
<p>docker-compose.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9201</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.12.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9202</span><span class="string">:9200</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>修改 Linux 系统权限，修改 <code>/etc/sysctl.conf</code> 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>添加下面的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure>

<p>让配置生效：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<p>通过docker-compose启动集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="集群状态监控"><a href="#集群状态监控" class="headerlink" title="集群状态监控"></a>集群状态监控</h3><p>kibana 可以监控 Elasticsearch 集群，但是更推荐使用 <a target="_blank" rel="noopener" href="https://github.com/lmenezes/cerebro">cerebro</a></p>
<p>下载解压打开 &#x2F;bin&#x2F;cerebro.bat</p>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:9000/">http://localhost:9000</a> 即可进入管理界面</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071018030.png"><img src="/../pic/202205071018030.png" alt="img"></a></p>
<p>输入任意节点的地址和端口，点击 connect</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071018761.png"><img src="/../pic/202205071018761.png" alt="img"></a></p>
<p>绿色的线条代表集群处于绿色（健康状态）</p>
<h3 id="创建索引库-1"><a href="#创建索引库-1" class="headerlink" title="创建索引库"></a>创建索引库</h3><p>我们还可以通过 cerebro 创建索引库，当然你需要使用 kibana 也可以。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071020771.png"><img src="/../pic/202205071020771.png" alt="img"></a></p>
<p>填写索引库信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071023380.png"><img src="/../pic/202205071023380.png" alt="img"></a></p>
<p>回到首页，即可查看索引库分片效果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071024397.png"><img src="/../pic/202205071024397.png" alt="img"></a></p>
<h2 id="集群职责划分"><a href="#集群职责划分" class="headerlink" title="集群职责划分"></a>集群职责划分</h2><p>Elasticsearch 中集群节点有不同的职责划分</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071029258.png"><img src="/../pic/202205071029258.png" alt="img"></a></p>
<p>（上图中的ingest节点用的比较少，所以不做介绍）</p>
<p><strong>默认情况下，集群中的任何一个节点都同时兼职上述四种角色。</strong></p>
<p>真实的集群一定要将集群职责分离</p>
<ul>
<li>master 节点：对 CPU 要求高，但是内存要求低</li>
<li>data 节点：对 CPU 和内存要求都高</li>
<li>coordinating 节点：对网络带宽、CPU 要求高</li>
</ul>
<p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071029263.png"><img src="/../pic/202205071029263.png" alt="img"></a></p>
<h2 id="集群脑裂问题"><a href="#集群脑裂问题" class="headerlink" title="集群脑裂问题"></a>集群脑裂问题</h2><p>脑裂是因为集群中的节点失联导致的。</p>
<p>例如一个集群中，主节点 node1 与其它节点失联。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071029267.png"><img src="/../pic/202205071029267.png" alt="img"></a></p>
<p>此时，node2 和 node3 认为 node1 宕机，就会重新选主。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071344676.png"><img src="/../pic/202205071344676.png" alt="img"></a></p>
<p>当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。</p>
<p>当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071344829.png"><img src="/../pic/202205071344829.png" alt="img"></a></p>
<p>解决脑裂的方案是，要求选票超过 <strong>(eligible节点数量+1)&#x2F;2</strong> 才能当选为 master，因此 eligible 节点数量最好是奇数。对应配置项是<code>discovery.zen.minimum_master_nodes</code>，在版本 7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题。</p>
<p>例如：3个节点形成的集群，选票必须超过 (3+1)&#x2F;2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为 master。node1 只有自己 1 票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p>
<h2 id="集群分布式存储"><a href="#集群分布式存储" class="headerlink" title="集群分布式存储"></a>集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？</p>
<p>Elasticsearch 会通过 hash 算法来计算文档应该存储到哪个分片</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071412275.png"><img src="/../pic/202205071412275.png" alt="img"></a></p>
<ul>
<li>_routing 默认是文档的 id</li>
<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li>
</ul>
<p>新增文档的流程如下图，</p>
<ol>
<li>新增一个 id&#x3D;1 的文档</li>
<li>对 id 做 hash 运算，假如得到的是 2，则应该存储到 shard-2</li>
<li>shard-2 的主分片在 node3 节点，将数据路由到 node3，node3 保存文档</li>
<li>同步给 shard-2 的副本分片2(R-2)，在 node2 节点</li>
<li>返回结果给 coordinating-node 节点(node1)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071412283.png"><img src="/../pic/202205071412283.png" alt="img"></a></p>
<h2 id="集群分布式查询"><a href="#集群分布式查询" class="headerlink" title="集群分布式查询"></a>集群分布式查询</h2><p>Elasticsearch 查询分成两个阶段</p>
<ul>
<li>scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片。</li>
<li>gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071422105.png"><img src="/../pic/202205071422105.png" alt="img"></a></p>
<h2 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h2><p>集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p>
<p>例如一个集群结构如图，三个都是健康的。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071516134.png"><img src="/../pic/202205071516134.png" alt="img"></a></p>
<p>现在，node1 是主节点，其它两个节点是从节点。突然，node1 发生了故障</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071516139.png"><img src="/../pic/202205071516139.png" alt="img"></a></p>
<p>宕机后的第一件事，需要重新选主，例如选中了 node2</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071516685.png"><img src="/../pic/202205071516685.png" alt="img"></a></p>
<p>node2 成为主节点后，会检测集群监控状态，将 node1 上的数据迁移到 node2、node3，确保数据依旧正常访问。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071516805.png"><img src="/../pic/202205071516805.png" alt="img"></a></p>
<p>如果重新启动node1节点，会恢复为原来的状态</p>
<p><img src="/../pic/image-20220929112419370.png" alt="image-20220929112419370"></p>
<h1 id="JMeter压力测试"><a href="#JMeter压力测试" class="headerlink" title="JMeter压力测试"></a>JMeter压力测试</h1><h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><p>JMeter 依赖于JDK，所以必须确保当前计算机上已经安装了 JDK，并且配置了环境变量。</p>
<p>Apache Jmeter官网下载，地址：<a target="_blank" rel="noopener" href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081544073.png"><img src="/../pic/202205081544073.png" alt="img"></a></p>
<p>解压缩即可使用，目录结构如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081545678.png"><img src="/../pic/202205081545678.png" alt="img"></a></p>
<p>其中的 bin 目录就是执行的脚本，其中包含启动脚本</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081545976.png"><img src="/../pic/202205081545976.png" alt="img"></a></p>
<p>双击即可运行，但是有两点注意</p>
<ul>
<li>启动时速度比较慢，要耐心等待。</li>
<li>启动后终端（黑窗口）不能关闭，否则 JMeter 也跟着关闭。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081545691.png"><img src="/../pic/202205081545691.png" alt="img"></a></p>
<h2 id="修改中文"><a href="#修改中文" class="headerlink" title="修改中文"></a>修改中文</h2><p>默认 JMeter 的语言是英文，需要设置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081547848.png"><img src="/../pic/202205081547848.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081547110.png"><img src="/../pic/202205081547110.png" alt="img"></a></p>
<p>上面的配置只能保证本次运行是中文，如果要永久中文，需要修改 JMeter 的配置文件。</p>
<p>打开 JMeter 文件夹，在 bin 目录中找到 <strong>jmeter.properties</strong>，添加下面配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">language</span>=<span class="string">zh_CN</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081546219.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081546219.png" alt="img"></a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在测试计划上点鼠标右键，选择「添加 &gt; 线程（用户） &gt; 线程组」</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081548692.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081548692.png" alt="img"></a></p>
<p>在新增的线程组中，填写线程信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081549330.png"><img src="/../pic/202205081549330.png" alt="img"></a></p>
<p>在线程组这里点鼠标右键，添加 http 请求</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081551101.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081551101.png" alt="img"></a></p>
<p>编写取样器内容</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081551053.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081551053.png" alt="img"></a></p>
<p>添加监听报告</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081551627.png"><img src="/../pic/202205081551627.png" alt="img"></a></p>
<p>汇总报告结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081548975.png"><img src="/../pic/202205081548975.png" alt="img"></a></p>
<p>添加监听结果树</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231440680.png"><img src="/../pic/202205231440680.png" alt="img"></a></p>
<p>察看结果树</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081548982.png"><img src="/../pic/202205081548982.png" alt="img"></a></p>
<h1 id="Sentine流量组件"><a href="#Sentine流量组件" class="headerlink" title="Sentine流量组件"></a>Sentine流量组件</h1><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><blockquote>
<p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p>
</blockquote>
<p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071911137.png"><img src="/../pic/202205071911137.png" alt="img"></a></p>
<p>如图，如果服务提供者I 发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I 的业务似乎不受影响。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071911461.png"><img src="/../pic/202205071911461.png" alt="img"></a></p>
<p>但是，依赖服务I 的业务请求被阻塞，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071911464.png"><img src="/../pic/202205071911464.png" alt="img"></a></p>
<p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，<strong>从而导致所有其它服务都不可用</strong>。</p>
<p>综上，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，这就是雪崩问题。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071911480.png"><img src="/../pic/202205071911480.png" alt="img"></a></p>
<p>解决雪崩问题的常见方式有四种</p>
<ol>
<li>超时处理</li>
<li>线程隔离</li>
<li>降级熔断</li>
<li>限流</li>
</ol>
<blockquote>
<p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p>
<p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p>
</blockquote>
<p>1.超时处理：设定超时时间，<strong>请求超过一定时间没有响应就返回错误信息，不会无休止等待。</strong></p>
<p>可能只会缓解雪崩问题，不能彻底解决雪崩问题，如果发请求的速度特别快的话就还会发生雪崩</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071936072.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205071936072.png" alt="img"></a></p>
<p>2.线程隔离</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071953573.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205071953573.png" alt="img"></a></p>
<p>是一种舱壁模式，如上图，船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。于此类似，我们可以<strong>限定每个业务能使用的线程数</strong>，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071935351.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205071935351.png" alt="img"></a></p>
<p>3.降级熔断</p>
<p>是一种断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p>
<p>断路器会统计访问某个服务的请求数量，异常比例。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071956512.png"><img src="/../pic/202205071956512.png" alt="img"></a></p>
<p>当发现访问服务 D 的<strong>请求异常比例</strong>过高时，认为服务 D 有导致雪崩的风险，会拦截访问服务 D 的一切请求，形成熔断。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071956665.png"><img src="/../pic/202205071956665.png" alt="img"></a></p>
<p>4.限流</p>
<p><strong>流量控制</strong>：限制业务访问的 QPS，避免服务因流量的突增而故障。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205071935370.png"><img src="/../pic/202205071935370.png" alt="img"></a></p>
<p>在 SpringCloud 当中支持多种服务保护技术</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li>
</ul>
<p>早期比较流行的是 Hystrix 框架，但<strong>目前国内实用最广泛的还是阿里巴巴的 Sentinel 框架</strong>，这里我们做下对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>Sentinel</strong></th>
<th align="left"><strong>Hystrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离策略</td>
<td align="left">信号量隔离</td>
<td align="left">线程池隔离&#x2F;信号量隔离</td>
</tr>
<tr>
<td align="left">熔断降级策略</td>
<td align="left">基于慢调用比例或异常比例</td>
<td align="left">基于失败比率</td>
</tr>
<tr>
<td align="left">实时指标实现</td>
<td align="left">滑动窗口</td>
<td align="left">滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td align="left">规则配置</td>
<td align="left">支持多种数据源</td>
<td align="left">支持多种数据源</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">多个扩展点</td>
<td align="left">插件的形式</td>
</tr>
<tr>
<td align="left">基于注解的支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">限流</td>
<td align="left">基于 QPS，支持基于调用关系的限流</td>
<td align="left">有限的支持</td>
</tr>
<tr>
<td align="left">流量整形</td>
<td align="left">支持慢启动、匀速排队模式</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">系统自适应保护</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">控制台</td>
<td align="left">开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td align="left">不完善</td>
</tr>
<tr>
<td align="left">常见框架的适配</td>
<td align="left">Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td align="left">Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
<h2 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p>
<p>Sentinel 具有以下特征</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h2 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h2><p>下载后 jar 包后，运行代码：<code>java -jar sentinel-dashboard-1.8.1.jar</code></p>
<p>如果要修改 Sentinel 的默认端口、账户、密码，可以通过下列配置：</p>
<table>
<thead>
<tr>
<th align="left"><strong>配置项</strong></th>
<th align="left"><strong>默认值</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">server.port</td>
<td align="left">8080</td>
<td align="left">服务端口</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.username</td>
<td align="left">sentinel</td>
<td align="left">默认用户名</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.password</td>
<td align="left">sentinel</td>
<td align="left">默认密码</td>
</tr>
</tbody></table>
<p>例如，修改端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8080 -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure>

<p>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 页面，就可以看到 Sentinel 的控制台了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205072010468.png"><img src="/../pic/202205072010468.png" alt="img"></a></p>
<p>账号和密码默认都是：sentinel</p>
<p>此时空白一片，还需要我们来整合进 SpringCloud</p>
<p>准备好我们的项目，在资料中，结构如下：</p>
<blockquote>
<p>这里老师讲的疏忽了，没有走 gateway 网关，但不影响。</p>
<p>提供的资料中的 gateway 网关带了权限配置导致这里我们访问不了网关（之前上课留下的），需要删除掉其中的 AuthorizeFilter.jar</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205072033318.png"><img src="/../pic/202205072033318.png" alt="img"></a></p>
<p>我们<strong>在 order-service 中整合 Sentinel</strong>，并连接 Sentinel 的控制台，步骤如下</p>
<p>1）引入 Sentinel 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）配置控制台</p>
<p>修改 application.yml 文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure>

<p>3）访问 order-service 的任意端点</p>
<p>打开浏览器，访问 <a target="_blank" rel="noopener" href="http://localhost:10010/order/101%EF%BC%8C%E5%A4%9A%E8%AE%BF%E9%97%AE%E5%87%A0%E6%AC%A1%EF%BC%8C%E5%A4%9A%E7%82%B9%E5%87%A0%E6%AC%A1%E5%88%B7%E6%96%B0%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91">http://localhost:10010/order/101，多访问几次，多点几次刷新，这样才能触发</a> Sentinel 的监控。</p>
<p>然后再访问 Sentinel 的控制台，查看效果。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081430741.png"><img src="/../pic/202205081430741.png" alt="img"></a></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>雪崩问题虽有四种方案，但是<strong>限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。</strong>《预判风险所在是防范风险的前提》，我们先学习流量控制。</p>
<h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>当请求进入微服务时，首先会访问 DispatcherServlet，然后进入 Controller、Service、Mapper，这样的一个调用链就叫做 <strong>簇点链路</strong>。</p>
<p><strong>簇点链路中被监控的每一个接口就是一个资源</strong>。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint，也就是 Controller 中的方法），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源。</p>
<p>例如，我们刚才访问的 order-service 中的 OrderController 中的端点：&#x2F;order&#x2F;{orderId}</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081445779.png"><img src="/../pic/202205081445779.png" alt="img"></a></p>
<p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p>
<ul>
<li>流控：流量控制</li>
<li>降级：降级熔断</li>
<li>热点：热点参数限流，是限流的一种</li>
<li>授权：请求的权限控制</li>
</ul>
<p>点击资源 &#x2F;order&#x2F;{orderId} 后面的流控按钮，就可以弹出表单。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081509045.png"><img src="/../pic/202205081509045.png" alt="img"></a></p>
<p>表单中可以填写限流规则，如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081509055.png"><img src="/../pic/202205081509055.png" alt="img"></a></p>
<p>其含义是限制 &#x2F;order&#x2F;{orderId} 这个资源的单机 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p>
<blockquote>
<p>需求：给 &#x2F;order&#x2F;{orderId} 这个资源设置流控规则，QPS 不能超过 5，然后测试。</p>
</blockquote>
<p>1）首先在 sentinel 控制台添加限流规则</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081513259.png"><img src="/../pic/202205081513259.png" alt="img"></a></p>
<p>2）利用 jmeter 测试，下面有讲到 JMeter 基础使用。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081514678.png"><img src="/../pic/202205081514678.png" alt="img"></a></p>
<p>20 个用户，2 秒内运行完，这样的话 QPS 就是 10，超过了我们在 sentinel 设置的 5</p>
<p>右键运行：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081512845.png"><img src="/../pic/202205081512845.png" alt="img"></a></p>
<blockquote>
<p>注意，不要点击菜单中的执行按钮来运行。</p>
</blockquote>
<p>结果：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081512850.png"><img src="/../pic/202205081512850.png" alt="img"></a></p>
<p>可以看到，成功的请求每次只有 5 个。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081525292.png"><img src="/../pic/202205081525292.png" alt="img"></a></p>
<h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong></p>
<h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul>
<li>直接：统计<strong>当前资源的请求</strong>，触发阈值时对当前资源直接限流，也是默认的模式<ul>
<li>直接对当前资源限流</li>
</ul>
</li>
<li>关联：统计<strong>与当前资源相关的另一个资源</strong>，触发阈值时，对当前资源限流<ul>
<li>相当于高优先级资源触发阈值，对低优先级资源限流。</li>
</ul>
</li>
<li>链路：统计<strong>从指定链路</strong>访问到<strong>本资源</strong>的请求，触发阈值时，对指定链路限流<ul>
<li>是针对请求来源的限流</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081553073.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081553073.png" alt="img"></a></p>
<p>上面我们测试的就是直接模式，默认就是直接模式。</p>
<h4 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h4><p>统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p>
<p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当<strong>修改订单</strong>业务触发阈值时，需要对<strong>查询订单</strong>业务限流。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081602290.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205081602290.png" alt="img"></a></p>
<p>例如：配置规则，<strong>当 &#x2F;write 资源访问量触发阈值时，就会对 &#x2F;read 资源限流，避免影响 &#x2F;write 资源。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081602252.png"><img src="/../pic/202205081602252.png" alt="img"></a></p>
<p>我们去程序中模拟：</p>
<ul>
<li>在 OrderController 新建两个端点：&#x2F;order&#x2F;query 和 &#x2F;order&#x2F;update，无需实现业务</li>
<li>配置流控规则，当 &#x2F;order&#x2F; update 资源被访问的 QPS 超过 5 时，对 &#x2F;order&#x2F;query 请求限流</li>
</ul>
<p>1）定义 &#x2F;order&#x2F;query 端点，模拟订单查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）定义 &#x2F;order&#x2F;update 端点，模拟订单更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;更新订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，查看 Sentinel 控制台的簇点链路。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081618267.png"><img src="/../pic/202205081618267.png" alt="img"></a></p>
<p>3）配置流控规则</p>
<p>想要对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询 &#x2F;order&#x2F;query 限流</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081619163.png"><img src="/../pic/202205081619163.png" alt="img"></a></p>
<p>在表单中填写流控规则</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081602274.png"><img src="/../pic/202205081602274.png" alt="img"></a></p>
<p>4）在 JMeter 测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081619453.png"><img src="/../pic/202205081619453.png" alt="img"></a></p>
<p>可以看到 1000 个用户，100 秒，因此 QPS 为10，超过了我们设定的阈值：5</p>
<p>查看 http 请求</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081602280.png"><img src="/../pic/202205081602280.png" alt="img"></a></p>
<p>请求的目标是 &#x2F;order&#x2F;update，但限流的目标是 &#x2F;order&#x2F;query，这就是关联模式；我们在浏览器访问 &#x2F;order&#x2F;query，可以发现确实被限流了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081620364.png"><img src="/../pic/202205081620364.png" alt="img"></a></p>
<h4 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h4><p>只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p>
<p>例如有两条请求链路</p>
<ul>
<li>&#x2F;test1 –&gt; &#x2F;common</li>
<li>&#x2F;test2 –&gt; &#x2F;common</li>
</ul>
<p>如果只希望统计从 &#x2F;test2 进入到 &#x2F;common 的请求，则可以这样配置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081632892.png"><img src="/../pic/202205081632892.png" alt="img"></a></p>
<p><strong>实战案例</strong></p>
<p>有查询订单和创建订单业务，两者都需要查询商品。</p>
<p>针对从<strong>查询订单</strong>进入到<strong>查询商品</strong>的请求统计，并设置限流。</p>
<ol>
<li>在 OrderService 中添加一个 queryGoods 方法，不用实现业务</li>
<li>在 OrderController 中，改造 &#x2F;order&#x2F;query 端点，调用 OrderService 中的 queryGoods 方法</li>
<li>在 OrderController 中添加一个 &#x2F;order&#x2F;save 端点，调用 OrderService 的 queryGoods 方法</li>
<li>给 queryGoods 设置限流规则，从 &#x2F;order&#x2F;query 进入 queryGoods 的方法限制 QPS 必须小于 2</li>
</ol>
<p>1）添加查询商品方法</p>
<p>在order-service服务中，给 OrderService 类添加一个 queryGoods 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）查询订单时，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 &#x2F;order&#x2F;query 端点的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>3）新增订单，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 &#x2F;order&#x2F;save 端点，模拟新增订单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.out.println(<span class="string">&quot;新增订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;新增订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）给查询商品添加资源标记</p>
<p>默认情况下，OrderService 中的方法是不被 Sentinel 监控的，需要我们自己通过注解来标记要监控的方法。</p>
<p>给 OrderService 的 queryGoods 方法添加 <code>@SentinelResource</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链路模式中，是对不同来源的两个链路做监控。但是 Sentinel 默认会给进入 SpringMVC 的所有请求设置同一个 root 资源，会导致链路模式失效(这个会设置所有的controller为同一个链路)。我们需要关闭这种对 SpringMVC 的资源聚合，修改 order-service 服务的 application.yml 文件</p>
<p>大概就是这种关系</p>
<img src="../pic/image-20220929154834788.png" alt="image-20220929154834788" style="zoom: 50%;" />

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure>

<p>重启服务，访问 &#x2F;order&#x2F;query 和 &#x2F;order&#x2F;save，可以查看到 Sentinel 的簇点链路规则中，出现了新的资源</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081633195.png"><img src="/../pic/202205081633195.png" alt="img"></a></p>
<p>5）添加流控规则</p>
<p>点击 goods 资源后面的流控按钮，在弹出的表单中填写下面信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081633212.png"><img src="/../pic/202205081633212.png" alt="img"></a></p>
<p>只统计从 &#x2F;order&#x2F;query 进入 &#x2F;goods 的资源，QPS 阈值为 2，超出则被限流。</p>
<p>6）Jmeter测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081633203.png"><img src="/../pic/202205081633203.png" alt="img"></a></p>
<p>可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2</p>
<p>一个 http 请求是访问 &#x2F;order&#x2F;save</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081858739.png"><img src="/../pic/202205081858739.png" alt="img"></a></p>
<p>运行的结果是 &#x2F;order&#x2F;save 完全不受影响。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081858880.png"><img src="/../pic/202205081858880.png" alt="img"></a></p>
<p>访问 &#x2F;order&#x2F;query</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081633221.png"><img src="/../pic/202205081633221.png" alt="img"></a></p>
<p>运行结果是 &#x2F;order&#x2F;query，每次只有2个通过。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081633245.png"><img src="/../pic/202205081633245.png" alt="img"></a></p>
<h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p>细心的小伙伴会发现在流控的高级选项中，还有一个流控效果选项，前面我们的测试都是基本快速失败的。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907653.png"><img src="/../pic/202205081907653.png" alt="img"></a></p>
<p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种</p>
<ul>
<li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常，是默认的处理方式。</li>
<li>Warm Up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</li>
<li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</li>
</ul>
<h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>阈值一般是一个微服务能承担的最大 QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将 QPS 跑到最大值，可能导致服务瞬间宕机。</p>
<p>（冷启动相当于一个人将要做剧烈运动前，先热身一下，再慢慢的剧烈起来）</p>
<p>Warm Up 也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值<strong>初始</strong>值是 <code>maxThreshold / coldFactor</code>，持续指定时长后，逐渐提高到 maxThreshold 值。而 coldFactor 的默认值是 3.</p>
<p>例如，我设置 QPS 的 maxThreshold 为 10，预热时间为 5 秒，那么初始阈值就是 10 &#x2F; 3 &#x3D; 3，然后在 5 秒后逐渐增长到 10</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907114.png"><img src="/../pic/202205081907114.png" alt="img"></a></p>
<p><strong>案例</strong>：给 &#x2F;order&#x2F;{orderId} 这个资源设置限流，最大 QPS 为 10，利用 Warm Up 效果，预热时长为 5 秒。</p>
<p>1）配置流控规则</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090008173.png"><img src="/../pic/202205090008173.png" alt="img"></a></p>
<p>2）JMeter 测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090008283.png"><img src="/../pic/202205090008283.png" alt="img"></a></p>
<p>刚刚启动时，大部分请求失败，成功的只有 3 个，说明 QPS 被限定在 3</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090009927.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205090009927.png" alt="img"></a></p>
<p>随着时间推移，成功比例越来越高</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090009448.png"><img src="/../pic/202205090009448.png" alt="img"></a></p>
<p>到 Sentinel 控制台查看实时监控</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907395.png"><img src="/../pic/202205081907395.png" alt="img"></a></p>
<p>一段时间后</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907398.png"><img src="/../pic/202205081907398.png" alt="img"></a></p>
<p>用官方的话讲，该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>
<h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>当请求超过 QPS 阈值时，「快速失败」和 「Warm Up」会拒绝新的请求并抛出异常。</p>
<p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>
<p>&#x3D;&#x3D;这种方式适用于波动式的网络请求。&#x3D;&#x3D;</p>
<p>例如：</p>
<blockquote>
<p>QPS &#x3D; 5，意味着每 200ms 处理一个队列中的请求；</p>
<p>timeout &#x3D; 2000，意味着<strong>预期等待时长</strong>超过 2000ms 的请求会被拒绝并抛出异常。</p>
</blockquote>
<p>比如现在一下子来了 12 个请求，因为每 200ms 执行一个请求，那么预期等待时长就是：</p>
<ul>
<li>第6个请求的<strong>预期等待时长</strong> &#x3D; 200 * (6 - 1) &#x3D; 1000ms</li>
<li>第12个请求的预期等待时长 &#x3D; 200 * (12-1) &#x3D; 2200ms</li>
</ul>
<p>又比如下图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090037622.png"><img src="/../pic/202205090037622.png" alt="img"></a></p>
<p>现在，第 1 秒同时接收到 10 个请求，但第 2 秒只有 1 个请求，此时 QPS 的曲线这样的</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907396.png"><img src="/../pic/202205081907396.png" alt="img"></a></p>
<p>如果使用排队等待的流控效果，所有进入的请求都要排队，以固定的 200ms 的间隔执行，QPS 会变的很平滑</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090016702.png"><img src="/../pic/202205090016702.png" alt="img"></a></p>
<p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p><strong>案例</strong>：给 &#x2F;order&#x2F;{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队等待的流控效果，超时时长设置为 5s</p>
<p>1）添加流控规则</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090011577.png"><img src="/../pic/202205090011577.png" alt="img"></a></p>
<p>2）JMeter 测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907171.png"><img src="/../pic/202205081907171.png" alt="img"></a></p>
<p>QPS 为 15，已经超过了我们设定的 10，如果是之前的「快速失败」 、「Warm Up」模式，超出的请求应该会直接报错。</p>
<p>但是我们看看「排队等待」的运行结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907254.png"><img src="/../pic/202205081907254.png" alt="img"></a></p>
<p>再去 Sentinel 查看实时监控的 QPS 曲线</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907426.png"><img src="/../pic/202205081907426.png" alt="img"></a></p>
<p>QPS 非常平滑，一致保持在 10，但是超出的请求没有被拒绝，而是放入队列。因此<strong>响应时间</strong>（等待时间）会越来越长。</p>
<p>当队列满了以后，才会有部分请求失败</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205081907443.png"><img src="/../pic/202205081907443.png" alt="img"></a></p>
<h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而「热点参数限流」是<strong>分别统计参数值相同的请求</strong>，判断是否超过 QPS 阈值。</p>
<h3 id="全局参数限流"><a href="#全局参数限流" class="headerlink" title="全局参数限流"></a>全局参数限流</h3><p>例如，一个根据 id 查询商品的接口</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090045292.png"><img src="/../pic/202205090045292.png" alt="img"></a></p>
<p>访问 &#x2F;goods&#x2F;{id} 的请求中，id 参数值会有变化，「热点参数限流」会根据参数值分别统计 QPS，统计结果：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090046762.png"><img src="/../pic/202205090046762.png" alt="img"></a></p>
<p>当 id&#x3D;1 的请求触发阈值被限流时，id值不为1的请求则不受影响。</p>
<p>配置示例：对 hot 这个资源的 0 号参数（也就是第一个参数）做统计，每 1s <strong>相同参数值</strong>的请求数不能超过 5</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042929.png"><img src="/../pic/202205090042929.png" alt="img"></a></p>
<h3 id="热点参数限流-1"><a href="#热点参数限流-1" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>假设上面的例子是一个商品查询接口，那么刚才的配置中，对这个接口的所有商品一视同仁，QPS 都限定为 5</p>
<p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的 QPS 限制与其它商品不一样，高一些。那就需要配置「热点参数限流」的高级选项了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090050071.png"><img src="/../pic/202205090050071.png" alt="img"></a></p>
<p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 个相同参数的 QPS 不能超过 5，有如下两个例外</p>
<ul>
<li>如果参数值是 100，则每 1s 允许的 QPS 为 10</li>
<li>如果参数值是 101，则每 1s 允许的 QPS 为 15</li>
</ul>
<p><strong>案例需求</strong>：给 &#x2F;order&#x2F;{orderId} 这个资源添加「热点参数限流」，规则如下</p>
<ul>
<li>默认的热点参数规则是每 1s 请求量不超过 2</li>
<li>给 102 这个参数设置例外：每 1s 请求量不超过 4</li>
<li>给 103 这个参数设置例外：每 1s 请求量不超过 10</li>
</ul>
<p><strong>注意事项</strong>：热点参数限流对默认的 SpringMVC 资源无效，需要利用 <code>@SentinelResource</code> 注解标记资源。</p>
<p>1）标记资源</p>
<p>给 order-service 中的 OrderController 中的 &#x2F;order&#x2F;{orderId} 资源添加注解</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042942.png"><img src="/../pic/202205090042942.png" alt="img"></a></p>
<p>2）热点参数限流规则</p>
<p>访问该接口，可以看到我们标记的 hot 资源出现了</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090136368.png"><img src="/../pic/202205090136368.png" alt="img"></a></p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090137049.png"><img src="/../pic/202205090137049.png" alt="img"></a></p>
<p>点击新增，填写表单</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090137574.png"><img src="/../pic/202205090137574.png" alt="img"></a></p>
<p>3）JMeter 测试</p>
<p>这里发起请求的 QPS 为 5，包含 3 个 http 请求</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090138955.png"><img src="/../pic/202205090138955.png" alt="img"></a></p>
<p>普通参数，QPS 阈值为 2</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042964.png"><img src="/../pic/202205090042964.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042203.png"><img src="/../pic/202205090042203.png" alt="img"></a></p>
<p>例外项，QPS 阈值为 4</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090140941.png"><img src="/../pic/202205090140941.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042238.png"><img src="/../pic/202205090042238.png" alt="img"></a></p>
<p><strong>例外项，QPS 阈值为 10</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090042244.png"><img src="/../pic/202205090042244.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205090140933.png"><img src="/../pic/202205090140933.png" alt="img"></a></p>
<h2 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h2><p>限流只是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p>
<p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p>
<p><strong>线程隔离</strong>：调用者在调用服务提供者时，给<strong>每个调用的请求分配独立线程池</strong>，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091001949.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205091001949.png" alt="img"></a></p>
<p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对<strong>服务提供者</strong>的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091203825.png"><img src="/../pic/202205091203825.png" alt="img"></a></p>
<p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong>发起远程调用时做线程隔离、或者服务熔断。</p>
<p>而我们的微服务远程调用都是基于 Feign 来完成的，因此我们需要将 Feign 与 Sentinel 整合，在 Feign 里面实现线程隔离和服务熔断。</p>
<h3 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h3><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合 Feign 和 Sentinel</p>
<p>修改配置，开启 Sentinel 功能，修改 OrderService 的 application.yml 文件，开启 Feign 的 Sentinel 功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure>

<p>服务降级：访问失败后，服务</p>
<p><strong>编写失败降级逻辑代码</strong>，业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p>
<p>给 FeignClient 编写失败后的降级逻辑</p>
<p>①方式一：FallbackClass，但无法对远程调用的异常做处理。</p>
<p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p>
<p>这里我们演示方式二的失败降级处理。</p>
<p><strong>步骤一</strong>：在 feing-api 项目中定义类，实现 FallbackFactory</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091209104.png"><img src="/../pic/202205091209104.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserclientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;UserClient&gt; &#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> Userclient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">//创建UserClient接口实现类，实现其中的方法，编写失败降级的处理逻辑</span></span><br><span class="line">        <span class="comment">//这里面编写的是匿名内部类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Userclient</span>() &#123;</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">findById</span> <span class="params">( Long id)</span> &#123;</span><br><span class="line">                <span class="comment">//记录异常信息</span></span><br><span class="line">                log.error(<span class="string">&quot;查询用户失败&quot;</span>，throwable);<span class="comment">//根据业务需求返回默认的数据，这里是空用户</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤二</strong>：在 feing-api 项目中的 DefaultFeignConfiguration 类中将 UserClientFallbackFactory 注册为一个Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserClientFallbackFactory <span class="title function_">userClientFallbackFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三</strong>：在 feing-api 项目中的 UserClient 接口中使用 UserClientFallbackFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220930173945717.png" alt="image-20220930173945717"></p>
<p>重启后，访问一次订单查询业务，然后查看 Sentinel 控制台，可以看到新的簇点链路</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091210616.png"><img src="/../pic/202205091210616.png" alt="img"></a></p>
<h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>线程隔离（舱壁模式）有两种方式实现</p>
<ul>
<li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果。</li>
<li>信号量隔离（Sentinel默认采用）：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</li>
</ul>
<p>两者的优缺点</p>
<ul>
<li>线程池隔离：基于线程池模式，有额外开销，但隔离控制更强</li>
<li>信号量隔离：基于计数器模式，简单，开销小</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091501180.png"><img src="/../pic/202205091501180.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091502961.png"><img src="/../pic/202205091502961.png" alt="img"></a></p>
<p><strong>Sentinel 使用的是信号量隔离</strong>，而 Hystrix 则两种线程隔离都可以，18 年Hystrix已经停止更新。</p>
<p>如何使用呢，在添加限流规则时，可以选择两种阈值类型</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091500754.png"><img src="/../pic/202205091500754.png" alt="img"></a></p>
<ul>
<li>QPS：就是每秒的请求数，之前已经演示过。</li>
<li>线程数：是该资源能使用的 Tomcat 线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</li>
</ul>
<p><strong>案例需求</strong>：给 order-service 服务中的 UserClient 的查询用户接口设置流控规则，线程数不能超过 2，然后利用 JMeter 测试。</p>
<p>1）配置隔离规则，选择 feign 接口后面的流控按钮</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091507487.png"><img src="/../pic/202205091507487.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091508076.png"><img src="/../pic/202205091508076.png" alt="img"></a></p>
<p>2）JMeter 测试</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091500777.png"><img src="/../pic/202205091500777.png" alt="img"></a></p>
<p>一次发生 10 个请求，有较大概率并发线程数超过 2，而超出的请求会走之前定义的失败降级逻辑。</p>
<p>查看运行结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091500739.png"><img src="/../pic/202205091500739.png" alt="img"></a></p>
<p>发现虽然结果都是通过了，<strong>不过部分请求得到的响应是「降级」返回的 null 信息。也就是我们写的降级方法</strong>。</p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>熔断降级是解决雪崩问题的重要手段。(主要思想就是计算比例！！！像保险丝，直接熔断，访问不了了就)其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p>
<p>断路器控制熔断和放行是通过状态机来完成的，如下图就是一个断路器的状态机制</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091510676.png"><img src="/../pic/202205091510676.png" alt="img"></a></p>
<p>状态机包括三个状态</p>
<ul>
<li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。会去判断是否达到熔断条件，这一步我们叫做「熔断策略」，达到该条件则切换到 open 状态，打开断路器。</li>
<li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open 状态 5 秒后会进入 half-open 状态。</li>
<li>half-open：半开状态，会一段时间放行一次请求，根据执行结果来判断接下来的操作。请求成功：则切换到 closed 状态；请求失败：则切换到 open 状态。</li>
</ul>
<p>断路器熔断策略有三种：慢调用、异常比例、异常数</p>
<h4 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a>慢调用</h4><p>业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p>
<p>例如下图，设置 RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5s，然后进入 half-open 状态，放行一次请求做测试。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520916.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205091520916.png" alt="img"></a></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms，统计时间为 1s ，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s；</p>
<p>1）设置慢调用</p>
<p>修改 user-service 中的 &#x2F;user&#x2F;{id} 这个接口的业务。通过休眠模拟一个延迟时间。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091538605.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205091538605.png" alt="img"></a></p>
<p>此时，orderId &#x3D; 101 的订单，关联的是 id 为 1 的用户，调用时长为 60ms</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520928.png"><img src="/../pic/202205091520928.png" alt="img"></a></p>
<p>orderId &#x3D; 102 的订单，关联的是 id 为 2 的用户，调用时长为非常短</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520932.png"><img src="/../pic/202205091520932.png" alt="img"></a></p>
<p>2）设置熔断规则</p>
<p>下面，给 feign 接口设置降级规则，超过 50ms 的请求都会被认为是慢请求。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091624147.png"><img src="/../pic/202205091624147.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091624535.png"><img src="/../pic/202205091624535.png" alt="img"></a></p>
<p>3）测试</p>
<p>在浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8088/order/101%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B05%E6%AC%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%EF%BC%8C%E8%A7%A6%E5%8F%91%E4%BA%86%E7%86%94%E6%96%AD%EF%BC%8C%E8%AF%B7%E6%B1%82%E6%97%B6%E9%95%BF%E7%BC%A9%E7%9F%AD%E8%87%B3">http://localhost:8088/order/101，快速刷新5次，可以发现，触发了熔断，请求时长缩短至</a> 5ms，快速失败了，并且走降级逻辑，返回的 null</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091624280.png"><img src="/../pic/202205091624280.png" alt="img"></a></p>
<p>此时在浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8088/order/102%EF%BC%8C%E4%B9%9F%E8%A2%AB%E7%86%94%E6%96%AD%E4%BA%86">http://localhost:8088/order/102，也被熔断了</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091625297.png"><img src="/../pic/202205091625297.png" alt="img"></a></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p>
<p>例如，异常比例设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.4，则触发熔断。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520106.png"><img src="/../pic/202205091520106.png" alt="img"></a></p>
<p>异常数设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 2 次，则触发熔断。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520416.png"><img src="/../pic/202205091520416.png" alt="img"></a></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，统计时间为 1s，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s</p>
<p>1）设置异常请求</p>
<p>首先，修改 user-service 中的 &#x2F;user&#x2F;{id} 这个接口的业务。手动抛出异常，以触发异常比例的熔断，也就是说，id 为 2时，就会触发异常。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520469.png"><img src="/../pic/202205091520469.png" alt="img"></a></p>
<p>2）设置熔断规则</p>
<p>在 5 次请求中，只要异常比例超过 0.4，也就是有 2 次以上的异常，就会触发熔断。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091818818.png"><img src="/../pic/202205091818818.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520694.png"><img src="/../pic/202205091520694.png" alt="img"></a></p>
<p>3）测试</p>
<p>在浏览器快速访问：<a target="_blank" rel="noopener" href="http://localhost:8088/order/102%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B0">http://localhost:8088/order/102，快速刷新</a> 5 次，触发熔断降级。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091821790.png"><img src="/../pic/202205091821790.png" alt="img"></a></p>
<p>此时，我们去访问本应该正常的 103，发现也被降级了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205091520623.png"><img src="/../pic/202205091520623.png" alt="img"></a></p>
<h2 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h2><p>授权规则可以对请求方来源做判断和控制。授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p>
<p>比如我们希望控制对资源 <code>test</code> 的访问设置白名单，只有来源为 <code>appA</code> 和 <code>appB</code> 的请求才可通过。</p>
<ul>
<li>白名单：来源（origin）在白名单内的调用者允许访问</li>
<li>黑名单：来源（origin）在黑名单内的调用者不允许访问</li>
</ul>
<p>点击左侧菜单的授权，可以看到授权规则</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100008770.png"><img src="/../pic/202205100008770.png" alt="img"></a></p>
<ul>
<li>资源名：就是受保护的资源，例如 &#x2F;order&#x2F;{orderId}</li>
<li>流控应用：是来源者的名单<ul>
<li>如果是勾选白名单，则名单中的来源被许可访问。</li>
<li>如果是勾选黑名单，则名单中的来源被禁止访问。</li>
</ul>
</li>
</ul>
<p>比如我们允许请求从 gateway 到 order-service，不允许浏览器访问 order-service，那么白名单中就要填写<strong>网关的来源名称（origin）</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100008679.png"><img src="/../pic/202205100008679.png" alt="img"></a></p>
<p>Sentinel 是通过 RequestOriginParser 这个接口的 parseOrigin() 方法来获取请求的来源的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是从 request 对象中，获取请求者的 origin 值并返回。默认情况下，Sentinel 不管请求者从哪里来，返回值永远是 default，也就是说一切请求的来源都被认为是一样的值 default</p>
<p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的 origin</strong></p>
<p>例如 order-service 服务中，我们定义一个 RequestOriginParser 的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(origin)) &#123;</span><br><span class="line">            origin = <span class="string">&quot;blank&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须让<strong>所有从 Gateway 路由到微服务的请求都带上 origin 头</strong>。这个需要利用之前学习的一个 GatewayFilter 来实现，使用 AddRequestHeaderGatewayFilter，修改 Gateway 服务中的 application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span> <span class="comment">#origin前面不能带空格</span></span><br></pre></td></tr></table></figure>

<p>这样，从 Gateway 路由的所有请求都会带上 origin 头，值为 gateway。而从其它地方到达微服务的请求一般没有这个头。</p>
<p>接下来，我们添加一个授权规则，放行 origin 值为 gateway 的请求。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100104446.png"><img src="/../pic/202205100104446.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100104442.png"><img src="/../pic/202205100104442.png" alt="img"></a></p>
<p>现在，我们直接跳过网关，访问 order-service 服务</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100104100.png"><img src="/../pic/202205100104100.png" alt="img"></a></p>
<p>通过网关访问</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100104271.png"><img src="/../pic/202205100104271.png" alt="img"></a></p>
<h2 id="自定义异常结果"><a href="#自定义异常结果" class="headerlink" title="自定义异常结果"></a>自定义异常结果</h2><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是 flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p>
<p>而如果要自定义异常时的返回结果，需要实现 BlockExceptionHandler 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有三个参数：</p>
<ul>
<li>HttpServletRequest request：request 对象</li>
<li>HttpServletResponse response：response 对象</li>
<li>BlockException e：被 Sentinel 拦截时抛出的异常</li>
</ul>
<p>这里的 BlockException 包含多个不同的子类</p>
<table>
<thead>
<tr>
<th align="left"><strong>异常</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">FlowException</td>
<td align="left">限流异常</td>
</tr>
<tr>
<td align="left">ParamFlowException</td>
<td align="left">热点参数限流的异常</td>
</tr>
<tr>
<td align="left">DegradeException</td>
<td align="left">降级异常</td>
</tr>
<tr>
<td align="left">AuthorityException</td>
<td align="left">授权规则异常</td>
</tr>
<tr>
<td align="left">SystemBlockException</td>
<td align="left">系统规则异常</td>
</tr>
</tbody></table>
<p>自定义异常处理，下面我们就在 order-service 定义一个自定义异常处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;未知异常&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">429</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">            status = <span class="number">401</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(status);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启测试，在不同场景下，会返回不同的异常消息。</p>
<p>限流：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100112438.png"><img src="/../pic/202205100112438.png" alt="img"></a></p>
<p>授权拦截时：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100122438.png"><img src="/../pic/202205100122438.png" alt="img"></a></p>
<h2 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h2><p>现在，Sentinel 的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。</p>
<p>规则是否能持久化，取决于规则管理模式，Sentinel 支持三种规则管理模式</p>
<ul>
<li>原始模式：Sentinel 的默认模式，将规则保存在内存，重启服务会丢失。</li>
<li>pull 模式</li>
<li>push 模式</li>
</ul>
<h3 id="pull模式"><a href="#pull模式" class="headerlink" title="pull模式"></a>pull模式</h3><p>pull 模式：控制台将配置的规则推送到 Sentinel 客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100126168.png"><img src="/../pic/202205100126168.png" alt="img"></a></p>
<p>这种模式的缺点是：时效性不强，因为是定时更新的</p>
<h3 id="push模式"><a href="#push模式" class="headerlink" title="push模式"></a>push模式</h3><p>（这个东西不是我们现在该看的）</p>
<p>push 模式：控制台将配置规则推送到远程配置中心，例如 Nacos，Sentinel 客户端监听 Nacos，获取配置变更的推送消息，完成本地配置更新。这种模式是比较好的一种。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205100128564.png"><img src="/../pic/202205100128564.png" alt="img"></a></p>
<p>我们简单了解一下这种方式，首先修改 OrderService，让其监听 Nacos 中的 Sentinel 规则配置。</p>
<p>在 order-service 中引入Sentinel 监听 Nacos 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置 Nacos 地址，在 order-service 中的 application.yml 文件配置 Nacos 地址及监听的配置信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">orderservice-flow-rules</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">SENTINEL_GROUP</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment"># 还可以是：degrade、authority、param-flow</span></span><br></pre></td></tr></table></figure>

<p>然后需要修改 sentinel-dashboard 源码，SentinelDashboard 默认不支持 Nacos 的持久化，需要修改源码。</p>
<blockquote>
<p>相当于开源开一半，主要给阿里云用户商业使用。</p>
<p>以下以供了解，未实测。</p>
</blockquote>
<p>解压 Sentinel 源码包</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101404663.png"><img src="/../pic/202205101404663.png" alt="img"></a></p>
<p>然后并用 IDEA 打开这个项目，结构如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101404666.png"><img src="/../pic/202205101404666.png" alt="img"></a></p>
<p>在 sentinel-dashboard 源码的pom文件中，nacos 的依赖默认的 scope 是 test，只能在测试时使用，这里要去除</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101405160.png"><img src="/../pic/202205101405160.png" alt="img"></a></p>
<p>将 sentinel-datasource-nacos 依赖的 scope 去掉，改成下面这样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 sentinel-dashboard 的 test 包下，已经编写了对 nacos 的支持，我们需要将其拷贝到 main 中。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101405035.png"><img src="/../pic/202205101405035.png" alt="img"></a></p>
<p>然后，还需要修改测试代码中的 NacosConfig 类</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101406914.png"><img src="/../pic/202205101406914.png" alt="img"></a></p>
<p>修改其中的 Nacos 地址，让其读取 application.properties 中的配置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101404688.png"><img src="/../pic/202205101404688.png" alt="img"></a></p>
<p>在 sentinel-dashboard 的 application.properties 中添加 Nacos 地址配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">nacos.addr</span>=<span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>

<p>另外，还需要修改 <code>com.alibaba.csp.sentinel.dashboard.controller.v2</code> 包下的 FlowControllerV2</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101404531.png"><img src="/../pic/202205101404531.png" alt="img"></a></p>
<p>让我们添加的 Nacos 数据源生效</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101407560.png"><img src="/../pic/202205101407560.png" alt="img"></a></p>
<p>接下来，还要修改前端页面，添加一个支持 nacos 的菜单。</p>
<p>修改 <code>src/main/webapp/resources/app/scripts/directives/sidebar/</code> 目录下的 sidebar.html 文件</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101404891.png"><img src="/../pic/202205101404891.png" alt="img"></a></p>
<p>将其中的这部分注释打开</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101408124.png"><img src="/../pic/202205101408124.png" alt="img"></a></p>
<p>修改其中的文本</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101408073.png"><img src="/../pic/202205101408073.png" alt="img"></a></p>
<p>运行 IDEA 中的 maven 插件，编译和打包修改好的 sentinel-dashboard</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205101408008.png"><img src="/../pic/202205101408008.png" alt="img"></a></p>
<p>启动方式跟官方一样</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure>

<p>如果要修改 Nacos 地址，可以添加参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar -Dnacos.addr=localhost:8848 sentinel-dashboard.jar</span><br></pre></td></tr></table></figure>

<h1 id="Seata分布式事务"><a href="#Seata分布式事务" class="headerlink" title="Seata分布式事务"></a>Seata分布式事务</h1><h2 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h2><p>在传统数据库事务中，必须要满足四个原则，我们把他称为 ACID</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231445816.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231445816.png" alt="img"></a></p>
<p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如</p>
<ul>
<li>跨数据源的分布式事务</li>
<li>跨服务的分布式事务</li>
<li>综合情况</li>
</ul>
<p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ol>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ol>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231447738.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231447738.png" alt="img"></a></p>
<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证 ACID 原则。</p>
<p>但是当我们把三件事情看做一个”业务”，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是<strong>分布式系统下的事务</strong>。此时 ACID 难以满足，这是分布式事务要解决的问题。</p>
<p>以下是一个项目演示，如下图有一个微服务项目</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231502038.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231502038.png" alt="img"></a></p>
<p>其中：seata-demo 是父工程，负责管理项目依赖</p>
<ul>
<li>account-service：账户服务，负责管理用户的资金账户。提供扣减余额的接口</li>
<li>storage-service：库存服务，负责管理商品库存。提供扣减库存的接口</li>
<li>order-service：订单服务，负责管理订单。创建订单时，需要调用 account-service 和 storage-service</li>
</ul>
<p>我们去创建订单，发送 POST 请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --location --request POST &#x27;http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=20&amp;money=200&#x27;</span><br></pre></td></tr></table></figure>

<p>测试发现，当库存不足时，此时账户余额已经扣减，并不会回滚，出现了分布式事务问题。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231505539.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231505539.png" alt="img"></a></p>
<h2 id="解决分布式事务"><a href="#解决分布式事务" class="headerlink" title="解决分布式事务"></a>解决分布式事务</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<blockquote>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance （分区容错性）</li>
</ul>
</blockquote>
<p>它们的第一个字母分别是 C、A、P。</p>
<p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506789.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506789.png" alt="img"></a></p>
<h4 id="Consistency一致性"><a href="#Consistency一致性" class="headerlink" title="Consistency一致性"></a>Consistency一致性</h4><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p>
<p>比如现在包含两个节点，其中的初始数据是一致的</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506787.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506787.png" alt="img"></a></p>
<p>当我们修改其中一个节点的数据时，两者的数据产生了差异</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506790.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506790.png" alt="img"></a></p>
<p>要想保住一致性，就必须实现 node01 到 node02 的数据同步</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506801.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506801.png" alt="img"></a></p>
<h4 id="Availability可用性"><a href="#Availability可用性" class="headerlink" title="Availability可用性"></a>Availability可用性</h4><p>可用性是指节点能不能被正常的访问</p>
<p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p>
<p>如图，有三个节点的集群，访问任何一个都可以及时得到响应</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506803.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506803.png" alt="img"></a></p>
<p>当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506810.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506810.png" alt="img"></a></p>
<h4 id="Partition-Tolerance分区容错"><a href="#Partition-Tolerance分区容错" class="headerlink" title="Partition Tolerance分区容错"></a>Partition Tolerance分区容错</h4><p>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p>
<p>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506703.png"><img src="/../pic/202205231506703.png" alt="img"></a></p>
<p>在分布式系统中，系统间的网络不能 100% 保证健康，一定会有故障的时候，而服务有必须对外保证服务。<strong>因此 Partition Tolerance 不可避免。</strong>当节点接收到新的数据变更时，就会出现问题了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506722.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506722.png" alt="img"></a></p>
<p>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p>
<p>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那 node01、node02 与 node03 之间就会出现数据不一致。</p>
<p>也就是说，在 P 一定会出现的情况下，A 和 C 之间只能实现一个。</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE理论就是对问题的调和</p>
<p>BASE 理论是对 CAP 的一种解决思路，包含三个思想：</p>
<ul>
<li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li><strong>Soft State（软状态）</strong>：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li>
<li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li>
</ul>
<p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴 CAP定理 和 BASE理论，有两种解决思路</p>
<ul>
<li>AP 模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</li>
<li>CP 模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</li>
</ul>
<blockquote>
<p>前面我们所学的 Elasticsearch 集群就是 CP 模式，保证了数据的一致性。</p>
</blockquote>
<p>解决分布式事务，各个子系统之间必须能感知彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者，也就是需要一个事务协调者。（TC）</p>
<p>一个全局事务中往往包含着多个分支事务</p>
<p>另外，这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个<strong>分支事务</strong>在一起称为<strong>全局事务</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231506031.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231506031.png" alt="img"></a></p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/image-20221001115341352.png" alt="image-20221001115341352"></p>
<h2 id="部署Seata"><a href="#部署Seata" class="headerlink" title="部署Seata"></a>部署Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="http://seata.io/%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E6%92%AD%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82">http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231707983.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231707983.png" alt="img"></a></p>
<h3 id="Seata的架构"><a href="#Seata的架构" class="headerlink" title="Seata的架构"></a>Seata的架构</h3><p>Seata 事务管理中有三个重要的角色</p>
<ul>
<li><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者</strong>：维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器</strong>：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM (Resource Manager) -</strong> <strong>资源管理器</strong>：管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205231704030.png"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/202205231704030.png" alt="img"></a></p>
<p>Seata 基于上述架构提供了四种不同的分布式事务解决方案</p>
<ul>
<li>XA 模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li>TCC 模式：最终一致的分阶段事务模式，有业务侵入</li>
<li>AT 模式：最终一致的分阶段事务模式，无业务侵入，也是 Seata 的默认模式</li>
<li>SAGA 模式：长事务模式，有业务侵入</li>
</ul>
<p>无论哪种方案，都离不开 TC，也就是事务的协调者。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205232202909.png"><img src="/../pic/202205232202909.png" alt="img"></a></p>
<h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><p>下载 seata-server 包，<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/blog/download.html">https://seata.io/zh-cn/blog/download.html</a></p>
<p>在非中文目录解压缩，其目录结构如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709346.png"><img src="/../pic/202205241709346.png" alt="img"></a></p>
<p>修改 conf 目录下的 registry.conf 文件</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709343.png"><img src="/../pic/202205241709343.png" alt="img"></a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;SH&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>为了让 TC 服务的集群可以共享配置，我们选择了 Nacos 作为统一配置中心。因此服务端配置文件 <code>seataServer.properties</code> 文件需要在Nacos 中配好。在 Nacos 后台新建一个配置文件：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709375.png"><img src="/../pic/202205241709375.png" alt="img"></a></p>
<p>配置内容如下</p>
<blockquote>
<p>注意：一定要把注释删掉！并且需要修改你的数据库信息。</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据存储方式，db代表数据库</span></span><br><span class="line"><span class="attr">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="attr">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"># 这是MySQL8的驱动，MySQL5使用的是com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">store.db.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 数据库地址、用户名、密码都需要修改成你自己的数据库信息。</span></span><br><span class="line"><span class="attr">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">store.db.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="attr">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="attr">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="attr">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 事务、日志等配置</span></span><br><span class="line"><span class="attr">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="attr">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"><span class="comment"># 客户端与服务端传输方式</span></span><br><span class="line"><span class="attr">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="attr">transport.compressor</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 关闭metrics功能，提高性能</span></span><br><span class="line"><span class="attr">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="attr">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="attr">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure>

<p>TC 服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。新建一个名为 seata 的数据库，运行 SQL</p>
<p>这些表主要记录全局事务、分支事务、全局锁信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for branch_table</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `branch_table`;</span><br><span class="line">CREATE TABLE `branch_table`  (</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NULL DEFAULT NULL,</span><br><span class="line">  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`branch_id`) USING BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of branch_table</span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for global_table</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `global_table`;</span><br><span class="line">CREATE TABLE `global_table`  (</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NOT NULL,</span><br><span class="line">  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `timeout` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `begin_time` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`xid`) USING BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of global_table</span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of lock_table</span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure>

<p>进入 bin 目录，运行其中的 seata-server.bat 即可。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709380.png"><img src="/../pic/202205241709380.png" alt="img"></a></p>
<p>启动成功后，打开浏览器，访问 Nacos 地址：<a href="http://localhost:8848，然后进入服务列表页面，可以看到">http://localhost:8848，然后进入服务列表页面，可以看到</a> seata-tc-server 的信息。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709137.png"><img src="/../pic/202205241709137.png" alt="img"></a></p>
<h3 id="Seata微服务集成"><a href="#Seata微服务集成" class="headerlink" title="Seata微服务集成"></a>Seata微服务集成</h3><p>这个如果想每个服务都有Seata服务，都得配置下面的属性</p>
<blockquote>
<p>很多人说这里很难，启动老是失败，注意检查好上一步配置是否正确，比如集群是否是 SH，分区是否是 DEFAULT_GROUP，实例名是否是 seata-tc-server</p>
</blockquote>
<p>首先，我们需要在微服务中引入 Seata 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要修改 application.yml 文件，添加一些配置，例如在 order-service 服务中的 application.yml，配置 TC 服务信息，通过注册中心 Nacos，结合服务名称获取 TC 地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure>

<p>微服务如何根据这些配置寻找 TC 地址的，我们知道注册到 Nacos 中的微服务，确定一个具体实例需要四个信息，<code>namespace+group+application+cluster</code></p>
<ul>
<li>namespace：命名空间，为空就是默认的 public</li>
<li>group：分组</li>
<li>application：服务名</li>
<li>cluster：集群名</li>
</ul>
<p>以上四个信息，在刚才的 yml 文件中都能找到。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241726339.png"><img src="/../pic/202205241726339.png" alt="img"></a></p>
<p>结合起来，TC 服务的信息就是：<code>public@DEFAULT_GROUP@seata-tc-server@SH</code>，这样就能确定 TC 服务集群了。然后就可以去 Nacos拉取对应的实例信息。</p>
<p>启动微服务后，Seata 控制台会显示连接上的服务。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242305852.png"><img src="/../pic/202205242305852.png" alt="img"></a></p>
<h3 id="TC服务异地容灾"><a href="#TC服务异地容灾" class="headerlink" title="TC服务异地容灾"></a>TC服务异地容灾</h3><p>1.模拟异地容灾的 TC 集群</p>
<p>计划启动两台 Seata 的 TC 服务节点</p>
<table>
<thead>
<tr>
<th align="left">节点名称</th>
<th align="left">ip地址</th>
<th align="left">端口号</th>
<th align="left">集群名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">seata</td>
<td align="left">127.0.0.1</td>
<td align="left">8091</td>
<td align="left">SH</td>
</tr>
<tr>
<td align="left">seata2</td>
<td align="left">127.0.0.1</td>
<td align="left">8092</td>
<td align="left">HZ</td>
</tr>
</tbody></table>
<p>之前我们已经启动了一台 seata 服务，端口是 8091，集群名为 SH。</p>
<p>现在，将 seata 目录复制一份，起名为 seata2</p>
<p>修改 seata2&#x2F;conf&#x2F;registry.conf 内容如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">registry</span> &#123;</span><br><span class="line">  <span class="comment"># tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attribute">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    <span class="comment"># seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attribute">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    group = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;HZ&quot;</span></span><br><span class="line">    username = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    password = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  <span class="comment"># 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attribute">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="comment"># 配置nacos地址等信息</span></span><br><span class="line">  nacos &#123;</span><br><span class="line">    <span class="attribute">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    username = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    password = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    dataId = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 seata2&#x2F;bin 目录，然后运行命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">seata<span class="literal">-server</span>.bat <span class="literal">-p</span> <span class="number">8092</span></span><br></pre></td></tr></table></figure>

<p>打开 nacos 控制台，查看服务列表</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709152.png"><img src="/../pic/202205241709152.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709154.png"><img src="/../pic/202205241709154.png" alt="img"></a></p>
<p>2.将事务组映射配置到 nacos</p>
<p>接下来，我们需要将 tx-service-group 与 cluster 的映射关系都配置到 Nacos 配置中心。</p>
<p>新建一个配置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205241709167.png"><img src="/../pic/202205241709167.png" alt="img"></a></p>
<p>配置的内容如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事务组映射关系</span></span><br><span class="line"><span class="attr">service.vgroupMapping.seata-demo</span>=<span class="string">SH</span></span><br><span class="line"><span class="attr">service.enableDegrade</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">service.disableGlobalTransaction</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 与TC服务的通信配置</span></span><br><span class="line"><span class="attr">transport.type</span>=<span class="string">TCP</span></span><br><span class="line"><span class="attr">transport.server</span>=<span class="string">NIO</span></span><br><span class="line"><span class="attr">transport.heartbeat</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">transport.enableClientBatchSendRequest</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">transport.threadFactory.bossThreadPrefix</span>=<span class="string">NettyBoss</span></span><br><span class="line"><span class="attr">transport.threadFactory.workerThreadPrefix</span>=<span class="string">NettyServerNIOWorker</span></span><br><span class="line"><span class="attr">transport.threadFactory.serverExecutorThreadPrefix</span>=<span class="string">NettyServerBizHandler</span></span><br><span class="line"><span class="attr">transport.threadFactory.shareBossWorker</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientSelectorThreadPrefix</span>=<span class="string">NettyClientSelector</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientSelectorThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">transport.threadFactory.clientWorkerThreadPrefix</span>=<span class="string">NettyClientWorkerThread</span></span><br><span class="line"><span class="attr">transport.threadFactory.bossThreadSize</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">transport.threadFactory.workerThreadSize</span>=<span class="string">default</span></span><br><span class="line"><span class="attr">transport.shutdown.wait</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># RM配置</span></span><br><span class="line"><span class="attr">client.rm.asyncCommitBufferLimit</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">client.rm.lock.retryInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">client.rm.lock.retryTimes</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">client.rm.lock.retryPolicyBranchRollbackOnConflict</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.rm.reportRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.rm.tableMetaCheckEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.rm.tableMetaCheckerInterval</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">client.rm.sqlParserType</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">client.rm.reportSuccessEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.rm.sagaBranchRegisterEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># TM配置</span></span><br><span class="line"><span class="attr">client.tm.commitRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.tm.rollbackRetryCount</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">client.tm.defaultGlobalTransactionTimeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">client.tm.degradeCheck</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">client.tm.degradeCheckAllowTimes</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">client.tm.degradeCheckPeriod</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># undo日志配置</span></span><br><span class="line"><span class="attr">client.undo.dataValidation</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.logSerialization</span>=<span class="string">jackson</span></span><br><span class="line"><span class="attr">client.undo.onlyCareUpdateColumns</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.logTable</span>=<span class="string">undo_log</span></span><br><span class="line"><span class="attr">client.undo.compress.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">client.undo.compress.type</span>=<span class="string">zip</span></span><br><span class="line"><span class="attr">client.undo.compress.threshold</span>=<span class="string">64k</span></span><br><span class="line"><span class="attr">client.log.exceptionRate</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure>

<p>3.微服务读取nacos配置</p>
<p>接下来，需要修改每一个微服务的 application.yml 文件，让微服务读取 Nacos 中的 client.properties 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">data-id:</span> <span class="string">client.properties</span></span><br></pre></td></tr></table></figure>

<p>重启微服务，现在微服务到底是连接 TC 的 SH 集群，还是 TC 的 HZ 集群，都统一由 Nacos 的 client.properties 来决定了。</p>
<p>大体先了解这么多，具体参考官方文档学习：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<h2 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h2><p>XA 规范 是 X&#x2F;Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的 TM 与局部的 RM 之间的接口，几乎所有主流的数据库都对 XA 规范提供了支持。</p>
<p>XA 是规范，目前主流数据库都实现了这种规范，实现的原理都是<strong>基于两阶段提交</strong>。</p>
<p>正常情况：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242231750.png"><img src="/../pic/202205242231750.png" alt="img"></a></p>
<p>异常情况：</p>
<p>（注意是只通知执行过并且执行成功的程序进行回滚）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242231755.png"><img src="/../pic/202205242231755.png" alt="img"></a></p>
<p>一阶段：</p>
<p>1.事务协调者通知每个事物参与者执行本地事务</p>
<p>2.本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</p>
<p>二阶段：</p>
<ul>
<li>事务协调者基于一阶段的报告来判断下一步操作<ul>
<li>如果一阶段都成功，则通知所有事务参与者，提交事务</li>
<li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li>
</ul>
</li>
</ul>
<p>Seata 对原始的 XA 模式做了简单的封装和改造，以适应自己的事务模型，基本架构如下图</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242231760.png"><img src="/../pic/202205242231760.png" alt="img"></a></p>
<p>RM 一阶段的工作：</p>
<p>① 注册分支事务到TC</p>
<p>② 执行分支业务 SQL 但不提交</p>
<p>③ 报告执行状态到 TC</p>
<p>TC 二阶段的工作：</p>
<ul>
<li><p>TC 检测各分支事务执行状态</p>
<p>a.如果都成功，通知所有 RM 提交事务</p>
<p>b.如果有失败，通知所有 RM 回滚事务</p>
</li>
</ul>
<p>RM 二阶段的工作：</p>
<ul>
<li>接收 TC 指令，提交或回滚事务</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>XA 模式的优点是什么？</p>
<ul>
<li>事务的强一致性，满足 ACID 原则。</li>
<li>常用数据库都支持，实现简单，并且没有代码侵入。</li>
</ul>
<p>XA 模式的缺点是什么？</p>
<ul>
<li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差。</li>
<li>依赖关系型数据库实现事务。</li>
</ul>
<h3 id="实现XA模式"><a href="#实现XA模式" class="headerlink" title="实现XA模式"></a>实现XA模式</h3><p>Seata 的 starter 已经完成了 XA 模式的自动装配，实现非常简单，步骤如下</p>
<p>1）修改每一个微服务的 application.yml 文件（每个参与事务的微服务），开启XA模式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure>

<p>2）给发起全局事务的入口方法添加 <code>@GlobalTransactional</code> 注解</p>
<p>本例中是 OrderServiceImpl 中的 create 方法.</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242231783.png"><img src="/../pic/202205242231783.png" alt="img"></a></p>
<p>3）重启服务并测试</p>
<p>重启 order-service，再次测试，发现无论怎样异常情况，三个微服务都能成功回滚。</p>
<h2 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h2><p>AT 模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p>
<p>基本流程图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242258121.png"><img src="/../pic/202205242258121.png" alt="img"></a></p>
<p>阶段一 RM 的工作：</p>
<ul>
<li>注册分支事务</li>
<li><strong>记录 undo-log（数据快照）</strong></li>
<li><strong>执行业务 SQL 并提交事务</strong></li>
<li>报告事务状态</li>
</ul>
<p>阶段二提交时 RM 的工作：</p>
<ul>
<li>删除 undo-log 即可</li>
</ul>
<p>阶段二回滚时 RM 的工作：</p>
<ul>
<li>根据 undo-log 恢复数据到更新前</li>
</ul>
<h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p>我们用一个真实的业务来梳理下 AT 模式的原理。</p>
<p>比如，现在有一个数据库表，记录用户余额</p>
<table>
<thead>
<tr>
<th align="left"><strong>id</strong></th>
<th align="left"><strong>money</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">100</td>
</tr>
</tbody></table>
<p>其中一个分支业务要执行的 SQL 为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>AT模式下，当前分支事务执行流程如下：</p>
<p>一阶段：</p>
<p>1）TM 发起并注册全局事务到 TC</p>
<p>2）TM 调用分支事务</p>
<p>3）分支事务准备执行业务 SQL</p>
<p>4）RM 拦截业务 SQL，根据 where 条件查询原始数据，形成快照。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>5）RM 执行业务 SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></p>
<p>6）RM 报告本地事务状态给 TC</p>
<p>二阶段：</p>
<p>1）TM 通知 TC 事务结束</p>
<p>2）TC 检查分支事务状态。如果都成功，则立即删除快照；如果有分支事务失败，需要回滚。读取快照数据<code>&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;</code>，将快照恢复到数据库。此时数据库再次恢复为 100。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242258118.png"><img src="/../pic/202205242258118.png" alt="img"></a></p>
<h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述 AT 模式与 XA 模式最大的区别是什么？</p>
<ul>
<li>XA 模式一阶段不提交事务，锁定资源；AT 模式一阶段直接提交，不锁定资源。</li>
<li>XA 模式依赖数据库机制实现回滚；AT 模式利用数据快照实现数据回滚。</li>
<li>XA 模式强一致；AT 模式最终一致。</li>
</ul>
<h3 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a>脏写问题</h3><blockquote>
<p>注意：此处脏写是在多线程环境下的问题</p>
</blockquote>
<p>在<strong>多线程并发</strong>访问 AT 模式的分布式事务时，有可能出现脏写问题。如图，当事务 1 因为某些原因要恢复快照时，另一个线程的事务 2 白更新了一次数据，出现了脏写问题。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242258122.png"><img src="/../pic/202205242258122.png" alt="img"></a></p>
<p>解决思路就是引入了全局锁的概念。在提交事务之前，先去拿全局锁，避免同一时刻有另外一个事务在操作当前数据，拿不到全局锁超过一定时间则回滚。如图，这样一来事务 2 就更新失败了，此时事务 1 恢复数据不会给另一个线程事务 2 造成改了又没改的离谱现象。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205242258136.png"><img src="/../pic/202205242258136.png" alt="img"></a></p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>AT 模式的优点：</p>
<ul>
<li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li>
<li>利用全局锁实现读写隔离</li>
<li>没有代码侵入，框架自动完成回滚和提交</li>
</ul>
<p>AT 模式的缺点：</p>
<ul>
<li>两阶段之间属于软状态，属于最终一致</li>
<li>框架的快照功能会影响性能，但比XA模式要好很多</li>
</ul>
<h3 id="实现AT模式"><a href="#实现AT模式" class="headerlink" title="实现AT模式"></a>实现AT模式</h3><p>AT 模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p>
<p>只不过，AT模式需要一个表来记录全局锁、另一张表来记录数据快照 undo_log</p>
<p>1）导入数据库表，记录全局锁</p>
<p>lock_table 表导入到 TC 服务关联的数据库，我这里的 TC 服务数据库是 seata</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for lock_table</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `lock_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock_table`  (</span><br><span class="line">  `row_key` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">96</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pk` <span class="type">varchar</span>(<span class="number">36</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`row_key`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_branch_id`(`branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>undo_log 表导入到微服务关联的数据库，我这里的微服务数据库是 seata_demo</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for undo_log</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `undo_log`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log`  (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">  `log_created` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">  `log_modified` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `ux_undo_log`(`xid`, `branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;AT transaction mode undo table&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>2）修改 application.yml 文件，将事务模式修改为 AT 模式即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 默认就是AT</span></span><br></pre></td></tr></table></figure>

<p>3）重启服务并测试。</p>
<h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><p>TCC 模式与 AT 模式非常相似，每阶段都是独立事务，不同的是 TCC 模式通过人工编码来实现数据恢复。需要实现三个方法：</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li>
<li>Cancel：预留资源释放，可以理解为 try 的反向操作。</li>
</ul>
<p>例如，一个扣减用户余额的业务。假设账户 A 原来余额是 100，需要余额扣减 30 元。</p>
<p><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加 30 元，可用余额扣除 30</p>
<p>初始余额</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261907452.png"><img src="/../pic/202205261907452.png" alt="img"></a></p>
<p>余额充足，可以冻结</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261907455.png"><img src="/../pic/202205261907455.png" alt="img"></a></p>
<p>此时，总金额 &#x3D; 冻结金额 + 可用金额，数量依然是 100 不变。事务直接提交无需等待其它事务。</p>
<p>**阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减 30</p>
<p>确认可以提交，不过之前可用金额已经扣减过了，这里只要清除冻结金额就好了</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261907456.png"><img src="/../pic/202205261907456.png" alt="img"></a></p>
<p>此时，总金额 &#x3D; 冻结金额 + 可用金额 &#x3D; 0 + 70 &#x3D; 70元</p>
<p>**阶段二(Canncel)**：如果要回滚（Cancel），则冻结金额扣减 30，可用余额增加 30</p>
<p>需要回滚，那么就要释放冻结金额，恢复可用金额</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261907454.png"><img src="/../pic/202205261907454.png" alt="img"></a></p>
<p>Seata 中的 TCC 模型依然延续之前的事务架构，如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261907469.png"><img src="/../pic/202205261907469.png" alt="img"></a></p>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>TCC 模式的每个阶段是做什么的？</p>
<ul>
<li>Try：资源检查和预留</li>
<li>Confirm：业务执行和提交</li>
<li>Cancel：预留资源的释放</li>
</ul>
<p>TCC 的优点是什么？</p>
<ul>
<li>一阶段完成直接提交事务，释放数据库资源，性能好</li>
<li>相比 AT 模型，无需生成快照，无需使用全局锁，性能最强</li>
<li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li>
</ul>
<p>TCC 的缺点是什么？</p>
<ul>
<li>有代码侵入，需要人为编写 try、Confirm 和 Cancel 接口，太麻烦</li>
<li>软状态，事务是最终一致</li>
<li>需要考虑 Confirm 和 Cancel 的失败情况，做好幂等处理</li>
</ul>
<h3 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h3><p>当某分支事务的 try 阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的 cancel 操作。在未执行 try 操作时先执行了 cancel 操作，这时cancel 不能做回滚，就是<strong>空回滚</strong>。执行 cancel 操作时，应当判断 try 是否已经执行，如果尚未执行，则应该空回滚。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205261921656.png"><img src="/../pic/202205261921656.png" alt="img"></a></p>
<h3 id="业务悬挂"><a href="#业务悬挂" class="headerlink" title="业务悬挂"></a>业务悬挂</h3><p>空回滚后出现的一个新问题：对于已经空回滚的业务，之前被阻塞的 try 操作恢复，继续执行 try，可此时整个业务都已经结束了，难道我们可以让他再去走 confirm 或 cancel 吗，显然不行。因此事务一直处于中间状态，这就是<strong>业务悬挂</strong>，我们应当去避免这种情况。所以执行 try 操作时，应当判断 cancel 是否已经执行过了，如果已经执行，<strong>应当阻止空回滚后的 try 操作，避免悬挂。</strong></p>
<h3 id="实现TCC模式"><a href="#实现TCC模式" class="headerlink" title="实现TCC模式"></a>实现TCC模式</h3><h4 id="设计数据表"><a href="#设计数据表" class="headerlink" title="设计数据表"></a>设计数据表</h4><p>实现 TCC 模式我们都知道要去记录冻结状态，所以这就需要一个数据表。</p>
<p>xid：是全局事务 id</p>
<p>freeze_money：用来记录用户冻结金额</p>
<p>state：用来记录事务状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account_freeze_tbl` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `freeze_money` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;冻结金额&#x27;</span>,</span><br><span class="line">  `state` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>

<ul>
<li>Try 业务<ul>
<li>记录冻结金额和事务状态到 account_freeze 表</li>
<li>扣减 account 表可用金额</li>
</ul>
</li>
<li>Confirm 业务<ul>
<li>根据 xid 删除 account_freeze 表的冻结记录</li>
</ul>
</li>
<li>Cancel 业务<ul>
<li>修改 account_freeze 表，冻结金额为 0，state 为 2</li>
<li>修改 account 表，恢复可用金额</li>
</ul>
</li>
<li>如何判断是否空回滚<ul>
<li>cancel 业务中，根据 xid 查询 account_freeze，如果为 null 则说明 try 还没做，需要空回滚</li>
</ul>
</li>
<li>如何避免业务悬挂<ul>
<li>try 业务中，根据 xid 查询 account_freeze，如果已经存在则证明 Cancel 已经执行，拒绝执行 try 业务</li>
</ul>
</li>
</ul>
<p>接下来，我们根据实际业务修改 account-service，利用 TCC 实现余额扣减功能。</p>
<h4 id="声明TCC接口"><a href="#声明TCC接口" class="headerlink" title="声明TCC接口"></a>声明TCC接口</h4><blockquote>
<p>Seata 全局事务的 id 可以通过 <code>RootContext.getXID();</code> 获取，</p>
<p>也可以通过 BusinessActionContext 参数的 getXid() 方法获取。</p>
</blockquote>
<p>TCC 的 Try、Confirm、Cancel 方法都需要在接口中基于注解来声明，首先是接口上要用 <code>@LocalTCC</code>，try 逻辑方法用注解<code>@TwoPhaseBusinessAction(name=&quot;try 方法名&quot;, commitMethod=&quot;confirm 方法名&quot;, rollbackMethod=&quot;cancel 方法名&quot;) </code>注明 ，在该方法参数上加入 <code>@BusinessActionContextParameter(paramName=&quot;try 方法的参数&quot;)</code>，可以使得该参数传入 <code>BusinessActionContext</code> 类，便于 confirm 和 cancel 读取。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205281606688.png"><img src="/../pic/202205281606688.png" alt="img"></a></p>
<p>我们在 account-service 项目中的 service 包中新建一个接口，声明 TCC 三个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTCCService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span><br><span class="line"><span class="params">                <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span><span class="type">int</span> money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写实现类"><a href="#编写实现类" class="headerlink" title="编写实现类"></a>编写实现类</h4><p>在 account-service 服务中的 service.impl 包下新建一个类，实现 TCC 业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountTCCService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(String userId, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 0.获取事务id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">        <span class="comment">// 处理业务悬挂</span></span><br><span class="line">        <span class="keyword">if</span> (freezeMapper.selectById(xid) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.扣减可用余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 2.记录冻结金额，事务状态</span></span><br><span class="line">        <span class="type">AccountFreeze</span> <span class="variable">freeze</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountFreeze</span>();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取事务id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> ctx.getXid();</span><br><span class="line">        <span class="comment">// 2.根据id删除冻结记录</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> freezeMapper.deleteById(xid);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 0.查询冻结记录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> ctx.getXid();</span><br><span class="line">        <span class="type">AccountFreeze</span> <span class="variable">freeze</span> <span class="operator">=</span> freezeMapper.selectById(xid);</span><br><span class="line">        <span class="comment">// 处理空回滚</span></span><br><span class="line">        <span class="keyword">if</span> (freeze == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//空回滚</span></span><br><span class="line">            freeze = <span class="keyword">new</span> <span class="title class_">AccountFreeze</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> ctx.getActionContext(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line">            freeze.setUserId(userId);</span><br><span class="line">            freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">            freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">            freeze.setXid(xid);</span><br><span class="line">            freezeMapper.insert(freeze);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 幂等判断</span></span><br><span class="line">        <span class="keyword">if</span>(freeze.getState() == AccountFreeze.State.CANCEL)&#123;</span><br><span class="line">            <span class="comment">// 已经处理过了cancel，无需重复</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 2.将冻结金额清零，状态改为CANCEL</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> freezeMapper.updateById(freeze);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h2><p>Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。Seata 官网对于 Saga 的指南：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任意一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202205281708899.png"><img src="/../pic/202205281708899.png" alt="img"></a></p>
<p>Saga 模式也分为两个阶段</p>
<ul>
<li>一阶段：直接提交本地事务</li>
<li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li>
</ul>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li>
<li>一阶段直接提交事务，无锁，性能好</li>
<li>不用编写 TCC 中的三个阶段，实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>软状态持续时间不确定，时效性差</li>
<li>没有锁，没有事务隔离，会有脏写</li>
</ul>
<h1 id="Redis分布式缓存"><a href="#Redis分布式缓存" class="headerlink" title="Redis分布式缓存"></a>Redis分布式缓存</h1><p>单机的 Redis 存在以下四大问题，我们将学着去解决。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142215082.png"><img src="/../pic/202206142215082.png" alt="img"></a></p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis持久化分为两种：</p>
<ul>
<li>RDB 持久化</li>
<li>AOF 持久化</li>
</ul>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB 全称 Redis Database Backup file（Redis数据备份文件），也被叫做 Redis 数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为 RDB 文件，<strong>默认是保存在当前运行目录。</strong></p>
<p>RDB 持久化在四种情况下会执行</p>
<ul>
<li>执行 save 命令</li>
<li>执行 bgsave 命令</li>
<li>Redis 停机时</li>
<li>触发 RDB 条件时</li>
</ul>
<p><strong>save 命令</strong></p>
<p>执行下面的命令，可以立即执行一次 RDB</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216902.png"><img src="/../pic/202206142216902.png" alt="img"></a></p>
<p>save 命令会导致<strong>主进程</strong>执行 RDB，这个过程中<strong>其它所有命令都会被阻塞</strong>。只有在数据迁移时可能用到。</p>
<p><strong>bgsave 命令</strong></p>
<p>这种方法比较适合在运行的过程中使用</p>
<p>下面的命令可以<strong>异步</strong>执行 RDB</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216906.png"><img src="/../pic/202206142216906.png" alt="img"></a></p>
<p>这个命令执行后会开启独立进程完成 RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>停机时</strong></p>
<p>Redis 停机时会执行一次 save 命令，实现 RDB 持久化。</p>
<p><strong>自动触发 RDB 条件</strong></p>
<p>Redis 内部有触发 RDB 的机制，可以在 redis.conf 文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave</span></span><br><span class="line"><span class="comment"># save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#举例，可以理解一下</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>

<p>RDB 的其它配置也可以在 redis.conf 文件中设置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>

<p>bgsave 开始时会 <strong>fork</strong> 主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件。</p>
<p>fork 采用的是 copy-on-write 技术：当主进程执行读操作时，访问共享内存；当主进程执行写操作时，则会拷贝一份数据，执行写操作。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216920.png"><img src="/../pic/202206142216920.png" alt="img"></a></p>
<p>RDB 方式 bgsave 的基本流程？</p>
<ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新 的RDB 文件</li>
<li>用新 RDB 文件替换旧的 RDB 文件</li>
</ul>
<p>RDB 会在什么时候自动执行？save 60 1000代表什么含义？</p>
<ul>
<li>默认是服务停止时</li>
<li>代表 60s 内至少执行 1000 次修改则触发 RDB</li>
</ul>
<p>RDB 的缺点？</p>
<ul>
<li>RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险</li>
<li>fork 子进程、压缩、写出 RDB 文件都比较耗时</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF 全称为 Append Only File（追加文件），Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216922.png"><img src="/../pic/202206142216922.png" alt="img"></a></p>
<p>AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启 AOF</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>

<p>AOF 的命令记录的频率也可以通过 redis.conf 文件来配</p>
<p><strong>下面三种方法放开一种就可以了</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>三种策略对比</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216924.png"><img src="/../pic/202206142216924.png" alt="img"></a></p>
<p><strong>AOF文件重写</strong></p>
<p>因为是记录命令，AOF 文件会比 RDB 文件大的多。而且 AOF <strong>会记录对同一个 key 的多次</strong>写操作，但只有最后一次写操作才有意义。通过执行 bgrewriteaof 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216934.png"><img src="/../pic/202206142216934.png" alt="img"></a></p>
<p>如图，AOF 原本有三个命令，但是这三个都是对 num 的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<ol>
<li>可以自己手动触发这个命令</li>
</ol>
<p><img src="/../pic/image-20221109154035049.png" alt="image-20221109154035049"></p>
<ol start="2">
<li>Redis 也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 redis.conf 中配置</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>





<h3 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h3><p>RDB 和 AOF 各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142216414.png"><img src="/../pic/202206142216414.png" alt="img"></a></p>
<p>Redis 支持同时开启 RDB 和 AOF，在这种情况下当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集完整。</p>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206142243954.png"><img src="/../pic/202206142243954.png" alt="img"></a></p>
<h3 id="搭建主从"><a href="#搭建主从" class="headerlink" title="搭建主从"></a>搭建主从</h3><blockquote>
<p>跳过部署三个 Redis，很简单。</p>
</blockquote>
<p>共包含三个节点，一个主节点，两个从节点。</p>
<p>这里我们在同一台虚拟机中开启 3 个 Redis 实例，模拟主从集群，信息如下：</p>
<table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">PORT</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.150.101</td>
<td align="center">7001</td>
<td align="center">master</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">7002</td>
<td align="center">slave</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">7003</td>
<td align="center">slave</td>
</tr>
</tbody></table>
<p>为了方便查看日志，我们打开 3 个 ssh 窗口，分别启动 Redis 实例，启动命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-server 7001/redis.conf</span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-server 7003/redis.conf</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150213482.png"><img src="/../pic/202206150213482.png" alt="img"></a></p>
<p>如果要一键停止，可以运行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure>





<p><strong>开启主从关系</strong></p>
<p>现在三个实例还没有任何关系，要配置主从可以使用 <code>replicaof</code> 或者 <code>slaveof</code>（5.0以前）命令。</p>
<p>有临时和永久两种模式：</p>
<p>1.修改配置文件（永久生效）</p>
<p>在 redis.conf 中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
<p>2.使用 redis-cli 客户端连接到redis服务，执行slaveof命令（重启后失效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 5.0 以后新增命令 replicaof，与 salveof 效果一致。</p>
</blockquote>
<p>这里我们为了演示方便，使用方式二。通过 redis-cli 命令连接 7002，执行下面命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接 7002</span></span><br><span class="line">redis-cli -p 7002</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure>

<p>通过 redis-cli 命令连接 7003，执行下面命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接 7003</span></span><br><span class="line">redis-cli -p 7003</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure>

<p>然后连接 7001 节点，查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150213485.png"><img src="/../pic/202206150213485.png" alt="img"></a></p>
<p>执行下列操作以测试</p>
<ul>
<li>利用 redis-cli 连接7001，执行<code>set num 123</code></li>
<li>利用 redis-cli 连接7002，执行<code>get num</code>，再执行<code>set num 666</code></li>
<li>利用 redis-cli 连接7003，执行<code>get num</code>，再执行<code>set num 888</code></li>
</ul>
<p>可以发现，只有在 7001 这个 master 节点上可以执行写操作，7002 和 7003 这两个 slave 节点只能执行读操作。</p>
<h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将 master 节点的所有数据都拷贝给 slave 节点，流程如下</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222378.png"><img src="/../pic/202206150222378.png" alt="img"></a></p>
<p>有几个概念需要知道：</p>
<ul>
<li><strong>Replication Id</strong>：简称 replid，是数据集的标记，id 一致则说明是同一数据集。每一个 master 都有唯一的replid，slave 则会继承 master 节点的 replid；</li>
<li><strong>offset</strong>：偏移量，随着记录在 repl_baklog 中的数据增多而逐渐增大。slave 完成同步时也会记录当前同步的offset，即 slave 的 offset 永远小于等于 master 的 offset；当 slave 的 offset 小于 master 的 offset，说明 slave 数据落后于 master，需要更新。</li>
</ul>
<p>因此 slave 做数据同步，必须向 master 声明自己的 replid 和 offset，master 才可以判断到底需要同步哪些数据。而 slave 原本也是一个 master，有自己的 replid 和 offset，当第一次变成 slave，与 master 建立连接时，发送的 replid 和 offset 是自己的 replid 和 offset。master 判断发现 slave 发送来的 replid 与自己的不一致，说明这是一个全新的 slave，就知道要做全量同步了。master 会将自己的 replid 和 offset 都发送给这个 slave，slave 保存这些信息。以后 slave 的replid 就与 master 一致了。因此，<strong>master判断一个节点是否是第一次同步的依据，就是看 replid 是否一致</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222382.png"><img src="/../pic/202206150222382.png" alt="img"></a></p>
<p>完整流程描述：</p>
<ul>
<li>slave 节点请求增量同步</li>
<li>master 节点判断 replid，发现不一致，拒绝增量同步，选择全量同步</li>
<li>master 将完整内存数据生成 RDB，发送 RDB 到 slave</li>
<li>slave 清空本地数据，加载 master 的 RDB</li>
<li>master 将 RDB 期间的命令记录在 repl_baklog，并持续将 log 中的命令发送给 slave</li>
<li>slave 执行接收到的命令，保持与 master 之间的同步</li>
</ul>
<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>全量同步需要先做 RDB，然后将 RDB 文件通过网络传输给 slave，成本太高。因此除了第一次做全量同步，其它大多数时候 slave 与 master 都是做<strong>增量同步</strong>。</p>
<p>什么是增量同步？就是只更新 slave 与 master 存在差异的部分数据。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222386.png"><img src="/../pic/202206150222386.png" alt="img"></a></p>
<p><strong>repl_backlog 原理</strong></p>
<p>master 怎么知道 slave 与自己的数据差异在哪里？</p>
<p>这就要说到全量同步时的 repl_baklog 文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从 0 开始读写</strong>，这样数组头部的数据就会被覆盖。repl_baklog 中会记录 Redis 处理过的命令日志及 offset，包括 master 当前的 offset 和 slave 已经拷贝到的 offset</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222384.png"><img src="/../pic/202206150222384.png" alt="img"></a></p>
<p>slave 与 master 的 offset 之间的差异，就是 salve 需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master 的 offset 逐渐变大，slave 也不断的拷贝，追赶 master 的 offset，直到数组被填满：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222403.png"><img src="/../pic/202206150222403.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222407.png"><img src="/../pic/202206150222407.png" alt="img"></a></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave 的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。但是，如果 slave 出现网络阻塞，导致 master 的 offset 远远超过了 slave 的 offset，如下图</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222063.png"><img src="/../pic/202206150222063.png" alt="img"></a></p>
<p>如果 master 继续写入新数据，其 offset 就会覆盖旧的数据，直到将 slave 现在的 offset 也覆盖了</p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222082.png"><img src="/../pic/202206150222082.png" alt="img"></a></p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果 slave 恢复，需要同步，却发现自己的 offset 都没有了，<strong>无法完成增量同步了，只能做全量同步。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222104.png"><img src="/../pic/202206150222104.png" alt="img"></a></p>
<h3 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h3><p>主从同步可以保证主从数据的一致性，非常重要。可以从以下几个方面来优化 Redis 主从集群</p>
<ul>
<li>在 master 中配置 <code>repl-diskless-sync yes</code> 启用无磁盘复制，避免全量同步时的磁盘 IO</li>
<li>Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘IO</li>
<li>适当提高 repl_baklog 的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个 master 上的 slave 节点数量，如果实在是太多 slave，则可以采用<strong>主-从-从</strong>链式结构，减少 master 压力</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.xn2001.com/img/2022/202206150222112.png"><img src="/../pic/202206150222112.png" alt="img"></a></p>
<p>简述全量同步和增量同步区别？</p>
<ul>
<li>全量同步：master 将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在 repl_baklog，逐个发送给slave</li>
<li>增量同步：slave 提交自己的 offset 到 master，master 获取 repl_baklog 中从 offset 之后的命令给slave</li>
</ul>
<p>什么时候执行全量同步？</p>
<ul>
<li>slave 节点第一次连接 master 节点时</li>
<li>slave 节点断开时间太久，repl_baklog 中的 offset 已经被覆盖时</li>
</ul>
<p>什么时候执行增量同步？</p>
<ul>
<li>slave 节点断开又恢复，并且在 repl_baklog 中能找到 offset 时</li>
</ul>
<h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><p>思考一下：slave节点宕机恢复后可以找master节点同步数据，那master节点宕机怎么办?</p>
<p>和之前的MySQL一样，如果搭建集群，master节点挂了，在剩下的slave节点中选出一个做master就好了</p>
<h3 id="哨兵的作用和原理"><a href="#哨兵的作用和原理" class="headerlink" title="哨兵的作用和原理"></a>哨兵的作用和原理</h3><p><img src="/../pic/image-20221109214318023.png" alt="image-20221109214318023"></p>
<p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令（众所周知会得到pong）:</p>
<ul>
<li>主观下线:如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li>客观下线:若超过**指定数量(quorum)**的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超<br>过Sentinel实例数量的一半。</li>
</ul>
<p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值(down-after-milliseconds *10）则会排除该<br>slave节点</li>
<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举。</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高。</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高。</li>
</ul>
<p><img src="/../pic/image-20221110093405488.png" alt="image-20221110093405488"></p>
<p>总结</p>
<p>Sentinel的三个作用是什么?</p>
<ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<p>Sentinel如何判断一个redis实例是否健康?</p>
<ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主<br>观下线</li>
</ul>
<p>如果大多数sentinel都认为实例主观下线，则判定服务下线故障转移步骤有哪些?</p>
<ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点都执行slaveof新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h3 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h3><h4 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h4><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p>
<p><img src="/../pic/image-20210701215227018.png" alt="image-20210701215227018"></p>
<p>三个sentinel实例信息如下：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th align="center">IP</th>
<th align="center">PORT</th>
</tr>
</thead>
<tbody><tr>
<td>s1</td>
<td align="center">192.168.150.101</td>
<td align="center">27001</td>
</tr>
<tr>
<td>s2</td>
<td align="center">192.168.150.101</td>
<td align="center">27002</td>
</tr>
<tr>
<td>s3</td>
<td align="center">192.168.150.101</td>
<td align="center">27003</td>
</tr>
</tbody></table>
<h4 id="准备实例和配置"><a href="#准备实例和配置" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h4><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p>
<p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/../pic/image-20210701215534714.png" alt="image-20210701215534714"></p>
<p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.150.101</span><br><span class="line">sentinel monitor mymaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/tmp/s1&quot;</span><br></pre></td></tr></table></figure>

<p>解读：</p>
<ul>
<li><code>port 27001</code>：是当前sentinel实例的端口</li>
<li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息<ul>
<li><code>mymaster</code>：主节点名称，自定义，任意写</li>
<li><code>192.168.150.101 7001</code>：主节点的ip和端口</li>
<li><code>2</code>：选举master时的quorum值</li>
</ul>
</li>
</ul>
<p>然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure>



<p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure>



<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure>



<p>启动后：</p>
<p><img src="/../pic/image-20210701220714104.png" alt="image-20210701220714104"></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>尝试让master节点7001宕机，查看sentinel日志：</p>
<p><img src="/../pic/image-20210701222857997.png" alt="image-20210701222857997"></p>
<p>查看7003的日志：</p>
<p><img src="/../pic/image-20210701223025709.png" alt="image-20210701223025709"></p>
<p>查看7002的日志：</p>
<p><img src="/../pic/image-20210701223131264.png" alt="image-20210701223131264"></p>
<h3 id="RedisTemplate的哨兵模式"><a href="#RedisTemplate的哨兵模式" class="headerlink" title="RedisTemplate的哨兵模式"></a>RedisTemplate的哨兵模式</h3><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置Redis地址"><a href="#配置Redis地址" class="headerlink" title="配置Redis地址"></a>配置Redis地址</h4><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">      master: mymaster</span><br><span class="line">      nodes:</span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27001</span></span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27002</span></span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27003</span></span><br></pre></td></tr></table></figure>

<h4 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h4><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非lamda表达式写法</p>
<p><img src="/../pic/image-20221110114251653.png" alt="image-20221110114251653"></p>
</blockquote>
<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li>
</ul>
<p>至于为什么不配置redis集群的地址，这个不需要我们关系，相当于我们只要知道注册中心的地址就可以了，注册中心会自动帮我们映射到redis上，这种思路就很清晰了</p>
<h2 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h2><h3 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p>海量数据存储问题</p>
</li>
<li><p>高并发写的问题</p>
</li>
</ul>
<p>使用分片集群可以解决上述问题，如图:</p>
<p><img src="/../pic/image-20210725155747294.png" alt="image-20210725155747294"></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点</p>
</li>
<li><p>master之间通过ping监测彼此健康状态</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
</li>
</ul>
<h4 id="集群结构-1"><a href="#集群结构-1" class="headerlink" title="集群结构"></a>集群结构</h4><p>分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下：</p>
<p><img src="/../pic/image-20210702164116027.png" alt="image-20210702164116027"></p>
<p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p>
<table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">PORT</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.150.101</td>
<td align="center">7001</td>
<td align="center">master</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">7002</td>
<td align="center">master</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">7003</td>
<td align="center">master</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">8001</td>
<td align="center">slave</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">8002</td>
<td align="center">slave</td>
</tr>
<tr>
<td align="center">192.168.150.101</td>
<td align="center">8003</td>
<td align="center">slave</td>
</tr>
</tbody></table>
<h4 id="准备实例和配置-1"><a href="#准备实例和配置-1" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h4><p>删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 删除旧的，避免配置干扰</span></span><br><span class="line"><span class="built_in">rm</span> -rf 7001 7002 7003</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003 8001 8002 8003</span><br></pre></td></tr></table></figure>



<p>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护(只需要指明该文件的位置就可以了)</span></span><br><span class="line">cluster-config-file /tmp/6379/nodes.conf</span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># 持久化文件存放目录</span></span><br><span class="line">dir /tmp/6379</span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 让redis后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 注册的实例ip</span></span><br><span class="line">replica-announce-ip 192.168.150.101</span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 数据库数量</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line">logfile /tmp/6379/run.log</span><br></pre></td></tr></table></figure>

<p>将这个文件拷贝到每个目录下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 执行拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 <span class="built_in">cp</span> redis.conf</span><br></pre></td></tr></table></figure>



<p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 一键启动所有服务</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure>

<p>通过ps查看状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p>发现服务都已经正常启动：</p>
<p><img src="/../pic/image-20210702174255799.png" alt="image-20210702174255799"></p>
<p>如果要关闭所有进程，可以执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span></span><br></pre></td></tr></table></figure>

<p>或者（推荐这种方式）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure>





<h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p>
<p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p>
<p>1）Redis 5.0之前</p>
<p>Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install zlib ruby rubygems</span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure>



<p>然后通过命令来管理集群：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/redis-6.2.4/src</span><br><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></table></figure>



<p>2）Redis 5.0以后</p>
<p>我们使用的是Redis 6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li>
<li><code>create</code>：代表是创建集群</li>
<li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li>
</ul>
<p>运行后的样子：</p>
<p><img src="/../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/gday03-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E8%B5%84%E6%96%99/assets/image-20210702181101969.png" alt="image-20210702181101969"></p>
<p>这里输入yes，则集群开始创建：</p>
<p><img src="/../../../%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/gday03-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/%E8%B5%84%E6%96%99/assets/image-20210702181215705.png" alt="image-20210702181215705"></p>
<p>通过命令可以查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20210702181922809.png" alt="image-20210702181922809"></p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>尝试连接7001节点，存储一个数据：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 存储数据</span></span><br><span class="line"><span class="built_in">set</span> num 123</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">get num</span><br><span class="line"><span class="comment"># 再次存储</span></span><br><span class="line"><span class="built_in">set</span> a 1</span><br></pre></td></tr></table></figure>

<p>结果悲剧了：</p>
<p><img src="/../pic/image-20210702182343979.png" alt="image-20210702182343979"></p>
<p>注意：！！！集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p 7001</span><br></pre></td></tr></table></figure>

<p>这次可以了：</p>
<p><img src="/../pic/image-20210702182602145.png" alt="image-20210702182602145"></p>
<h3 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h3><h4 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="/../pic/image-20210725155820320.png" alt="image-20210725155820320"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li>key中**包含”{}”**，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li>
<li>key中<strong>不包含“{}”</strong>，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="/../pic/image-20210725155850200.png" alt="image-20210725155850200"> </p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Redis如何判断某个key应该在哪个实例？</p>
<ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="/../pic/image-20210725160138290.png" alt="image-20210725160138290"></p>
<p>比如，添加节点的命令：</p>
<p><img src="/../pic/image-20210725160448139.png" alt="image-20210725160448139"></p>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽</li>
</ul>
<h4 id="创建新的redis实例"><a href="#创建新的redis实例" class="headerlink" title="创建新的redis实例"></a>创建新的redis实例</h4><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="/../pic/image-20210725160448139.png" alt="image-20210725160448139"></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001</span><br></pre></td></tr></table></figure>



<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="/../pic/image-20210725161007099.png" alt="image-20210725161007099"></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>
<h4 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h4><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="/../pic/image-20210725161241793.png" alt="image-20210725161241793"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="/../pic/image-20210725161401925.png" alt="image-20210725161401925"></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="/../pic/image-20210725161506241.png" alt="image-20210725161506241"></p>
<p>得到下面的反馈：</p>
<p><img src="/../pic/image-20210725161540841.png" alt="image-20210725161540841"></p>
<p>询问要移动多少个插槽，我们计划是3000个：</p>
<p>新的问题来了：</p>
<p><img src="/../pic/image-20210725161637152.png" alt="image-20210725161637152"></p>
<p>那个node来接收这些插槽？？</p>
<p>显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="/../pic/image-20210725161731738.png" alt="image-20210725161731738"></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="/../pic/image-20210725161817642.png" alt="image-20210725161817642"></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="/../pic/image-20210725162030478.png" alt="image-20210725162030478"></p>
<p>填完后，点击done，这样插槽转移就准备好了：</p>
<p><img src="/../pic/image-20210725162101228.png" alt="image-20210725162101228"></p>
<p>确认要转移吗？输入yes：</p>
<p>然后，通过命令查看结果：</p>
<p><img src="/../pic/image-20210725162145497.png" alt="image-20210725162145497"> </p>
<p>可以看到： </p>
<p><img src="/../pic/image-20210725162224058.png" alt="image-20210725162224058"></p>
<p>目的达成。</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>集群初识状态是这样的：</p>
<p><img src="/../pic/image-20210727161152065.png" alt="image-20210727161152065"></p>
<p>其中7001、7002、7003都是master，我们计划让7002宕机。</p>
<h4 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h4><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure>



<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="/../pic/image-20210725162319490.png" alt="image-20210725162319490"></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="/../pic/image-20210725162408979.png" alt="image-20210725162408979"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="/../pic/image-20210727160803386.png" alt="image-20210727160803386"></p>
<h4 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h4><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="/../pic/image-20210725162441407.png" alt="image-20210725162441407"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="/../pic/image-20210727160037766.png" alt="image-20210727160037766"></p>
<p>效果：</p>
<p><img src="/../pic/image-20210727161152065.png" alt="image-20210727161152065"></p>
<h3 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<blockquote>
<p>之前已经配置过1，3步骤了，这里就不写了</p>
</blockquote>
<p>与哨兵模式相比，其中<strong>只有分片集群的配置方式</strong>略有差异，如下：</p>
<p>配置的是每一个节点的地址，注意是每一个都要写上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221111090905997.png" alt="image-20221111090905997"></p>
<h1 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h1><h2 id="什么是多级缓存"><a href="#什么是多级缓存" class="headerlink" title="什么是多级缓存"></a>什么是多级缓存</h2><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>
<p><img src="/../pic/image-20210821075259137-166815097751044.png" alt="image-20210821075259137"></p>
<p>存在下面的问题：</p>
<p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>
<p>•Redis缓存失效时，会对数据库产生冲击</p>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>
<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存</li>
<li>访问非静态资源（ajax查询数据）时，访问服务端</li>
<li>请求到达Nginx后，优先读取Nginx本地缓存</li>
<li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li>
<li>如果Redis查询未命中，则查询Tomcat</li>
<li>请求进入Tomcat后，优先查询JVM进程缓存</li>
<li>如果JVM进程缓存未命中，则查询数据库</li>
</ul>
<p><img src="/../pic/image-20210821075558137-166815097751145.png" alt="image-20210821075558137"></p>
<p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p>
<p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的Nginx服务来做反向代理，如图：</p>
<p><img src="/../pic/image-20210821080511581-166815097751148.png" alt="image-20210821080511581"></p>
<p>另外，我们的Tomcat服务将来也会部署为集群模式：</p>
<p><img src="/../pic/image-20210821080954947-166815097751146.png" alt="image-20210821080954947"></p>
<p>可见，多级缓存的关键有两个：</p>
<ul>
<li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p>
</li>
<li><p>另一个就是在Tomcat中实现JVM进程缓存</p>
</li>
</ul>
<p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>
<p>这也是今天课程的难点和重点。</p>
<h2 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h2><p>为了演示多级缓存的案例，我们先准备一个商品查询的业务。</p>
<h3 id="导入案例"><a href="#导入案例" class="headerlink" title="导入案例"></a>导入案例</h3><p>参考课前资料的：《案例导入说明.md》</p>
<p><img src="/../pic/image-20210821081418456-166815097751147.png" alt="image-20210821081418456"> </p>
<blockquote>
<h1 id="案例导入说明"><a href="#案例导入说明" class="headerlink" title="案例导入说明"></a>案例导入说明</h1><p>为了演示多级缓存，我们先导入一个商品管理的案例，其中包含商品的CRUD功能。我们将来会给查询商品添加多级缓存。</p>
<h1 id="1-安装MySQL"><a href="#1-安装MySQL" class="headerlink" title="1.安装MySQL"></a>1.安装MySQL</h1><p>后期做数据同步需要用到MySQL的主从功能，所以需要大家在虚拟机中，利用Docker来运行一个MySQL容器。</p>
<h2 id="1-1-准备目录"><a href="#1-1-准备目录" class="headerlink" title="1.1.准备目录"></a>1.1.准备目录</h2><p>为了方便后期配置MySQL，我们先准备两个目录，用于挂载容器的数据和配置文件目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment"># 进入/tmp目录</span></span><br><span class="line">&gt;<span class="built_in">cd</span> /tmp</span><br><span class="line">&gt;<span class="comment"># 创建文件夹</span></span><br><span class="line">&gt;<span class="built_in">mkdir</span> mysql</span><br><span class="line">&gt;<span class="comment"># 进入mysql目录</span></span><br><span class="line">&gt;<span class="built_in">cd</span> mysql</span><br></pre></td></tr></table></figure>



<h2 id="1-2-运行命令"><a href="#1-2-运行命令" class="headerlink" title="1.2.运行命令"></a>1.2.运行命令</h2><p>进入mysql目录后，执行下面的Docker命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--name mysql \</span><br><span class="line">-v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d \</span><br><span class="line">-v <span class="variable">$PWD</span>/logs:/logs \</span><br><span class="line">-v <span class="variable">$PWD</span>/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">--privileged \</span><br><span class="line">-d \</span><br><span class="line">mysql:5.7.25</span><br></pre></td></tr></table></figure>



<h2 id="1-3-修改配置"><a href="#1-3-修改配置" class="headerlink" title="1.3.修改配置"></a>1.3.修改配置</h2><p>在&#x2F;tmp&#x2F;mysql&#x2F;conf目录添加一个my.cnf文件，作为mysql的配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment"># 创建文件</span></span><br><span class="line">&gt;<span class="built_in">touch</span> /tmp/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure>



<p>文件的内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">&gt;<span class="section">[mysqld]</span></span><br><span class="line">&gt;skip-name-resolve</span><br><span class="line">&gt;<span class="attr">character_set_server</span>=utf8</span><br><span class="line">&gt;<span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line">&gt;<span class="attr">server-id</span>=<span class="number">1000</span></span><br></pre></td></tr></table></figure>



<h2 id="1-4-重启"><a href="#1-4-重启" class="headerlink" title="1.4.重启"></a>1.4.重启</h2><p>配置修改后，必须重启容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker restart mysql</span><br></pre></td></tr></table></figure>



<h1 id="2-导入SQL"><a href="#2-导入SQL" class="headerlink" title="2.导入SQL"></a>2.导入SQL</h1><p>接下来，利用Navicat客户端连接MySQL，然后导入课前资料提供的sql文件：</p>
<p><img src="/../pic/image-20210809180936732.png" alt="image-20210809180936732"> </p>
<p>其中包含两张表：</p>
<ul>
<li>tb_item：商品表，包含商品的基本信息</li>
<li>tb_item_stock：商品库存表，包含商品的库存信息</li>
</ul>
<p>之所以将库存分离出来，是因为库存是更新比较频繁的信息，写操作较多。而其他信息修改的频率非常低。</p>
<h1 id="3-导入Demo工程"><a href="#3-导入Demo工程" class="headerlink" title="3.导入Demo工程"></a>3.导入Demo工程</h1><p>下面导入课前资料提供的工程：</p>
<p><img src="/../pic/image-20210809181147502.png" alt="image-20210809181147502"> </p>
<p>项目结构如图所示：</p>
<p><img src="/../pic/image-20210809181346450.png" alt="image-20210809181346450"></p>
<p>其中的业务包括：</p>
<ul>
<li>分页查询商品</li>
<li>新增商品</li>
<li>修改商品</li>
<li>修改库存</li>
<li>删除商品</li>
<li>根据id查询商品</li>
<li>根据id查询库存</li>
</ul>
<p>业务全部使用mybatis-plus来实现，如有需要请自行修改业务逻辑。</p>
<h2 id="3-1-分页查询商品"><a href="#3-1-分页查询商品" class="headerlink" title="3.1.分页查询商品"></a>3.1.分页查询商品</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181554563.png" alt="image-20210809181554563"></p>
<h2 id="3-2-新增商品"><a href="#3-2-新增商品" class="headerlink" title="3.2.新增商品"></a>3.2.新增商品</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181646907.png" alt="image-20210809181646907"></p>
<h2 id="3-3-修改商品"><a href="#3-3-修改商品" class="headerlink" title="3.3.修改商品"></a>3.3.修改商品</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181714607.png" alt="image-20210809181714607"></p>
<h2 id="3-4-修改库存"><a href="#3-4-修改库存" class="headerlink" title="3.4.修改库存"></a>3.4.修改库存</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181744011.png" alt="image-20210809181744011"></p>
<h2 id="3-5-删除商品"><a href="#3-5-删除商品" class="headerlink" title="3.5.删除商品"></a>3.5.删除商品</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181821696.png" alt="image-20210809181821696"></p>
<p>这里是采用了逻辑删除，将商品状态修改为3</p>
<h2 id="3-6-根据id查询商品"><a href="#3-6-根据id查询商品" class="headerlink" title="3.6.根据id查询商品"></a>3.6.根据id查询商品</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181901823.png" alt="image-20210809181901823"></p>
<p>这里只返回了商品信息，不包含库存</p>
<h2 id="3-7-根据id查询库存"><a href="#3-7-根据id查询库存" class="headerlink" title="3.7.根据id查询库存"></a>3.7.根据id查询库存</h2><p>在<code>com.heima.item.web</code>包的<code>ItemController</code>中可以看到接口定义：</p>
<p><img src="/../pic/image-20210809181932805.png" alt="image-20210809181932805"></p>
<h2 id="3-8-启动"><a href="#3-8-启动" class="headerlink" title="3.8.启动"></a>3.8.启动</h2><p>注意修改application.yml文件中配置的mysql地址信息：</p>
<p><img src="/../pic/image-20210809182350132.png" alt="image-20210809182350132"></p>
<p>需要修改为自己的虚拟机地址信息、还有账号和密码。</p>
<p>修改后，启动服务，访问：<a target="_blank" rel="noopener" href="http://localhost:8081/item/10001%E5%8D%B3%E5%8F%AF%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">http://localhost:8081/item/10001即可查询数据</a></p>
<h1 id="4-导入商品查询页面"><a href="#4-导入商品查询页面" class="headerlink" title="4.导入商品查询页面"></a>4.导入商品查询页面</h1><p>商品查询是购物页面，与商品管理的页面是分离的。</p>
<p>部署方式如图：</p>
<p><img src="/../pic/image-20210816111210961.png" alt="image-20210816111210961"></p>
<p>我们需要准备一个反向代理的nginx服务器，如上图红框所示，将静态的商品页面放到nginx目录中。</p>
<p>页面需要的数据通过ajax向服务端（nginx业务集群）查询。</p>
<h2 id="4-1-运行nginx服务"><a href="#4-1-运行nginx服务" class="headerlink" title="4.1.运行nginx服务"></a>4.1.运行nginx服务</h2><p>这里我已经给大家准备好了nginx反向代理服务器和静态资源。</p>
<p>我们找到课前资料的nginx目录：</p>
<p><img src="/../pic/image-20210816111348353.png" alt="image-20210816111348353"> </p>
<p>将其拷贝到一个非中文目录下，运行这个nginx服务。</p>
<p>运行命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">start</span> nginx.exe</span><br></pre></td></tr></table></figure>



<p>然后访问 <a target="_blank" rel="noopener" href="http://localhost/item.html?id=10001%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://localhost/item.html?id=10001即可：</a></p>
<p><img src="/../pic/image-20210816112323632.png" alt="image-20210816112323632"></p>
<h2 id="4-2-反向代理"><a href="#4-2-反向代理" class="headerlink" title="4.2.反向代理"></a>4.2.反向代理</h2><p>现在，页面是假数据展示的。我们需要向服务器发送ajax请求，查询商品数据。</p>
<p>打开控制台，可以看到页面有发起ajax查询数据：</p>
<p><img src="/../pic/image-20210816113816958.png" alt="image-20210816113816958"></p>
<p>而这个请求地址同样是80端口，所以被当前的nginx反向代理了。</p>
<p>查看nginx的conf目录下的nginx.conf文件：</p>
<p><img src="/../pic/image-20210816113917002.png" alt="image-20210816113917002"> </p>
<p>其中的关键配置如下：</p>
<p><img src="/../pic/image-20210816114416561.png" alt="image-20210816114416561"></p>
<p>其中的192.168.150.101是我的虚拟机IP，也就是我的Nginx业务集群要部署的地方：</p>
<p><img src="/../pic/image-20210816114554645.png" alt="image-20210816114554645"></p>
<p>完整内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">#user  nobody;</span></span><br><span class="line">&gt;<span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">events</span> &#123;</span><br><span class="line">   <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">http</span> &#123;</span><br><span class="line">   <span class="attribute">include</span>       mime.types;</span><br><span class="line">   <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">   <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">   <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">   <span class="section">upstream</span> nginx-cluster&#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.150.101:8081</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">           <span class="attribute">proxy_pass</span> http://nginx-cluster;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="section">location</span> / &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">           <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">       <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="初识Caffeine"><a href="#初识Caffeine" class="headerlink" title="初识Caffeine"></a>初识Caffeine</h3><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<p>我们今天会利用Caffeine框架来实现JVM进程缓存。</p>
<p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>Caffeine的性能非常好，下图是官方给出的性能对比：</p>
<p><img src="/../pic/image-20210821081826399-166815097751149.png" alt="image-20210821081826399"></p>
<p>可以看到Caffeine的性能遥遥领先！</p>
<p>缓存使用的基本API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 第一种方法</span></span><br><span class="line">    <span class="comment">//存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;瑶瑶&quot;</span>);</span><br><span class="line">    <span class="comment">// 取数据         getIfPresent意思是：取 如果存在的话  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 第二种方法</span></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;昊昊&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li><p><strong>基于容量</strong>：设置缓存的数量上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221111154252259.png" alt="image-20221111154252259"></p>
<p><img src="/../pic/image-20221111154335992.png" alt="image-20221111154335992"></p>
</li>
<li><p><strong>基于时间</strong>：设置缓存的有效时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221111154525543.png" alt="image-20221111154525543"></p>
</li>
<li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p>
</blockquote>
<h3 id="实现JVM进程缓存"><a href="#实现JVM进程缓存" class="headerlink" title="实现JVM进程缓存"></a>实现JVM进程缓存</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>利用Caffeine实现下列需求：</p>
<ul>
<li>给根据id查询<strong>商品</strong>的业务添加缓存，缓存未命中时查询数据库</li>
<li>给根据id查询<strong>商品库存</strong>的业务添加缓存，缓存未命中时查询数据库</li>
<li>缓存初始大小为100</li>
<li>缓存上限为10000</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p>
<p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后，修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ItemStock <span class="title function_">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Lua语法入门"><a href="#Lua语法入门" class="headerlink" title="Lua语法入门"></a>Lua语法入门</h2><p><img src="/../pic/image-20221111161035742.png" alt="image-20221111161035742"></p>
<p>Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。</p>
<h3 id="初识Lua"><a href="#初识Lua" class="headerlink" title="初识Lua"></a>初识Lua</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a target="_blank" rel="noopener" href="https://www.lua.org/">https://www.lua.org/</a></p>
<p><img src="/../pic/image-20210821091437975-166815097751150.png" alt="image-20210821091437975"></p>
<p>Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。</p>
<p>Nginx本身也是C语言开发，因此也允许基于Lua做拓展。</p>
<h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。</p>
<p>1）在Linux虚拟机的任意目录下，新建一个hello.lua文件</p>
<p><img src="/../pic/image-20210821091621308-166815097751151.png" alt="image-20210821091621308"></p>
<p>2）添加下面的内容</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  </span><br></pre></td></tr></table></figure>



<p>3）运行</p>
<p><img src="/../pic/image-20210821091638140-166815097751152.png" alt="image-20210821091638140"></p>
<h3 id="变量和循环"><a href="#变量和循环" class="headerlink" title="变量和循环"></a>变量和循环</h3><p>学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。</p>
<h4 id="Lua的数据类型"><a href="#Lua的数据类型" class="headerlink" title="Lua的数据类型"></a>Lua的数据类型</h4><p>Lua中支持的常见数据类型包括：</p>
<p><img src="/../pic/image-20210821091835406-166815097751153.png" alt="image-20210821091835406"></p>
<p>另外，Lua提供了type()函数来判断一个变量的数据类型：</p>
<p><img src="/../pic/image-20210821091904332-166815097751154.png" alt="image-20210821091904332"></p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串，可以用单引号或双引号，</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串拼接可以使用 ..</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&#x27;hello&#x27;</span> .. <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 ，key为角标的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map =  &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>Lua中的table可以用key来访问：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 访问table</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure>



<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。</p>
<p>遍历数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>遍历普通table</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(key, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h3 id="条件控制、函数"><a href="#条件控制、函数" class="headerlink" title="条件控制、函数"></a>条件控制、函数</h3><p>Lua中的条件控制和函数声明与Java类似。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>定义函数的语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">( argument1, argument2..., argumentn)</span></span></span><br><span class="line">    <span class="comment">-- 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>例如，定义一个函数，用来打印数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><p>类似Java的条件控制，例如if、else语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>与java不同，布尔表达式中的逻辑运算是基于英文单词：</p>
<p><img src="/../pic/image-20210821092657918-166815097751155.png" alt="image-20210821092657918"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;数组不能为空！&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h2 id="实现多级缓存"><a href="#实现多级缓存" class="headerlink" title="实现多级缓存"></a>实现多级缓存</h2><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。</p>
<h3 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h3><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p>
<ul>
<li>具备Nginx的完整功能</li>
<li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li>
<li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li>
</ul>
<p>官方网站： <a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a></p>
<p><img src="/../pic/image-20210821092902946-166815097751156.png" alt="image-20210821092902946"></p>
<p>安装Lua可以参考课前资料提供的《安装OpenResty.md》：</p>
<p><img src="/../pic/image-20210821092941139-166815097751157.png" alt="image-20210821092941139"> </p>
<blockquote>
<h1 id="安装OpenResty-1"><a href="#安装OpenResty-1" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h1><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>首先你的Linux虚拟机必须联网</p>
<h2 id="1）安装开发库"><a href="#1）安装开发库" class="headerlink" title="1）安装开发库"></a><strong>1）安装开发库</strong></h2><p>首先要安装OpenResty的依赖开发库，执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;yum install -y pcre-devel openssl-devel gcc --skip-broken</span><br></pre></td></tr></table></figure>



<h2 id="2）安装OpenResty仓库"><a href="#2）安装OpenResty仓库" class="headerlink" title="2）安装OpenResty仓库"></a><strong>2）安装OpenResty仓库</strong></h2><p>你可以在你的 CentOS 系统中添加 <code>openresty</code> 仓库，这样就可以便于未来安装或更新我们的软件包（通过 <code>yum check-update</code> 命令）。运行下面的命令就可以添加我们的仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br></pre></td></tr></table></figure>



<p>如果提示说命令不存在，则运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;yum install -y yum-utils </span><br></pre></td></tr></table></figure>

<p>然后再重复上面的命令</p>
<h2 id="3）安装OpenResty"><a href="#3）安装OpenResty" class="headerlink" title="3）安装OpenResty"></a><strong>3）安装OpenResty</strong></h2><p>然后就可以像下面这样安装软件包，比如 <code>openresty</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;yum install -y openresty</span><br></pre></td></tr></table></figure>



<h2 id="4）安装opm工具"><a href="#4）安装opm工具" class="headerlink" title="4）安装opm工具"></a><strong>4）安装opm工具</strong></h2><p>opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。</p>
<p>如果你想安装命令行工具 <code>opm</code>，那么可以像下面这样安装 <code>openresty-opm</code> 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;yum install -y openresty-opm</span><br></pre></td></tr></table></figure>



<h2 id="5）目录结构"><a href="#5）目录结构" class="headerlink" title="5）目录结构"></a><strong>5）目录结构</strong></h2><p>默认情况下，OpenResty安装的目录是：&#x2F;usr&#x2F;local&#x2F;openresty</p>
<p><img src="/../pic/image-20200310225539214.png" alt="image-20200310225539214"> </p>
<p>看到里面的nginx目录了吗，OpenResty就是在Nginx基础上集成了一些Lua模块。</p>
<h2 id="6）配置nginx的环境变量"><a href="#6）配置nginx的环境变量" class="headerlink" title="6）配置nginx的环境变量"></a><strong>6）配置nginx的环境变量</strong></h2><p>打开配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>在最下面加入两行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">export</span> NGINX_HOME=/usr/local/openresty/nginx</span><br><span class="line">&gt;<span class="built_in">export</span> PATH=<span class="variable">$&#123;NGINX_HOME&#125;</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>NGINX_HOME：后面是OpenResty安装目录下的nginx的目录</p>
<p>然后让配置生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;source /etc/profile</span><br></pre></td></tr></table></figure>



<h1 id="2-启动和运行"><a href="#2-启动和运行" class="headerlink" title="2.启动和运行"></a>2.启动和运行</h1><p>OpenResty底层是基于Nginx的，查看OpenResty目录的nginx目录，结构与windows中安装的nginx基本一致：</p>
<p><img src="/../pic/image-20210811100653291.png" alt="image-20210811100653291"></p>
<p>所以运行方式与nginx基本一致：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment"># 启动nginx</span></span><br><span class="line">&gt;nginx</span><br><span class="line">&gt;<span class="comment"># 重新加载配置</span></span><br><span class="line">&gt;nginx -s reload</span><br><span class="line">&gt;<span class="comment"># 停止</span></span><br><span class="line">&gt;nginx -s stop</span><br></pre></td></tr></table></figure>





<p>nginx的默认配置文件注释太多，影响后续我们的编辑，这里将nginx.conf中的注释部分删除，保留有效部分。</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">#user  nobody;</span></span><br><span class="line">&gt;<span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line">&gt;<span class="attribute">error_log</span>  logs/<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">events</span> &#123;</span><br><span class="line">       <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">http</span> &#123;</span><br><span class="line">       <span class="attribute">include</span>       mime.types;</span><br><span class="line">       <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">       <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">       <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">       <span class="section">server</span> &#123;</span><br><span class="line">            <span class="attribute">listen</span>       <span class="number">8081</span>;</span><br><span class="line">            <span class="attribute">server_name</span>  localhost;</span><br><span class="line">            <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">root</span>   html;</span><br><span class="line">                <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">            <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">                <span class="attribute">root</span>   html;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>



<p>在Linux的控制台输入命令以启动nginx：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;nginx</span><br></pre></td></tr></table></figure>



<p>然后访问页面：<a href="http://192.168.30.128:8081，注意ip地址替换为你自己的虚拟机IP：">http://192.168.30.128:8081，注意ip地址替换为你自己的虚拟机IP：</a></p>
<p><img src="/../pic/image-20221111171936762.png" alt="image-20221111171936762"></p>
<h1 id="3-备注"><a href="#3-备注" class="headerlink" title="3.备注"></a>3.备注</h1><p>加载OpenResty的lua模块：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">#lua 模块</span></span><br><span class="line">&gt;<span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line">&gt;<span class="comment">#c模块     </span></span><br><span class="line">&gt;<span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p>common.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line">&gt;<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">   <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">           method = ngx.HTTP_GET,</span><br><span class="line">               args = params,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">           <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">           ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http not found, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">            ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> resp.body</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="comment">-- 将方法导出</span></span><br><span class="line">&gt;<span class="keyword">local</span> _M = &#123;  </span><br><span class="line">   read_http = read_http</span><br><span class="line">&gt;&#125;  </span><br><span class="line">   <span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>释放Redis连接API：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line">&gt;<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">   <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">   <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">       <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">           ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>读取Redis数据的API：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line">&gt;<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">   <span class="comment">-- 获取一个连接</span></span><br><span class="line">   <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">           ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">       <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">       <span class="comment">-- 查询失败处理</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">           ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">        <span class="comment">--得到的数据为空处理</span></span><br><span class="line">       <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">           resp = <span class="literal">nil</span></span><br><span class="line">           ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        close_redis(red)</span><br><span class="line">       <span class="keyword">return</span> resp</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>开启共享词典：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line">&gt;<span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="OpenResty快速入门"><a href="#OpenResty快速入门" class="headerlink" title="OpenResty快速入门"></a>OpenResty快速入门</h3><p>我们希望达到的多级缓存架构如图：</p>
<p><img src="/../pic/yeVDlwtfMx-166815097751158.png" alt="yeVDlwtfMx"></p>
<p>其中：</p>
<ul>
<li><p>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</p>
</li>
<li><p>OpenResty集群用来编写多级缓存业务</p>
</li>
</ul>
<h4 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h4><p>现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。</p>
<p>这个请求如下：</p>
<p><img src="/../pic/image-20210821093144700-166815097751159.png" alt="image-20210821093144700"></p>
<p>请求地址是localhost，端口是80，就被windows上安装的Nginx服务给接收到了。然后代理给了OpenResty集群：</p>
<p><img src="/../pic/image-20210821094447709-166815097751160.png" alt="image-20210821094447709"></p>
<p>我们需要在OpenResty中编写业务，查询商品数据并返回到浏览器。</p>
<p>但是这次，我们先在OpenResty接收请求，返回假的商品数据。</p>
<h4 id="OpenResty监听请求"><a href="#OpenResty监听请求" class="headerlink" title="OpenResty监听请求"></a>OpenResty监听请求</h4><p>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p>
<p>1）添加对OpenResty的Lua模块的加载</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221111173004139.png" alt="image-20221111173004139"></p>
<p>2）监听&#x2F;api&#x2F;item路径</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对&#x2F;api&#x2F;item这个路径的监听：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span>  /api/item &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221111173509993.png" alt="image-20221111173509993"></p>
<p><img src="/../pic/image-20221111173640580.png" alt="image-20221111173640580"></p>
<p>这个监听，就类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>做路径映射。</p>
<p>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p>
<h4 id="编写item-lua"><a href="#编写item-lua" class="headerlink" title="编写item.lua"></a>编写item.lua</h4><p>1）在<code>/usr/loca/openresty/nginx</code>目录创建文件夹：lua</p>
<p><img src="/../pic/image-20210821100755080-166815097751161.png" alt="image-20210821100755080"></p>
<p>2）在<code>/usr/loca/openresty/nginx/lua</code>文件夹下，新建文件：item.lua</p>
<p><img src="/../pic/image-20210821100801756-166815097751162.png" alt="image-20210821100801756"></p>
<p>3）编写item.lua，返回假数据</p>
<p>item.lua中，利用ngx.say()函数返回数据到Response中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 26寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:19900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>4）重新加载配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个不但虚拟机的要刷新，自己的windows那个负载均衡的nginx也要刷新一下</p>
<p>如果再没有刷新就清理一下浏览器的缓存</p>
</blockquote>
<p>刷新商品页面：<a target="_blank" rel="noopener" href="http://localhost/item.html?id=10001%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost/item.html?id=10001，即可看到效果：</a></p>
<p><img src="/../pic/image-20210821101217089-166815097751163.png" alt="image-20210821101217089"></p>
<h3 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h3><p>上一节中，我们在OpenResty接收前端请求，但是返回的是假数据。</p>
<p>要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。</p>
<p>那么如何获取前端传递的商品参数呢？</p>
<h4 id="获取参数的API"><a href="#获取参数的API" class="headerlink" title="获取参数的API"></a>获取参数的API</h4><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p>
<p><img src="/../pic/image-20210821101433528-166815097751164.png" alt="image-20210821101433528"></p>
<h4 id="获取参数并返回"><a href="#获取参数并返回" class="headerlink" title="获取参数并返回"></a>获取参数并返回</h4><p>在前端发起的ajax请求如图：</p>
<p><img src="/../pic/image-20210821101721649-166815097751165.png" alt="image-20210821101721649"></p>
<p>可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID</p>
<p>1）获取商品id</p>
<p>修改<code>/usr/loca/openresty/nginx/nginx.conf</code>文件中监听&#x2F;api&#x2F;item的代码，利用正则表达式获取ID：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /api/item/(\d+)</span> &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）拼接ID并返回</p>
<p>修改<code>/usr/loca/openresty/nginx/lua/item.lua</code>文件，获取id并拼接到结果中返回：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 拼接并返回</span></span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:&#x27;</span> .. id .. <span class="string">&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>3）重新加载并测试</p>
<p>运行命令以重新加载OpenResty配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新页面可以看到结果中已经带上了ID：</p>
<p><img src="/../pic/image-20210821102235467-166815097751166.png" alt="image-20210821102235467"> </p>
<h3 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a>查询Tomcat</h3><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：</p>
<p><img src="/../pic/image-20210821102610167-166815097751167.png" alt="image-20210821102610167"></p>
<p>需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。</p>
<p><img src="/../pic/image-20210821102959829-166815097751168.png" alt="image-20210821102959829"></p>
<p><img src="/../pic/image-20221114095255866.png" alt="image-20221114095255866"></p>
<h4 id="发送http请求的API"><a href="#发送http请求的API" class="headerlink" title="发送http请求的API"></a>发送http请求的API</h4><p>nginx提供了内部API用以发送http请求：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> resp = ngx.location.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">    method = ngx.HTTP_GET,   <span class="comment">-- 请求方式</span></span><br><span class="line">    args = &#123;a=<span class="number">1</span>,b=<span class="number">2</span>&#125;,  <span class="comment">-- get方式传参数（这两个选一种就可以了）</span></span><br><span class="line">    body=<span class="string">&quot;c=3&amp;d=4&quot;</span>     <span class="comment">--post方式传参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的响应内容包括：</p>
<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，是一个table</li>
<li>resp.body：响应体，就是响应数据</li>
</ul>
<p><strong>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。</strong></p>
<p>但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /path &#123;</span><br><span class="line">    <span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.30.128:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原理如图：</p>
<p><img src="/../pic/image-20210821104149061-166815097751169.png" alt="image-20210821104149061"></p>
<h4 id="封装http工具"><a href="#封装http工具" class="headerlink" title="封装http工具"></a>封装http工具</h4><p>下面，我们封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat。</p>
<p>1）添加反向代理，到windows的Java服务</p>
<p>因为item-service中的接口都是&#x2F;item开头，所以我们监听&#x2F;item路径，代理到windows上的tomcat服务。</p>
<p>修改 <code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，添加一个location：</p>
<p><strong>注意这里是代理到windows我们写的Java代码上的</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.30.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以后，只要我们调用<code>ngx.location.capture(&quot;/item&quot;)</code>，就一定能发送请求到windows的tomcat服务。</p>
<p>2）封装工具类</p>
<p>之前我们说过，OpenResty启动时会加载以下两个目录中的工具文件：</p>
<p><img src="/../pic/image-20210821104857413-166815097751170.png" alt="image-20210821104857413"></p>
<p>所以，自定义的http工具也需要放到这个目录下。</p>
<p>在<code>/usr/local/openresty/lualib</code>目录下，新建一个common.lua文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br></pre></td></tr></table></figure>

<p>内容如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">            method = ngx.HTTP_GET,</span><br><span class="line">            args = params,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。</p>
<p>使用的时候，可以利用<code>require(&#39;common&#39;)</code>来导入该函数库，这里的common是函数库的文件名。</p>
<p>3）实现商品查询</p>
<p>最后，我们修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="comment">-- 从 common中获取read_http这个函数</span></span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>) </span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<p>这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json：</p>
<p><img src="/../pic/image-20210821110441222-166815097751171.png" alt="image-20210821110441222"></p>
<p>这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。</p>
<h4 id="CJSON工具类"><a href="#CJSON工具类" class="headerlink" title="CJSON工具类"></a>CJSON工具类</h4><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。</p>
<p>官方地址： <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-cjson/">https://github.com/openresty/lua-cjson/</a></p>
<p>1）引入cjson模块：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure>



<p>2）序列化：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">    name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 把 table 序列化为 json</span></span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure>



<p>3）反序列化：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化 json为 table</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure>





<h4 id="实现Tomcat查询"><a href="#实现Tomcat查询" class="headerlink" title="实现Tomcat查询"></a>实现Tomcat查询</h4><p>下面，我们修改之前的item.lua中的业务，添加json处理功能：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> StockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(StockJSON)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>



<h4 id="基于ID负载均衡"><a href="#基于ID负载均衡" class="headerlink" title="基于ID负载均衡"></a>基于ID负载均衡</h4><p>刚才的代码中，我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式：</p>
<p><img src="/../pic/image-20210821111023255-166815097751172.png" alt="image-20210821111023255"></p>
<p>因此，OpenResty需要对tomcat集群做负载均衡。</p>
<p>而默认的负载均衡规则是轮询模式，当我们查询&#x2F;item&#x2F;10001时：</p>
<ul>
<li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li>
<li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），仍然会去查询数据库</li>
<li>…</li>
</ul>
<p>你看，因为<strong>轮询</strong>的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。</p>
<p>怎么办？</p>
<p>如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。</p>
<p>也就是说，我们需要根据商品id做负载均衡（肯定是要用到hash的咯），而不是轮询。</p>
<h5 id="1）原理"><a href="#1）原理" class="headerlink" title="1）原理"></a>1）原理</h5><p>nginx提供了基于请求路径做负载均衡的算法：</p>
<p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。</p>
<p>例如：</p>
<ul>
<li>我们的请求路径是 &#x2F;item&#x2F;10001</li>
<li>tomcat总数为2台（8081、8082）</li>
<li>对请求路径&#x2F;item&#x2F;1001做hash运算求余的结果为1</li>
<li>则访问第一个tomcat服务，也就是8081</li>
</ul>
<p>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p>
<h5 id="2）实现"><a href="#2）实现" class="headerlink" title="2）实现"></a>2）实现</h5><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p>
<p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.30.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.30.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221114133005833.png" alt="image-20221114133005833"></p>
<p>重新加载OpenResty</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>





<h5 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h5><p>启动两台tomcat服务：</p>
<p><img src="/../pic/image-20210821112420464-166815097751173.png" alt="image-20210821112420464"></p>
<p>同时启动：</p>
<p><img src="/../pic/image-20210821112444482-166815097751174.png" alt="image-20210821112444482"> </p>
<p>清空日志后，再次访问页面，可以看到不同id的商品，访问到了不同的tomcat服务：</p>
<p><img src="/../pic/image-20210821112559965-166815097751175.png" alt="image-20210821112559965"></p>
<p><img src="/../pic/image-20210821112637430-166815097751176.png" alt="image-20210821112637430"></p>
<h3 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h3><p>Redis缓存会面临冷启动问题：</p>
<p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p>
<p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p>
<p>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</p>
<p>1）利用Docker安装Redis</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>2）在item-service服务中引入Redis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）配置Redis地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.30</span><span class="number">.128</span></span><br></pre></td></tr></table></figure>



<p>4）编写初始化类</p>
<p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p>
<p>这里我们利用InitializingBean接口来实现，因为<strong>InitializingBean可以在对象被Spring创建</strong>并且成员变量全部注入后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring自带的json处理工具</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在服务器启动的时候会自动加载这个方法，这个方法里面完成了对redis初始化数据的操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis（注意这个key）</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis（注意这个key）</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="查询Redis缓存"><a href="#查询Redis缓存" class="headerlink" title="查询Redis缓存"></a>查询Redis缓存</h3><p>现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：</p>
<p><img src="/../pic/image-20210821113340111-166815097751177.png" alt="image-20210821113340111"></p>
<p>当请求进入OpenResty之后：</p>
<ul>
<li>优先查询Redis缓存</li>
<li>如果Redis缓存未命中，再查询Tomcat</li>
</ul>
<h4 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a>封装Redis工具</h4><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。</p>
<p>修改<code>/usr/local/openresty/lualib/common.lua</code>文件：</p>
<p>1）引入Redis模块，并初始化Redis对象</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>2）封装函数，用来释放Redis连接，其实是放入连接池</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>3）封装函数，根据key查询Redis数据</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>4）导出</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>完整的common.lua：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>





<h4 id="实现Redis查询"><a href="#实现Redis查询" class="headerlink" title="实现Redis查询"></a>实现Redis查询</h4><p>接下来，我们就可以去修改item.lua文件，实现对Redis的查询了。</p>
<p>查询逻辑是：</p>
<ul>
<li>根据id查询Redis</li>
<li>如果查询失败则继续查询Tomcat</li>
<li>将查询结果返回</li>
</ul>
<p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，添加一个查询函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>2）而后修改商品查询、库存查询的业务：</p>
<p><img src="/../pic/image-20221114143630182.png" alt="image-20221114143630182"></p>
<p>3）完整的item.lua代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h3 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a>Nginx本地缓存</h3><p>现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：</p>
<p><img src="/../pic/image-20210821114742950-166815097751179.png" alt="image-20210821114742950"></p>
<h4 id="本地缓存API"><a href="#本地缓存API" class="headerlink" title="本地缓存API"></a>本地缓存API</h4><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p>
<p>1）开启共享字典，在nginx.conf的http下添加配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure>



<p>2）在item.lua中操作共享字典：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h4><p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p>2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数，注意这里又加了一个参数：</p>
<p><img src="/../pic/image-20210821115108528-166815097751180.png" alt="image-20210821115108528"></p>
<p>其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。</p>
<p>这里给商品基本信息设置超时时间为30分钟，库存为1分钟。</p>
<p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p>
<p>3）完整的item.lua文件：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h2 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步</h2><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p>
<p>所以我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。</p>
<h3 id="数据同步策略"><a href="#数据同步策略" class="headerlink" title="数据同步策略"></a>数据同步策略</h3><p>缓存数据同步的常见方式有三种：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
<p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步</li>
</ul>
<p>而异步实现又可以基于MQ或者Canal来实现：</p>
<p>1）基于MQ的异步通知：</p>
<p><img src="/../pic/image-20210821115552327-166815097751181.png" alt="image-20210821115552327"></p>
<p>解读：</p>
<ul>
<li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li>
<li>缓存服务监听MQ消息，然后完成对缓存的更新</li>
</ul>
<p>依然有少量的代码侵入。</p>
<p>2）基于Canal的通知</p>
<p><img src="/../pic/image-20210821115719363-166815097751182.png" alt="image-20210821115719363"></p>
<p>解读：</p>
<ul>
<li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li>
<li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li>
<li>缓存服务接收到canal通知，更新缓存</li>
</ul>
<p>代码零侵入</p>
<h3 id="安装Canal"><a href="#安装Canal" class="headerlink" title="安装Canal"></a>安装Canal</h3><h4 id="认识Canal"><a href="#认识Canal" class="headerlink" title="认识Canal"></a>认识Canal</h4><p>**Canal [kə’næl]**，译意为水道&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<p><img src="/../pic/image-20210821115914748-166815097751183.png" alt="image-20210821115914748"></p>
<ul>
<li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li>
<li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li>
<li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p>
<p><img src="/../pic/image-20210821115948395-166815097751184.png" alt="image-20210821115948395"></p>
<h4 id="安装Canal-1"><a href="#安装Canal-1" class="headerlink" title="安装Canal"></a>安装Canal</h4><p>安装和配置Canal参考课前资料文档：</p>
<p><img src="/../pic/image-20210821120017324-166815097751185.png" alt="image-20210821120017324"> </p>
<blockquote>
<h1 id="安装和配置Canal"><a href="#安装和配置Canal" class="headerlink" title="安装和配置Canal"></a>安装和配置Canal</h1><p>下面我们就开启mysql的主从同步机制，让Canal来模拟salve</p>
<h1 id="1-开启MySQL主从"><a href="#1-开启MySQL主从" class="headerlink" title="1.开启MySQL主从"></a>1.开启MySQL主从</h1><p>Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能才可以。</p>
<p>这里以之前用Docker运行的mysql为例：</p>
<h2 id="1-1-开启binlog"><a href="#1-1-开启binlog" class="headerlink" title="1.1.开启binlog"></a>1.1.开启binlog</h2><p>打开mysql容器挂载的日志文件，我的在<code>/tmp/mysql/conf</code>目录:</p>
<p><img src="/../pic/image-20210813153241537.png" alt="image-20210813153241537"></p>
<p>修改文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;vi /tmp/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">&gt;<span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line">&gt;<span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20221114153416702.png" alt="image-20221114153416702"></p>
<p><strong>heima是数据库名称</strong></p>
<p>配置解读：</p>
<ul>
<li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址和文件名，叫做mysql-bin</li>
<li><code>binlog-do-db=heima</code>：指定对哪个database记录binary log events，这里记录heima这个库</li>
</ul>
<p>最终效果：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">&gt;<span class="section">[mysqld]</span></span><br><span class="line">&gt;skip-name-resolve</span><br><span class="line">&gt;<span class="attr">character_set_server</span>=utf8</span><br><span class="line">&gt;<span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line">&gt;<span class="attr">server-id</span>=<span class="number">1000</span></span><br><span class="line">&gt;<span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line">&gt;<span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure>



<h2 id="1-2-设置用户权限"><a href="#1-2-设置用户权限" class="headerlink" title="1.2.设置用户权限"></a>1.2.设置用户权限</h2><p>接下来添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对heima这个库的操作权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;create user canal@&#x27;%&#x27; IDENTIFIED by &#x27;canal&#x27;;</span><br><span class="line">&gt;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;canal&#x27;;</span><br><span class="line">&gt;FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>



<p>重启mysql容器即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker restart mysql</span><br></pre></td></tr></table></figure>



<p>测试设置是否成功：在mysql控制台，或者Navicat中，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20200327094735948.png" alt="image-20200327094735948"> </p>
<h1 id="2-安装Canal"><a href="#2-安装Canal" class="headerlink" title="2.安装Canal"></a>2.安装Canal</h1><h2 id="2-1-创建网络"><a href="#2-1-创建网络" class="headerlink" title="2.1.创建网络"></a>2.1.创建网络</h2><p>我们需要创建一个网络，将MySQL、Canal、MQ放到同一个Docker网络中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker network create heima</span><br></pre></td></tr></table></figure>

<p>让mysql加入这个网络：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker network connect heima mysql</span><br></pre></td></tr></table></figure>





<h2 id="2-3-安装Canal"><a href="#2-3-安装Canal" class="headerlink" title="2.3.安装Canal"></a>2.3.安装Canal</h2><p>课前资料中提供了canal的镜像压缩包:</p>
<p><img src="/../pic/image-20210813161804292.png"> </p>
<p>大家可以上传到虚拟机，然后通过命令导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker load -i canal.tar</span><br></pre></td></tr></table></figure>



<p>然后运行命令创建Canal容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run -p 11111:11111 --name canal \</span><br><span class="line">&gt;-e canal.destinations=heima \</span><br><span class="line">&gt;-e canal.instance.master.address=mysql:3306  \</span><br><span class="line">&gt;-e canal.instance.dbUsername=canal  \</span><br><span class="line">&gt;-e canal.instance.dbPassword=canal  \</span><br><span class="line">&gt;-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">&gt;-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span><br><span class="line">&gt;-e canal.instance.gtidon=<span class="literal">false</span>  \</span><br><span class="line">&gt;-e canal.instance.filter.regex=heima\\..* \</span><br><span class="line">&gt;--network heima \</span><br><span class="line">&gt;-d canal/canal-server:v1.1.5</span><br></pre></td></tr></table></figure>



<p>说明:</p>
<ul>
<li><code>-p 11111:11111</code>：这是canal的默认监听端口</li>
<li><code>-e canal.instance.master.address=mysql:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看</li>
<li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名</li>
<li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码</li>
<li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</li>
</ul>
<p>表名称监听支持的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">&gt;多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">&gt;常见例子：</span><br><span class="line">&gt;1.  所有表：.*   or  .*\\..*</span><br><span class="line">&gt;2.  canal schema下所有表： canal\\..*</span><br><span class="line">&gt;3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">&gt;4.  canal schema下的一张表：canal.test1</span><br><span class="line">&gt;5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h3><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p>
<p><img src="/../pic/image-20210821120049024-166815097751186.png" alt="image-20210821120049024"></p>
<p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：<a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p>
<p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p>
<h4 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.30</span><span class="number">.128</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure>



<h4 id="修改Item实体类"><a href="#修改Item实体类" class="headerlink" title="修改Item实体类"></a>修改Item实体类</h4><p><img src="/../pic/image-20221114160729684.png" alt="image-20221114160729684"></p>
<p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h4><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p>
<ul>
<li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li>
<li>EntryHandler的泛型是与表对应的实体类</li>
</ul>
<p><img src="/../pic/image-20221114160714452.png" alt="image-20221114160714452"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>你可能会发现，这里通过Canal实现的实时更新只更新了redis和Tomcat的本地缓存，并没有更新OpenResty也就是Nginx服务器集群里面的缓存，这是因为OpenResty里面的缓存我们设置了超时时间，为了教学方便，我们其实是把所有数据都加入到每级缓存中，但是其实在实际中每级的缓存里面的内容可能是不一样的</p>
<p>知道了这些所以OpenResty存储的数据应该是不重要的，并且应该很久不会变化的，等待过期后再重写去查询，就是这样的思想，tomcat和redis里面可以放任意的数据，但是OpenResty里面存放的数据是有要求的，也就是上面提到的，但是具体这些在不同业务中会有不同的差别，需要根据实际情况来编写。</p>
<p>这一节真的学了好久！</p>
<h1 id="服务异步通信-高级篇"><a href="#服务异步通信-高级篇" class="headerlink" title="服务异步通信-高级篇"></a>服务异步通信-高级篇</h1><p>消息队列在使用过程中，面临着很多实际问题需要思考：</p>
<p><img src="/../pic/image-20210718155003157.png" alt="image-20210718155003157"></p>
<h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>消息从发送，到消费者接收，会经理多个过程：</p>
<p><img src="/../pic/image-20210718155059371.png" alt="image-20210718155059371"></p>
<p>其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p>
<ul>
<li>发送时丢失：<ul>
<li>生产者发送的消息未送达exchange</li>
<li>消息到达exchange后未到达queue</li>
</ul>
</li>
<li>MQ宕机，queue将消息丢失</li>
<li>consumer接收到消息后未消费就宕机</li>
</ul>
<p>针对这些问题，RabbitMQ分别给出了解决方案：</p>
<ul>
<li>生产者确认机制</li>
<li>mq持久化</li>
<li>消费者确认机制</li>
<li>失败重试机制</li>
</ul>
<p>下面我们就通过案例来演示每一个步骤。</p>
<p>首先，导入课前资料提供的demo工程：*</p>
<p><img src="/../pic/image-20210718155328927.png" alt="image-20210718155328927"></p>
<p>项目结构如下：</p>
<p><img src="/../pic/image-20210718155448734.png" alt="image-20210718155448734"></p>
<h3 id="生产者消息确认"><a href="#生产者消息确认" class="headerlink" title="生产者消息确认"></a>生产者消息确认</h3><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给<strong>发送者</strong>，表示消息是否处理成功。</p>
<p>返回结果有两种方式：</p>
<ul>
<li>publisher-confirm，发送者确认<ul>
<li>消息成功投递到交换机，返回ack</li>
<li>消息未投递到交换机，返回nack</li>
</ul>
</li>
<li>publisher-return，发送者回执<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li>
</ul>
</li>
</ul>
<p><img src="/../pic/image-20221114191326753.png" alt="image-20221114191326753"></p>
<p>注意：</p>
<p>确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>首先，修改publisher服务中的application.yml文件，添加下面的内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>publish-confirm-type</code>：开启publisher-confirm，这里支持两种类型：<ul>
<li><code>simple</code>：同步等待confirm结果，直到超时(可能会发生阻塞，所以不推荐使用这个)</li>
<li><code>correlated</code>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li>
</ul>
</li>
<li><code>publish-returns</code>：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</li>
<li><code>template.mandatory</code>：定义消息路由失败时的策略。<ul>
<li>true，则调用ReturnCallback；</li>
<li>false：则直接丢弃消息</li>
</ul>
</li>
</ul>
<h4 id="定义Return回调"><a href="#定义Return回调" class="headerlink" title="定义Return回调"></a>定义Return回调</h4><p>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：</p>
<p><img src="/../pic/image-20221116111721401.png" alt="image-20221116111721401"></p>
<p>修改publisher服务，添加一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="comment">//这个方法的执行是在bean工厂创建之后执行的，所以下面我们给rabbit&#x27;template设置一下配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                     replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="comment">// 如果有业务需要，可以重发消息</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。</p>
<p>在publisher服务的cn.itcast.mq.spring.SpringAmqpTest类中，定义一个单元测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.消息体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">// 3.添加callback</span></span><br><span class="line">        correlationData.getFuture().addCallback(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123;</span><br><span class="line">                <span class="comment">// 3.1.ack，消息成功</span></span><br><span class="line">                log.debug(<span class="string">&quot;消息发送成功, ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2.nack，消息失败</span></span><br><span class="line">                log.error(<span class="string">&quot;消息发送失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(), result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ex -&gt; log.error(<span class="string">&quot;消息发送异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(),ex.getMessage()));</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;amq.topic&quot;</span>, routingKey, message);</span><br><span class="line">        <span class="comment">// 休眠一会儿，等待ack回执</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/../pic/image-20221116113149113.png" alt="image-20221116113149113"></p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>RabbitMQ默认是内存存储</p>
<p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。</p>
<p>要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p>
<ul>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化</li>
</ul>
<p><img src="/../pic/image-20221116113637467.png" alt="image-20221116113637467"></p>
<h4 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h4><p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。</p>
<p>我们可以在<strong>消费者的代码</strong>中在config类里面创建队列和交换机</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的交换机都会带上<code>D</code>的标示：</p>
<p><img src="/../pic/image-20210718164412450.png" alt="image-20210718164412450"></p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的队列都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的队列都会带上<code>D</code>的标示：</p>
<p><img src="/../pic/image-20210718164729543.png" alt="image-20210718164729543"></p>
<h4 id="消息持久化-1"><a href="#消息持久化-1" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p>
<ul>
<li>1：非持久化</li>
<li>2：持久化</li>
</ul>
<p>用java代码指定：</p>
<p><img src="/../pic/image-20210718165100016.png" alt="image-20210718165100016"></p>
<p>默认情况下，</p>
<p>SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p>
<p>在Mq的UI界面发送消息可能会是非持久化的</p>
<h3 id="消费者消息确认"><a href="#消费者消息确认" class="headerlink" title="消费者消息确认"></a>消费者消息确认</h3><p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ<strong>确认消息被消费者消费</strong>（注意是消费，如果没有被消费但是消费者宕机的话，说明还是没消费，这种情况是不可取的）后会立刻删除。</p>
<p>而RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p>
<p>设想这样的场景：</p>
<ul>
<li>1）RabbitMQ投递消息给消费者</li>
<li>2）消费者获取消息后，返回ACK给RabbitMQ</li>
<li>3）RabbitMQ删除消息</li>
<li>4）消费者宕机，消息尚未处理</li>
</ul>
<p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p>
<p>而SpringAMQP则允许配置三种确认模式：</p>
<p>•manual：手动ack，需要在业务代码结束后，调用api发送ack。</p>
<p>•auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
<p>•none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
<p>由此可知：</p>
<ul>
<li>none模式下，消息投递是不可靠的，可能丢失</li>
<li>auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack</li>
<li>manual：自己根据业务情况，判断什么时候该ack</li>
</ul>
<p>一般，我们都是使用默认的auto即可。</p>
<h4 id="演示none模式"><a href="#演示none模式" class="headerlink" title="演示none模式"></a>演示none模式</h4><p>修改consumer服务的application.yml文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure>

<p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到simple.queue的消息：【&#123;&#125;】&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// 模拟异常</span></span><br><span class="line">    System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;消息处理完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试可以发现，当消息处理抛异常时，消息依然被RabbitMQ删除了。</p>
<h4 id="演示auto模式"><a href="#演示auto模式" class="headerlink" title="演示auto模式"></a>演示auto模式</h4><p>再次把确认机制修改为auto:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure>

<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为unack（未确定状态）：</p>
<p><img src="/../pic/image-20210718171705383.png" alt="image-20210718171705383"></p>
<p>抛出异常后，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除：</p>
<p><img src="/../pic/image-20210718171759179.png" alt="image-20210718171759179"></p>
<h3 id="消费失败重试机制"><a href="#消费失败重试机制" class="headerlink" title="消费失败重试机制"></a>消费失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：</p>
<p><img src="/../pic/image-20210718172746378.png" alt="image-20210718172746378"></p>
<p>怎么办呢？</p>
<h4 id="本地重试"><a href="#本地重试" class="headerlink" title="本地重试"></a>本地重试</h4><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p>
<p>修改consumer服务的application.yml文件，添加内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false   （这个配置没使用没啥用）</span></span><br></pre></td></tr></table></figure>



<p>重启consumer服务，重复之前的测试。可以发现：</p>
<ul>
<li>在重试3次后，SpringAMQP会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了</li>
<li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li>
</ul>
<p>结论：</p>
<ul>
<li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li>
<li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li>
</ul>
<h4 id="失败策略"><a href="#失败策略" class="headerlink" title="失败策略"></a>失败策略</h4><p>在之前的测试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。</p>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机（这个就是所谓的死信交换机）</p>
</li>
</ul>
<p>比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p>
<p><img src="/../pic/image-20221116150927191.png" alt="image-20221116150927191">  </p>
<p>1）在consumer服务中定义处理失败消息的交换机和队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>如何确保RabbitMQ消息的可靠性？</p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失</li>
<li>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<h2 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h2><h3 id="初识死信交换机"><a href="#初识死信交换机" class="headerlink" title="初识死信交换机"></a>初识死信交换机</h3><h4 id="什么是死信交换机"><a href="#什么是死信交换机" class="headerlink" title="什么是死信交换机"></a>什么是死信交换机</h4><p>什么是死信？</p>
<p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息满了，无法投递</li>
</ul>
<p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，检查DLX）。</p>
<p>如图，一个消息被消费者拒绝了，变成了死信：</p>
<p><img src="/../pic/image-20210718174328383.png" alt="image-20210718174328383"></p>
<p>因为simple.queue绑定了死信交换机 dl.direct，因此死信会投递给这个交换机：</p>
<p><img src="/../pic/image-20210718174416160.png" alt="image-20210718174416160"></p>
<p>如果这个死信交换机也绑定了一个队列，则消息最终会进入这个存放死信的队列：</p>
<p><img src="/../pic/image-20210718174506856.png" alt="image-20210718174506856"></p>
<p>另外，队列将死信投递给死信交换机时，必须知道两个信息：</p>
<ul>
<li>死信交换机名称</li>
<li>死信交换机与死信队列绑定的RoutingKey</li>
</ul>
<p>这样才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。</p>
<p><img src="/../pic/image-20210821073801398.png" alt="image-20210821073801398"></p>
<h4 id="利用死信交换机接收死信（拓展）"><a href="#利用死信交换机接收死信（拓展）" class="headerlink" title="利用死信交换机接收死信（拓展）"></a>利用死信交换机接收死信（拓展）</h4><p>在失败重试策略中，默认的RejectAndDontRequeueRecoverer会在本地重试次数耗尽后，发送reject给RabbitMQ，消息变成死信，被丢弃。</p>
<p>我们可以给simple.queue添加一个死信交换机，给死信交换机绑定一个队列。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p>
<p><img src="/../pic/image-20210718174506856.png" alt="image-20210718174506856"></p>
<p>我们在consumer服务中，定义一组死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明普通的 simple.queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">dlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>什么样的消息会成为死信？</p>
<ul>
<li>消息被消费者reject或者返回nack</li>
<li>消息超时未消费</li>
<li>队列满了</li>
</ul>
<p>死信交换机的使用场景是什么？</p>
<ul>
<li>如果队列绑定了死信交换机，死信会投递到死信交换机；</li>
<li>可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性。</li>
</ul>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>TTL，也就是Time-To-Live。如果一个队列中的消息<strong>TTL结束</strong>仍未消费，则会变为死信。</p>
<p>一个队列中的消息如果<strong>超时</strong>未消费，则会变为死信，超时分为两种情况：</p>
<ul>
<li>消息所在的队列设置了超时时间</li>
<li>消息本身设置了超时时间</li>
</ul>
<p><img src="/../pic/image-20210718182643311.png" alt="image-20210718182643311"></p>
<h4 id="接收超时死信的死信交换机"><a href="#接收超时死信的死信交换机" class="headerlink" title="接收超时死信的死信交换机"></a>接收超时死信的死信交换机</h4><p>在consumer服务的SpringRabbitListener中，定义一个新的消费者，并且声明 死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dl.ttl.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dl.ttl.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;ttl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="声明一个队列，并且指定TTL"><a href="#声明一个队列，并且指定TTL" class="headerlink" title="声明一个队列，并且指定TTL"></a>声明一个队列，并且指定TTL</h4><p>要给队列设置超时时间，需要在声明队列时配置x-message-ttl属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个队列设定了死信交换机为<code>dl.ttl.direct</code></p>
<p>声明交换机，将ttl与交换机绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">ttlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送消息，但是不要指定TTL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, ttl queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息的日志：</p>
<p><img src="/../pic/image-20210718191657478.png" alt="image-20210718191657478"></p>
<p>查看下接收消息的日志：</p>
<p><img src="/../pic/image-20210718191738706.png" alt="image-20210718191738706"></p>
<p>因为队列的TTL值是10000ms，也就是10秒。可以看到消息发送与接收之间的时差刚好是10秒。</p>
<h4 id="发送消息时，设定TTL"><a href="#发送消息时，设定TTL" class="headerlink" title="发送消息时，设定TTL"></a>发送消息时，设定TTL</h4><p>在发送消息时，也可以指定TTL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">        .withBody(<span class="string">&quot;hello, ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查看发送消息日志：</p>
<p><img src="/../pic/image-20210718191939140.png" alt="image-20210718191939140"></p>
<p>接收消息日志：</p>
<p><img src="/../pic/image-20210718192004662.png" alt="image-20210718192004662"></p>
<p>这次，发送与接收的延迟只有5秒。说明当队列、消息都设置了TTL时，<strong>任意一个到期</strong>就会成为死信。</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>消息超时的两种方式是？</p>
<ul>
<li>给队列设置ttl属性，进入队列后超过ttl时间的消息变为死信</li>
<li>给消息设置ttl属性，队列接收到消息超过ttl时间后变为死信</li>
</ul>
<p>如何实现发送一个消息20秒后消费者才收到消息？</p>
<ul>
<li>给消息的目标队列指定死信交换机</li>
<li>将消费者监听的队列绑定到死信交换机</li>
<li>发送消息时给消息设置超时时间为20秒</li>
</ul>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。</p>
<p>延迟队列的使用场景包括：</p>
<ul>
<li>延迟发送短信</li>
<li>用户下单，如果用户在15 分钟内未支付，则自动取消</li>
<li>预约工作会议，20分钟后自动通知所有参会人员</li>
</ul>
<p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。</p>
<p>这个插件就是DelayExchange插件。参考RabbitMQ的插件列表页面：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p><img src="/../pic/image-20210718192529342.png" alt="image-20210718192529342"></p>
<p>使用方式可以参考官网地址：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<h4 id="安装DelayExchange插件"><a href="#安装DelayExchange插件" class="headerlink" title="安装DelayExchange插件"></a>安装DelayExchange插件</h4><p>参考课前资料：</p>
<p><img src="/../pic/image-20210718193409812.png" alt="image-20210718193409812"></p>
<blockquote>
<h1 id="2-安装DelayExchange插件"><a href="#2-安装DelayExchange插件" class="headerlink" title="2.安装DelayExchange插件"></a>2.安装DelayExchange插件</h1><p>官方的安装指南地址为：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<p>上述文档是基于linux原生安装RabbitMQ，然后安装插件。</p>
<p>因为我们之前是基于Docker安装RabbitMQ，所以下面我们会讲解基于Docker来安装RabbitMQ插件。</p>
<h2 id="2-1-下载插件"><a href="#2-1-下载插件" class="headerlink" title="2.1.下载插件"></a>2.1.下载插件</h2><p>RabbitMQ有一个官方的插件社区，地址为：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p>其中包含各种各样的插件，包括我们要使用的DelayExchange插件：</p>
<p><img src="/../pic/image-20210713104511055.png" alt="image-20210713104511055"></p>
<p>大家可以去对应的GitHub页面下载3.8.9版本的插件，地址为<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9%E8%BF%99%E4%B8%AA%E5%AF%B9%E5%BA%94RabbitMQ%E7%9A%843.8.5%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E3%80%82">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9这个对应RabbitMQ的3.8.5以上版本。</a></p>
<p>课前资料也提供了下载好的插件：</p>
<p><img src="/../pic/image-20210713104808909.png" alt="image-20210713104808909"></p>
<h2 id="2-2-上传插件"><a href="#2-2-上传插件" class="headerlink" title="2.2.上传插件"></a>2.2.上传插件</h2><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。如果不是基于Docker的同学，请参考第一章部分，重新创建Docker容器。</p>
<p>我们之前设定的RabbitMQ的数据卷名称为<code>mq-plugins</code>，所以我们使用下面命令查看数据卷：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure>

<p>可以得到下面结果：</p>
<p><img src="/../pic/image-20210713105135701.png" alt="image-20210713105135701"></p>
<p>接下来，将插件上传到这个目录即可：</p>
<p><img src="/../pic/image-20210713105339785.png" alt="image-20210713105339785"></p>
<h2 id="2-3-安装插件"><a href="#2-3-安装插件" class="headerlink" title="2.3.安装插件"></a>2.3.安装插件</h2><p>最后就是安装了，需要进入MQ容器内部来执行安装。我的容器名为<code>mq</code>，所以执行下面命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it mq bash</span><br></pre></td></tr></table></figure>

<p>执行时，请将其中的 <code>-it</code> 后面的<code>mq</code>替换为你自己的容器名.</p>
<p>进入容器内部后，执行下面命令开启插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/../pic/image-20210713105829435.png" alt="image-20210713105829435"></p>
</blockquote>
<h4 id="DelayExchange原理"><a href="#DelayExchange原理" class="headerlink" title="DelayExchange原理"></a>DelayExchange原理</h4><p>DelayExchange需要将一个交换机声明为delayed类型。当我们发送消息到delayExchange时，流程如下：</p>
<ul>
<li>接收消息</li>
<li>判断消息是否具备x-delay属性</li>
<li>如果有x-delay属性，说明是延迟消息，持久化到硬盘，读取x-delay值，作为延迟时间</li>
<li>返回routing not found结果给消息发送者</li>
<li>x-delay时间到期后，重新投递消息到指定队列</li>
</ul>
<h4 id="使用DelayExchange"><a href="#使用DelayExchange" class="headerlink" title="使用DelayExchange"></a>使用DelayExchange</h4><p>插件的使用也非常简单：声明一个交换机，交换机的类型可以是任意类型，只需要设定delayed属性为true即可，然后声明队列与其绑定即可(之后的工作spring会帮我们处理)。</p>
<h5 id="1）声明DelayExchange交换机"><a href="#1）声明DelayExchange交换机" class="headerlink" title="1）声明DelayExchange交换机"></a>1）声明DelayExchange交换机</h5><p>基于注解方式（推荐）：</p>
<p><img src="/../pic/image-20210718193747649.png" alt="image-20210718193747649"></p>
<p>也可以基于@Bean的方式：</p>
<p><img src="/../pic/image-20210718193831076.png" alt="image-20210718193831076"></p>
<h5 id="2）发送消息"><a href="#2）发送消息" class="headerlink" title="2）发送消息"></a>2）发送消息</h5><p>发送消息时，一定要携带x-delay属性，指定延迟的时间：</p>
<p><img src="/../pic/image-20210718193917009.png" alt="image-20210718193917009"></p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>延迟队列插件的使用步骤包括哪些？</p>
<p>•声明一个交换机，添加delayed属性为true</p>
<p>•发送消息时，添加x-delay头，值为超时时间</p>
<h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h3><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p>
<p><img src="/../pic/image-20210718194040498.png" alt="image-20210718194040498"></p>
<p>解决消息堆积有三种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度。也就是我们之前说的work queue模式</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<p>要提升队列容积，把消息保存在内存中显然是不行的。</p>
<h3 id="惰性队列-1"><a href="#惰性队列-1" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是惰性队列。惰性队列的特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<h4 id="基于命令行设置lazy-queue"><a href="#基于命令行设置lazy-queue" class="headerlink" title="基于命令行设置lazy-queue"></a>基于命令行设置lazy-queue</h4><p>而要设置一个队列为惰性队列，只需要在声明队列时，指定x-queue-mode属性为lazy即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues  </span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues  </code>：策略的作用对象，是所有的队列</li>
</ul>
<h4 id="基于-Bean声明lazy-queue"><a href="#基于-Bean声明lazy-queue" class="headerlink" title="基于@Bean声明lazy-queue"></a>基于@Bean声明lazy-queue</h4><p><img src="/../pic/image-20210718194522223.png" alt="image-20210718194522223"></p>
<h4 id="基于-RabbitListener声明LazyQueue"><a href="#基于-RabbitListener声明LazyQueue" class="headerlink" title="基于@RabbitListener声明LazyQueue"></a>基于@RabbitListener声明LazyQueue</h4><p><img src="/../pic/image-20210718194539054.png" alt="image-20210718194539054"></p>
<h4 id="使用发送者进行测试"><a href="#使用发送者进行测试" class="headerlink" title="使用发送者进行测试"></a>使用发送者进行测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">                .withBody(<span class="string">&quot;延迟队列&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;lazy.queue&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我同时用了普通的队列进行对比测试，这个lazyqueue要比normalqueue快的多（不知道是不是我的心理作用），并且数据不会丢失</p>
<p><img src="/../pic/image-20221116180821988.png" alt="image-20221116180821988"></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>消息堆积问题的解决方案？</p>
<ul>
<li>队列上绑定多个消费者，提高消费速度</li>
<li>使用惰性队列，可以再mq中保存更多消息</li>
</ul>
<p>惰性队列的优点有哪些？</p>
<ul>
<li>基于磁盘存储，消息上限高</li>
<li>没有间歇性的page-out，性能比较稳定</li>
</ul>
<p>惰性队列的缺点有哪些？</p>
<ul>
<li>基于磁盘存储，消息时效性会降低</li>
<li>性能受限于磁盘的IO</li>
</ul>
<h2 id="MQ集群"><a href="#MQ集群" class="headerlink" title="MQ集群"></a>MQ集群</h2><h3 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h3><p>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：</p>
<p>•<strong>普通集群</strong>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</p>
<p>•<strong>镜像集群</strong>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</p>
<p>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：<strong>仲裁队列</strong>来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</p>
<h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><h4 id="集群结构和特征"><a href="#集群结构和特征" class="headerlink" title="集群结构和特征"></a>集群结构和特征</h4><p>普通集群，或者叫标准集群（classic cluster），具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回（意思就是如果你访问的是3，但是你想取到的是1，3就会帮你转发到1）</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<p>结构如图：</p>
<p><img src="/../pic/image-20210718220843323.png" alt="image-20210718220843323"></p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>参考课前资料：《RabbitMQ部署指南.md》</p>
<blockquote>
<h1 id="3-集群部署"><a href="#3-集群部署" class="headerlink" title="3.集群部署"></a>3.集群部署</h1><p>接下来，我们看看如何安装RabbitMQ的集群。</p>
<h2 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p>
<ul>
<li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li>
<li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li>
</ul>
<p>我们先来看普通模式集群，我们的计划部署3节点的mq集群：</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>控制台端口</th>
<th>amqp通信端口</th>
</tr>
</thead>
<tbody><tr>
<td>mq1</td>
<td>8081 —&gt; 15672</td>
<td>8071 —&gt; 5672</td>
</tr>
<tr>
<td>mq2</td>
<td>8082 —&gt; 15672</td>
<td>8072 —&gt; 5672</td>
</tr>
<tr>
<td>mq3</td>
<td>8083 —&gt; 15672</td>
<td>8073  —&gt; 5672</td>
</tr>
</tbody></table>
<p>集群中的节点标示默认都是：<code>rabbit@[hostname]</code>，因此以上三个节点的名称分别为：</p>
<ul>
<li>rabbit@mq1</li>
<li>rabbit@mq2</li>
<li>rabbit@mq3</li>
</ul>
<h2 id="2-2-获取cookie"><a href="#2-2-获取cookie" class="headerlink" title="2.2.获取cookie"></a>2.2.获取cookie</h2><p>RabbitMQ底层依赖于Erlang，而Erlang虚拟机就是一个面向分布式的语言，默认就支持集群模式。集群模式中的每个RabbitMQ 节点使用 cookie 来确定它们是否被允许相互通信。</p>
<p>要使两个节点能够通信，它们必须具有相同的共享秘密，称为<strong>Erlang cookie</strong>。cookie 只是一串最多 255 个字符的字母数字字符。</p>
<p>每个集群节点必须具有<strong>相同的 cookie</strong>。实例之间也需要它来相互通信。</p>
<p>我们先在之前启动的mq容器中获取一个cookie值，作为集群的cookie。执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it mq <span class="built_in">cat</span> /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure>

<p>可以看到cookie值如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;FXZMCVGLBIXZCDEMMVZQ</span><br></pre></td></tr></table></figure>



<p>接下来，停止并删除当前的mq容器，我们重新搭建集群。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">rm</span> -f mq</span><br></pre></td></tr></table></figure>



<p><img src="/../pic/image-20210717212345165.png" alt="image-20210717212345165"></p>
<p>清原来数据卷的挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker volume prune</span><br></pre></td></tr></table></figure>



<h2 id="2-3-准备集群配置"><a href="#2-3-准备集群配置" class="headerlink" title="2.3.准备集群配置"></a>2.3.准备集群配置</h2><p>在&#x2F;tmp目录新建一个配置文件 rabbitmq.conf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> /tmp</span><br><span class="line">&gt;<span class="comment"># 创建文件</span></span><br><span class="line">&gt;<span class="built_in">touch</span> rabbitmq.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">&gt;loopback_users.<span class="attribute">guest</span> = <span class="literal">false</span></span><br><span class="line">&gt;listeners.tcp.default = <span class="number">5672</span></span><br><span class="line">&gt;cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config</span><br><span class="line">&gt;cluster_formation.classic_config.nodes.<span class="number">1</span> = rabbit<span class="variable">@mq1</span></span><br><span class="line">&gt;cluster_formation.classic_config.nodes.<span class="number">2</span> = rabbit<span class="variable">@mq2</span></span><br><span class="line">&gt;cluster_formation.classic_config.nodes.<span class="number">3</span> = rabbit<span class="variable">@mq3</span></span><br></pre></td></tr></table></figure>



<p>再创建一个文件，记录cookie</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> /tmp</span><br><span class="line">&gt;<span class="comment"># 创建cookie文件</span></span><br><span class="line">&gt;<span class="built_in">touch</span> .erlang.cookie</span><br><span class="line">&gt;<span class="comment"># 写入cookie</span></span><br><span class="line">&gt;<span class="built_in">echo</span> <span class="string">&quot;FXZMCVGLBIXZCDEMMVZQ&quot;</span> &gt; .erlang.cookie</span><br><span class="line">&gt;<span class="comment"># 修改cookie文件的权限</span></span><br><span class="line">&gt;<span class="built_in">chmod</span> 600 .erlang.cookie</span><br></pre></td></tr></table></figure>





<p>准备三个目录,mq1、mq2、mq3：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> /tmp</span><br><span class="line">&gt;<span class="comment"># 创建目录</span></span><br><span class="line">&gt;<span class="built_in">mkdir</span> mq1 mq2 mq3</span><br></pre></td></tr></table></figure>



<p>然后拷贝rabbitmq.conf、cookie文件到mq1、mq2、mq3：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment"># 进入/tmp</span></span><br><span class="line">&gt;<span class="built_in">cd</span> /tmp</span><br><span class="line">&gt;<span class="comment"># 拷贝</span></span><br><span class="line">&gt;<span class="built_in">cp</span> rabbitmq.conf mq1</span><br><span class="line">&gt;<span class="built_in">cp</span> rabbitmq.conf mq2</span><br><span class="line">&gt;<span class="built_in">cp</span> rabbitmq.conf mq3</span><br><span class="line">&gt;<span class="built_in">cp</span> .erlang.cookie mq1</span><br><span class="line">&gt;<span class="built_in">cp</span> .erlang.cookie mq2</span><br><span class="line">&gt;<span class="built_in">cp</span> .erlang.cookie mq3</span><br></pre></td></tr></table></figure>





<h2 id="2-4-启动集群"><a href="#2-4-启动集群" class="headerlink" title="2.4.启动集群"></a>2.4.启动集群</h2><p>创建一个网络：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker network create mq-net</span><br></pre></td></tr></table></figure>







<p>运行命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run -d --net mq-net \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">&gt;--name mq1 \</span><br><span class="line">&gt;--hostname mq1 \</span><br><span class="line">&gt;-p 8071:5672 \</span><br><span class="line">&gt;-p 8081:15672 \</span><br><span class="line">&gt;rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run -d --net mq-net \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">&gt;--name mq2 \</span><br><span class="line">&gt;--hostname mq2 \</span><br><span class="line">&gt;-p 8072:5672 \</span><br><span class="line">&gt;-p 8082:15672 \</span><br><span class="line">&gt;rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run -d --net mq-net \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">&gt;--name mq3 \</span><br><span class="line">&gt;--hostname mq3 \</span><br><span class="line">&gt;-p 8073:5672 \</span><br><span class="line">&gt;-p 8083:15672 \</span><br><span class="line">&gt;rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>



<h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5.测试"></a>2.5.测试</h2><p>在mq1这个节点上添加一个队列：</p>
<p><img src="/../pic/image-20210717222833196.png" alt="image-20210717222833196"></p>
<p>如图，在mq2和mq3两个控制台也都能看到：</p>
<p><img src="/../pic/image-20210717223057902.png" alt="image-20210717223057902"></p>
<h3 id="2-5-1-数据共享测试"><a href="#2-5-1-数据共享测试" class="headerlink" title="2.5.1.数据共享测试"></a>2.5.1.数据共享测试</h3><p>点击这个队列，进入管理页面：</p>
<p><img src="/../pic/image-20210717223421750.png" alt="image-20210717223421750"></p>
<p>然后利用控制台发送一条消息到这个队列：</p>
<p><img src="/../pic/image-20210717223320238.png" alt="image-20210717223320238"></p>
<p>结果在mq2、mq3上都能看到这条消息：</p>
<p><img src="/../pic/image-20210717223603628.png" alt="image-20210717223603628"></p>
<h3 id="2-5-2-可用性测试"><a href="#2-5-2-可用性测试" class="headerlink" title="2.5.2.可用性测试"></a>2.5.2.可用性测试</h3><p>我们让其中一台节点mq1宕机：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker stop mq1</span><br></pre></td></tr></table></figure>

<p>然后登录mq2或mq3的控制台，发现simple.queue也不可用了：</p>
<p><img src="/../pic/image-20210717223800203.png" alt="image-20210717223800203"></p>
<p>说明数据并没有拷贝到mq2和mq3。</p>
</blockquote>
<h3 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h3><h4 id="集群结构和特征-1"><a href="#集群结构和特征-1" class="headerlink" title="集群结构和特征"></a>集群结构和特征</h4><p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p>结构如图：</p>
<p><img src="/../pic/image-20210718221039542-16686211555661.png" alt="image-20210718221039542"></p>
<h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><p>参考课前资料：《RabbitMQ部署指南.md》</p>
<blockquote>
<h1 id="4-镜像模式"><a href="#4-镜像模式" class="headerlink" title="4.镜像模式"></a>4.镜像模式</h1><p>在刚刚的案例中，一旦创建队列的主机宕机，队列就会不可用。不具备高可用能力。如果要解决这个问题，必须使用官方提供的镜像集群方案。</p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html</a></p>
<h2 id="4-1-镜像模式的特征"><a href="#4-1-镜像模式的特征" class="headerlink" title="4.1.镜像模式的特征"></a>4.1.镜像模式的特征</h2><p>默认情况下，队列只保存在创建该队列的节点上。而镜像模式下，创建队列的节点被称为该队列的<strong>主节点</strong>，队列还会拷贝到集群中的其它节点，也叫做该队列的<strong>镜像</strong>节点。</p>
<p>但是，不同队列可以在集群中的任意节点上创建，因此不同队列的主节点可以不同。甚至，<strong>一个队列的主节点可能是另一个队列的镜像节点</strong>。</p>
<p>用户发送给队列的一切请求，例如发送消息、消息回执默认都会在主节点完成，如果是从节点接收到请求，也会路由到主节点去完成。<strong>镜像节点仅仅起到备份数据作用</strong>。</p>
<p>当主节点接收到消费者的ACK时，所有镜像都会删除节点中的数据。</p>
<p>总结如下：</p>
<ul>
<li>镜像队列结构是一主多从（从就是镜像）</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</li>
<li>不具备负载均衡功能，因为所有操作都会有主节点完成（但是不同队列，其主节点可以不同，可以利用这个提高吞吐量）</li>
</ul>
<h2 id="4-2-镜像模式的配置"><a href="#4-2-镜像模式的配置" class="headerlink" title="4.2.镜像模式的配置"></a>4.2.镜像模式的配置</h2><p>镜像模式的配置有3种模式：</p>
<table>
<thead>
<tr>
<th align="left">ha-mode</th>
<th align="left">ha-params</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">准确模式exactly</td>
<td align="left">队列的副本量count</td>
<td align="left">集群中队列副本（主服务器和镜像服务器之和）的数量。count如果为1意味着单个副本：即队列主节点。count值为2表示2个副本：1个队列主和1个队列镜像。换句话说：count &#x3D; 镜像数量 + 1。如果群集中的节点数少于count，则该队列将镜像到所有节点。如果有集群总数大于count+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。</td>
</tr>
<tr>
<td align="left">all</td>
<td align="left">(none)</td>
<td align="left">队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I &#x2F; O，磁盘I &#x2F; O和磁盘空间使用情况。推荐使用exactly，设置副本数为（N &#x2F; 2 +1）。</td>
</tr>
<tr>
<td align="left">nodes</td>
<td align="left"><em>node names</em></td>
<td align="left">指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。</td>
</tr>
</tbody></table>
<p>这里我们以rabbitmqctl命令作为案例来讲解配置语法。</p>
<p>语法示例：</p>
<h3 id="4-2-1-exactly模式"><a href="#4-2-1-exactly模式" class="headerlink" title="4.2.1.exactly模式"></a>4.2.1.exactly模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rabbitmqctl set_policy</code>：固定写法</li>
<li><code>ha-two</code>：策略名称，自定义</li>
<li><code>&quot;^two\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#39;</code>: 策略内容</li>
<li><code>&quot;ha-mode&quot;:&quot;exactly&quot;</code>：策略模式，此处是exactly模式，指定副本数量</li>
<li><code>&quot;ha-params&quot;:2</code>：策略参数，这里是2，就是副本数量为2，1主1镜像</li>
<li><code>&quot;ha-sync-mode&quot;:&quot;automatic&quot;</code>：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</li>
</ul>
<h3 id="4-2-2-all模式"><a href="#4-2-2-all模式" class="headerlink" title="4.2.2.all模式"></a>4.2.2.all模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl set_policy ha-all &quot;^all\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ha-all</code>：策略名称，自定义</li>
<li><code>&quot;^all\.&quot;</code>：匹配所有以<code>all.</code>开头的队列名</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#39;</code>：策略内容</li>
<li><code>&quot;ha-mode&quot;:&quot;all&quot;</code>：策略模式，此处是all模式，即所有节点都会称为镜像节点</li>
</ul>
<h3 id="4-2-3-nodes模式"><a href="#4-2-3-nodes模式" class="headerlink" title="4.2.3.nodes模式"></a>4.2.3.nodes模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl set_policy ha-nodes &quot;^nodes\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rabbitmqctl set_policy</code>：固定写法</li>
<li><code>ha-nodes</code>：策略名称，自定义</li>
<li><code>&quot;^nodes\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>nodes.</code>开头的队列名称</li>
<li><code>&#39;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#39;</code>: 策略内容</li>
<li><code>&quot;ha-mode&quot;:&quot;nodes&quot;</code>：策略模式，此处是nodes模式</li>
<li><code>&quot;ha-params&quot;:[&quot;rabbit@mq1&quot;, &quot;rabbit@mq2&quot;]</code>：策略参数，这里指定副本所在节点名称</li>
</ul>
<h2 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3.测试"></a>4.3.测试</h2><p>我们使用exactly模式的镜像，因为集群节点数量为3，因此镜像数量就设置为2.</p>
<p>运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it mq1 rabbitmqctl set_policy ha-two <span class="string">&quot;^two\.&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>下面，我们创建一个新的队列：</p>
<p><img src="/../pic/image-20210717231751411.png" alt="image-20210717231751411"></p>
<p>在任意一个mq控制台查看队列：</p>
<p><img src="/../pic/image-20210717231829505.png" alt="image-20210717231829505"></p>
<h3 id="4-3-1-测试数据共享"><a href="#4-3-1-测试数据共享" class="headerlink" title="4.3.1.测试数据共享"></a>4.3.1.测试数据共享</h3><p>给two.queue发送一条消息：</p>
<p><img src="/../pic/image-20210717231958996.png" alt="image-20210717231958996"></p>
<p>然后在mq1、mq2、mq3的任意控制台查看消息：</p>
<p><img src="/../pic/image-20210717232108584.png" alt="image-20210717232108584"></p>
<h3 id="4-3-2-测试高可用"><a href="#4-3-2-测试高可用" class="headerlink" title="4.3.2.测试高可用"></a>4.3.2.测试高可用</h3><p>现在，我们让two.queue的主节点mq1宕机：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker stop mq1</span><br></pre></td></tr></table></figure>



<p>查看集群状态：</p>
<p><img src="/../pic/image-20210717232257420.png" alt="image-20210717232257420"></p>
<p>查看队列状态：</p>
<p><img src="/../pic/image-20210717232322646.png" alt="image-20210717232322646"></p>
<p>发现依然是健康的！并且其主节点切换到了rabbit@mq2上</p>
</blockquote>
<h3 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><h4 id="集群特征"><a href="#集群特征" class="headerlink" title="集群特征"></a>集群特征</h4><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<h4 id="部署-2"><a href="#部署-2" class="headerlink" title="部署"></a>部署</h4><p>参考课前资料：《RabbitMQ部署指南.md》</p>
<blockquote>
<h1 id="5-仲裁队列"><a href="#5-仲裁队列" class="headerlink" title="5.仲裁队列"></a>5.仲裁队列</h1><p>从RabbitMQ 3.8版本开始，引入了新的仲裁队列，他具备与镜像队里类似的功能，但使用更加方便。</p>
<h2 id="5-1-添加仲裁队列"><a href="#5-1-添加仲裁队列" class="headerlink" title="5.1.添加仲裁队列"></a>5.1.添加仲裁队列</h2><p>在任意控制台添加一个队列，一定要选择队列类型为Quorum类型。</p>
<p><img src="/../pic/image-20210717234329640.png" alt="image-20210717234329640"></p>
<p>在任意控制台查看队列：</p>
<p><img src="/../pic/image-20210717234426209.png" alt="image-20210717234426209"></p>
<p>可以看到，仲裁队列的 + 2字样。代表这个队列有2个镜像节点。</p>
<p>因为仲裁队列默认的镜像数为5。如果你的集群有7个节点，那么镜像数肯定是5；而我们集群只有3个节点，因此镜像数量就是3.</p>
<h2 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2.测试"></a>5.2.测试</h2><p>可以参考对镜像集群的测试，效果是一样的。</p>
<h2 id="5-3-集群扩容"><a href="#5-3-集群扩容" class="headerlink" title="5.3.集群扩容"></a>5.3.集群扩容</h2><h3 id="5-3-1-加入集群"><a href="#5-3-1-加入集群" class="headerlink" title="5.3.1.加入集群"></a>5.3.1.加入集群</h3><p>1）启动一个新的MQ容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker run -d --net mq-net \</span><br><span class="line">&gt;-v <span class="variable">$&#123;PWD&#125;</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line">&gt;-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line">&gt;--name mq4 \</span><br><span class="line">&gt;--hostname mq5 \</span><br><span class="line">&gt;-p 8074:15672 \</span><br><span class="line">&gt;-p 8084:15672 \</span><br><span class="line">&gt;rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<p>2）进入容器控制台：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it mq4 bash</span><br></pre></td></tr></table></figure>

<p>3）停止mq进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>



<p>4）重置RabbitMQ中的数据：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl reset</span><br></pre></td></tr></table></figure>



<p>5）加入mq1：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl join_cluster rabbit@mq1</span><br></pre></td></tr></table></figure>



<p>6）再次启动mq进程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmqctl start_app</span><br></pre></td></tr></table></figure>



<p><img src="/../pic/image-20210718001909492.png" alt="image-20210718001909492"></p>
<h3 id="5-3-2-增加仲裁队列副本"><a href="#5-3-2-增加仲裁队列副本" class="headerlink" title="5.3.2.增加仲裁队列副本"></a>5.3.2.增加仲裁队列副本</h3><p>我们先查看下quorum.queue这个队列目前的副本情况，进入mq1容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;docker <span class="built_in">exec</span> -it mq1 bash</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmq-queues quorum_status <span class="string">&quot;quorum.queue&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/../pic/image-20210718002118357.png" alt="image-20210718002118357"></p>
<p>现在，我们让mq4也加入进来：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmq-queues add_member <span class="string">&quot;quorum.queue&quot;</span> <span class="string">&quot;rabbit@mq4&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/../pic/image-20210718002253226.png" alt="image-20210718002253226"></p>
<p>再次查看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;rabbitmq-queues quorum_status <span class="string">&quot;quorum.queue&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20210718002342603.png" alt="image-20210718002342603"></p>
<p>查看控制台，发现quorum.queue的镜像数量也从原来的 +2 变成了 +3：</p>
<p><img src="/../pic/image-20210718002422365.png" alt="image-20210718002422365"></p>
</blockquote>
<h4 id="Java代码创建仲裁队列"><a href="#Java代码创建仲裁队列" class="headerlink" title="Java代码创建仲裁队列"></a>Java代码创建仲裁队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SpringAMQP连接MQ集群"><a href="#SpringAMQP连接MQ集群" class="headerlink" title="SpringAMQP连接MQ集群"></a>SpringAMQP连接MQ集群</h4><p>注意，这里用address来代替host、port方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    addresses: <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span>:<span class="number">8071</span>, <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span>:<span class="number">8072</span>, <span class="number">192.168</span><span class="number">.150</span><span class="number">.105</span>:<span class="number">8073</span></span><br><span class="line">    username: itcast</span><br><span class="line">    password: <span class="number">123321</span></span><br><span class="line">    virtual-host: /</span><br></pre></td></tr></table></figure>







<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="1-微服务篇"><a href="#1-微服务篇" class="headerlink" title="1.微服务篇"></a>1.微服务篇</h2><h3 id="1-1-SpringCloud常见组件有哪些？"><a href="#1-1-SpringCloud常见组件有哪些？" class="headerlink" title="1.1.SpringCloud常见组件有哪些？"></a>1.1.SpringCloud常见组件有哪些？</h3><p><strong>问题说明</strong>：这个题目主要考察对SpringCloud的组件基本了解</p>
<p><strong>难易程度</strong>：简单</p>
<p><strong>参考话术</strong>：</p>
<p>SpringCloud包含的组件很多，有很多功能是重复的。其中最常用组件包括：</p>
<p>•注册中心组件：Eureka、Nacos等</p>
<p>•负载均衡组件：Ribbon</p>
<p>•远程调用组件：OpenFeign</p>
<p>•网关组件：Zuul、Gateway</p>
<p>•服务保护组件：Hystrix、Sentinel</p>
<p>•服务配置管理组件：SpringCloudConfig、Nacos</p>
<h3 id="1-2-Nacos的服务注册表结构是怎样的？"><a href="#1-2-Nacos的服务注册表结构是怎样的？" class="headerlink" title="1.2.Nacos的服务注册表结构是怎样的？"></a>1.2.Nacos的服务注册表结构是怎样的？</h3><p><strong>问题说明</strong>：考察对Nacos数据分级结构的了解，以及Nacos源码的掌握情况</p>
<p><strong>难易程度</strong>：一般</p>
<p><strong>参考话术</strong>：</p>
<p>Nacos采用了<strong>数据的分级存储模型</strong>，最外层是<strong>Namespace</strong>，用来隔离环境。然后是<strong>Group</strong>，用来对服务分组。接下来就是<strong>服务</strong>（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个<strong>集群</strong>（Cluster），Cluster下是不同的<strong>实例</strong>（Instance）。</p>
<p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p>
<p>如图：</p>
<p><img src="/../pic/image-20210925215305446.png" alt="image-20210925215305446"></p>
<h3 id="1-3-Nacos如何支撑阿里内部数十万服务注册压力？"><a href="#1-3-Nacos如何支撑阿里内部数十万服务注册压力？" class="headerlink" title="1.3.Nacos如何支撑阿里内部数十万服务注册压力？"></a>1.3.Nacos如何支撑阿里内部数十万服务注册压力？</h3><p><strong>问题说明</strong>：考察对Nacos源码的掌握情况</p>
<p><strong>难易程度</strong>：难</p>
<p><strong>参考话术</strong>：</p>
<p>Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。</p>
<h3 id="1-4-Nacos如何避免并发读写冲突问题？"><a href="#1-4-Nacos如何避免并发读写冲突问题？" class="headerlink" title="1.4.Nacos如何避免并发读写冲突问题？"></a>1.4.Nacos如何避免并发读写冲突问题？</h3><p><strong>问题说明</strong>：考察对Nacos源码的掌握情况</p>
<p><strong>难易程度</strong>：难</p>
<p><strong>参考话术</strong>：</p>
<p>Nacos在更新实例列表时，会采用<strong>CopyOnWrite</strong>技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p>
<p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p>
<h3 id="1-5-Nacos与Eureka的区别有哪些？"><a href="#1-5-Nacos与Eureka的区别有哪些？" class="headerlink" title="1.5.Nacos与Eureka的区别有哪些？"></a>1.5.Nacos与Eureka的区别有哪些？</h3><p><strong>问题说明</strong>：考察对Nacos、Eureka的底层实现的掌握情况</p>
<p><strong>难易程度</strong>：难</p>
<p><strong>参考话术</strong>：</p>
<p>Nacos与Eureka有相同点，也有不同之处，可以从以下几点来描述：</p>
<ul>
<li><strong>接口方式</strong>：Nacos与Eureka都对外暴露了Rest风格的API接口，用来实现服务注册、发现等功能</li>
<li><strong>实例类型</strong>：Nacos的实例有永久和临时实例之分；而Eureka只支持临时实例</li>
<li><strong>健康检测</strong>：Nacos对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka只支持心跳模式</li>
<li><strong>服务发现</strong>：Nacos支持定时拉取和订阅推送两种模式；Eureka只支持定时拉取模式</li>
</ul>
<h3 id="1-6-Sentinel的限流与Gateway的限流有什么差别？"><a href="#1-6-Sentinel的限流与Gateway的限流有什么差别？" class="headerlink" title="1.6.Sentinel的限流与Gateway的限流有什么差别？"></a>1.6.Sentinel的限流与Gateway的限流有什么差别？</h3><p><strong>问题说明</strong>：考察对限流算法的掌握情况</p>
<p><strong>难易程度</strong>：难</p>
<p><strong>参考话术</strong>：</p>
<p>限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的令牌桶算法。</p>
<p>而Sentinel内部却比较复杂：</p>
<ul>
<li>默认限流模式是基于滑动时间窗口算法</li>
<li>排队等待的限流模式则基于漏桶算法</li>
<li>而热点参数限流则是基于令牌桶算法</li>
</ul>
<h3 id="1-7-Sentinel的线程隔离与Hystix的线程隔离有什么差别"><a href="#1-7-Sentinel的线程隔离与Hystix的线程隔离有什么差别" class="headerlink" title="1.7.Sentinel的线程隔离与Hystix的线程隔离有什么差别?"></a>1.7.Sentinel的线程隔离与Hystix的线程隔离有什么差别?</h3><p><strong>问题说明</strong>：考察对线程隔离方案的掌握情况</p>
<p><strong>难易程度</strong>：一般</p>
<p><strong>参考话术</strong>：</p>
<p>Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。</p>
<p>Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。</p>
<h2 id="2-MQ篇"><a href="#2-MQ篇" class="headerlink" title="2.MQ篇"></a>2.MQ篇</h2><h3 id="2-1-你们为什么选择了RabbitMQ而不是其它的MQ？"><a href="#2-1-你们为什么选择了RabbitMQ而不是其它的MQ？" class="headerlink" title="2.1.你们为什么选择了RabbitMQ而不是其它的MQ？"></a>2.1.你们为什么选择了RabbitMQ而不是其它的MQ？</h3><p>如图：</p>
<p><img src="/../pic/image-20210925220034702.png" alt="image-20210925220034702"></p>
<p><strong>话术：</strong></p>
<p>kafka是以吞吐量高而闻名，不过其数据稳定性一般，而且无法保证消息有序性。我们公司的日志收集也有使用，业务模块中则使用的RabbitMQ。</p>
<p>阿里巴巴的RocketMQ基于Kafka的原理，弥补了Kafka的缺点，继承了其高吞吐的优势，其客户端目前以Java为主。但是我们担心阿里巴巴开源产品的稳定性，所以就没有使用。</p>
<p>RabbitMQ基于面向并发的语言Erlang开发，吞吐量不如Kafka，但是对我们公司来讲够用了。而且<strong>消息可靠性较好</strong>，并且<strong>消息延迟极低</strong>，<strong>集群搭建比较方便</strong>。<strong>支持多种协议</strong>，并且<strong>有各种语言的客户端</strong>，比较灵活。<strong>Spring对RabbitMQ的支持也比较好</strong>，使用起来比较方便，比较符合我们公司的需求。</p>
<p>综合考虑我们公司的并发需求以及稳定性需求，我们选择了RabbitMQ。</p>
<h3 id="2-2-RabbitMQ如何确保消息的不丢失？"><a href="#2-2-RabbitMQ如何确保消息的不丢失？" class="headerlink" title="2.2.RabbitMQ如何确保消息的不丢失？"></a>2.2.RabbitMQ如何确保消息的不丢失？</h3><p><strong>话术：</strong></p>
<p>RabbitMQ针对消息传递过程中可能发生问题的各个地方，给出了针对性的解决方案：</p>
<ul>
<li>生产者发送消息时可能因为网络问题导致消息没有到达交换机：<ul>
<li>RabbitMQ提供了publisher confirm机制<ul>
<li>生产者发送消息后，可以编写ConfirmCallback函数</li>
<li>消息成功到达交换机后，RabbitMQ会调用ConfirmCallback通知消息的发送者，返回ACK</li>
<li>消息如果未到达交换机，RabbitMQ也会调用ConfirmCallback通知消息的发送者，返回NACK</li>
<li>消息超时未发送成功也会抛出异常</li>
</ul>
</li>
</ul>
</li>
<li>消息到达交换机后，如果未能到达队列，也会导致消息丢失：<ul>
<li>RabbitMQ提供了publisher return机制<ul>
<li>生产者可以定义ReturnCallback函数</li>
<li>消息到达交换机，未到达队列，RabbitMQ会调用ReturnCallback通知发送者，告知失败原因</li>
</ul>
</li>
</ul>
</li>
<li>消息到达队列后，MQ宕机也可能导致丢失消息：<ul>
<li>RabbitMQ提供了持久化功能，集群的主从备份功能<ul>
<li>消息持久化，RabbitMQ会将交换机、队列、消息持久化到磁盘，宕机重启可以恢复消息</li>
<li>镜像集群，仲裁队列，都可以提供主从备份功能，主节点宕机，从节点会自动切换为主，数据依然在</li>
</ul>
</li>
</ul>
</li>
<li>消息投递给消费者后，如果消费者处理不当，也可能导致消息丢失<ul>
<li>SpringAMQP基于RabbitMQ提供了消费者确认机制、消费者重试机制，消费者失败处理策略：<ul>
<li>消费者的确认机制：<ul>
<li>消费者处理消息成功，未出现异常时，Spring返回ACK给RabbitMQ，消息才被移除</li>
<li>消费者处理消息失败，抛出异常，宕机，Spring返回NACK或者不返回结果，消息不被移除</li>
</ul>
</li>
<li>消费者重试机制：<ul>
<li>默认情况下，消费者处理失败时，消息会再次回到MQ队列，然后投递给其它消费者。Spring提供的消费者重试机制，则是在处理失败后不返回NACK，而是直接在消费者本地重试。多次重试都失败后，则按照消费者失败处理策略来处理消息。避免了消息频繁入队带来的额外压力。</li>
</ul>
</li>
<li>消费者失败策略：<ul>
<li>当消费者多次本地重试失败时，消息默认会丢弃。</li>
<li>Spring提供了Republish策略，在多次重试都失败，耗尽重试次数后，将消息重新投递给指定的异常交换机，并且会携带上异常栈信息，帮助定位问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-RabbitMQ如何避免消息堆积？"><a href="#2-3-RabbitMQ如何避免消息堆积？" class="headerlink" title="2.3.RabbitMQ如何避免消息堆积？"></a>2.3.RabbitMQ如何避免消息堆积？</h3><p><strong>话术：</strong></p>
<p>消息堆积问题产生的原因往往是因为消息发送的速度超过了消费者消息处理的速度。因此解决方案无外乎以下三点：</p>
<ul>
<li>提高消费者处理速度</li>
<li>增加更多消费者</li>
<li>增加队列消息存储上限</li>
</ul>
<p>1）提高消费者处理速度</p>
<p>消费者处理速度是由业务代码决定的，所以我们能做的事情包括：</p>
<ul>
<li>尽可能优化业务代码，提高业务性能</li>
<li>接收到消息后，开启线程池，并发处理多个消息</li>
</ul>
<p>优点：成本低，改改代码即可</p>
<p>缺点：开启线程池会带来额外的性能开销，对于高频、低时延的任务不合适。推荐任务执行周期较长的业务。</p>
<p>2）增加更多消费者</p>
<p>一个队列绑定多个消费者，共同争抢任务，自然可以提供消息处理的速度。</p>
<p>优点：能用钱解决的问题都不是问题。实现简单粗暴</p>
<p>缺点：问题是没有钱。成本太高</p>
<p>3）增加队列消息存储上限</p>
<p>在RabbitMQ的1.8版本后，加入了新的队列模式：Lazy Queue</p>
<p>这种队列不会将消息保存在内存中，而是在收到消息后直接写入磁盘中，理论上没有存储上限。可以解决消息堆积问题。</p>
<p>优点：磁盘存储更安全；存储无上限；避免内存存储带来的Page Out问题，性能更稳定；</p>
<p>缺点：磁盘存储受到IO性能的限制，消息时效性不如内存模式，但影响不大。</p>
<h3 id="2-4-RabbitMQ如何保证消息的有序性？"><a href="#2-4-RabbitMQ如何保证消息的有序性？" class="headerlink" title="2.4.RabbitMQ如何保证消息的有序性？"></a>2.4.RabbitMQ如何保证消息的有序性？</h3><p>多个有序的消息可能是一个大消息的拆分吧</p>
<p><strong>话术：</strong></p>
<p>其实RabbitMQ是<strong>队列</strong>存储，天然具备先进先出的特点，只要消息的发送是有序的，那么理论上接收也是有序的。不过当一个队列绑定了多个消费者时，可能出现消息轮询投递给消费者的情况，而消费者的处理顺序就无法保证了。</p>
<p>因此，要保证消息的有序性，需要做的下面几点：</p>
<ul>
<li>保证消息发送的有序性</li>
<li>保证一组有序的消息都发送到同一个队列</li>
<li>保证一个队列只包含一个消费者</li>
</ul>
<h3 id="2-5-如何防止MQ消息被重复消费？"><a href="#2-5-如何防止MQ消息被重复消费？" class="headerlink" title="2.5.如何防止MQ消息被重复消费？"></a>2.5.如何防止MQ消息被重复消费？</h3><p>MQ能保证的是消息至少被消费者成功消费一次</p>
<p>在保证MQ消息不重复的情况下，消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，为了保证消息被消费，当消费者网络稳定后，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。</p>
<p><strong>话术：</strong></p>
<p>消息重复消费的原因多种多样，不可避免。所以只能从消费者端入手，只要能保证消息处理的<strong>幂等性</strong>（幂等性指的是同一个操作，不论执行多少次都是会得到相同的结果）就可以确保消息不被重复消费。</p>
<p>而幂等性的保证又有很多方案：</p>
<p><img src="C:/Users/Xu/AppData/Roaming/Typora/typora-user-images/image-20230222204020752.png" alt="image-20230222204020752"></p>
<ul>
<li>给每一条消息都添加一个唯一id，处理消息时基于数据库表的id唯一性做判断，如果插入过了一次就不会再插入了</li>
<li>加一个消息表，记录什么时候修改了什么</li>
</ul>
<h3 id="2-6-如何保证RabbitMQ的高可用？"><a href="#2-6-如何保证RabbitMQ的高可用？" class="headerlink" title="2.6.如何保证RabbitMQ的高可用？"></a>2.6.如何保证RabbitMQ的高可用？</h3><p><strong>话术：</strong></p>
<p>要实现RabbitMQ的高可用无外乎下面两点：</p>
<ul>
<li>做好交换机、队列、消息的持久化</li>
<li>搭建RabbitMQ的镜像集群，做好主从备份。当然也可以使用仲裁队列代替镜像集群。</li>
</ul>
<h3 id="2-7-使用MQ可以解决那些问题？"><a href="#2-7-使用MQ可以解决那些问题？" class="headerlink" title="2.7.使用MQ可以解决那些问题？"></a>2.7.使用MQ可以解决那些问题？</h3><p><strong>话术：</strong></p>
<p>RabbitMQ能解决的问题很多，例如：</p>
<ul>
<li>解耦合：将几个业务关联的微服务调用修改为基于MQ的异步通知，可以解除微服务之间的业务耦合。同时还提高了业务性能。</li>
<li>流量削峰：将突发的业务请求放入MQ中，作为缓冲区。后端的业务根据自己的处理能力从MQ中获取消息，逐个处理任务。流量曲线变的平滑很多</li>
<li>延迟队列：基于RabbitMQ的死信队列或者DelayExchange插件，可以实现消息发送后，延迟接收的效果。</li>
</ul>
<h2 id="3-Redis篇"><a href="#3-Redis篇" class="headerlink" title="3.Redis篇"></a>3.Redis篇</h2><h3 id="3-1-Redis与Memcache的区别？"><a href="#3-1-Redis与Memcache的区别？" class="headerlink" title="3.1.Redis与Memcache的区别？"></a>3.1.Redis与Memcache的区别？</h3><ul>
<li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li>
<li><code>集群模式</code>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><code>Redis使用单线程</code>：Memcached是多线程，非阻塞IO复用的网络模型；Redis使用<strong>单线程</strong>的<strong>多路 IO 复用</strong>模型。</li>
</ul>
<p><img src="/../pic/1574821356723.png" alt="1574821356723"></p>
<h3 id="3-2-Redis的单线程问题"><a href="#3-2-Redis的单线程问题" class="headerlink" title="3.2.Redis的单线程问题"></a>3.2.Redis的单线程问题</h3><p><strong>面试官</strong>：Redis采用单线程，如何保证高并发？</p>
<p><strong>面试话术</strong>：</p>
<p>Redis快的主要原因是：</p>
<ol>
<li>完全基于内存</li>
<li>数据结构简单，对数据操作也简单</li>
<li>使用多路 I&#x2F;O 复用模型，充分利用CPU资源</li>
</ol>
<p><strong>面试官</strong>：这样做的好处是什么？</p>
<p><strong>面试话术</strong>：</p>
<p>单线程优势有下面几点：</p>
<ul>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的CPU切换，充分利用CPU资源</li>
</ul>
<h3 id="3-2-Redis的持久化方案有哪些？"><a href="#3-2-Redis的持久化方案有哪些？" class="headerlink" title="3.2.Redis的持久化方案有哪些？"></a>3.2.Redis的持久化方案有哪些？</h3><p><strong>相关资料：</strong></p>
<p>1）RDB 持久化</p>
<p>RDB持久化可以使用save或bgsave，为了不阻塞主进程业务，一般都使用bgsave，流程：</p>
<ul>
<li>Redis 进程会 fork 出一个<strong>子进程</strong>（与父进程内存数据一致）。</li>
<li>父进程继续处理客户端请求命令</li>
<li>由<strong>子进程</strong>将<strong>内存</strong>中的所有数据<strong>写入到一个临时的 RDB 文件</strong>中。</li>
<li>完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。</li>
</ul>
<p>下面是一些和 RDB 持久化相关的配置：</p>
<ul>
<li><code>save 60 10000</code>：如果在 60 秒内有 10000 个 key 发生改变，那就执行 RDB 持久化。</li>
<li><code>stop-writes-on-bgsave-error yes</code>：如果 Redis 执行 RDB 持久化失败（常见于操作系统内存不足），那么 Redis 将不再接受 client 写入数据的请求。</li>
<li><code>rdbcompression yes</code>：当生成 RDB 文件时，同时进行压缩。</li>
<li><code>dbfilename dump.rdb</code>：将 RDB 文件命名为 dump.rdb。</li>
<li><code>dir /var/lib/redis</code>：将 RDB 文件保存在<code>/var/lib/redis</code>目录下。</li>
</ul>
<p>　　当然在实践中，我们通常会将<code>stop-writes-on-bgsave-error</code>设置为<code>false</code>，同时让监控系统在 Redis 执行 RDB 持久化失败时发送告警，以便人工介入解决，而不是粗暴地拒绝 client 的写入请求。</p>
<p>RDB持久化的优点：</p>
<ul>
<li>RDB持久化文件小，Redis<strong>数据恢复时速度快</strong></li>
<li>子进程不影响父进程，父进程可以持续处理客户端命令</li>
<li>子进程fork时采用<strong>copy-on-write</strong>方式，大多数情况下，没有太多的内存消耗，效率比较好。</li>
</ul>
<p> RDB 持久化的缺点：</p>
<ul>
<li>子进程fork时采用copy-on-write方式，如果Redis此时写操作较多，可能导致额外的内存占用，甚至内存溢出</li>
<li>RDB文件压缩会减小文件体积，但通过时会对CPU有额外的消耗</li>
<li>如果业务场景很看重数据的持久性 (durability)，那么不应该采用 RDB 持久化。譬如说，如果 Redis 每 5 分钟执行一次 RDB 持久化，要是 Redis 意外奔溃了，那么最多会丢失 5 分钟的数据。</li>
</ul>
<p>2）AOF 持久化</p>
<p>　　可以使用<code>appendonly yes</code>配置项来开启 AOF 持久化。Redis 执行 AOF 持久化时，会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。<br>　　与 RDB 持久化相比，AOF 持久化的一个明显优势就是，<strong>它可以提高数据的持久性 (durability)。</strong>因为在 AOF 模式下，Redis 每次接收到 client 的写命令，就会将命令<code>write()</code>到 AOF 文件末尾。<br>　　然而，在 Linux 中，将数据<code>write()</code>到文件后，数据并不会立即刷新到磁盘，而会先暂存在 OS 的文件系统缓冲区。在合适的时机，OS 才会将缓冲区的数据刷新到磁盘（如果需要将文件内容刷新到磁盘，可以调用<code>fsync()</code>或<code>fdatasync()</code>）。<br>　　通过<code>appendfsync</code>配置项，可以控制 Redis 将命令同步到磁盘的频率：</p>
<ul>
<li><code>always</code>：每次 Redis 将命令<code>write()</code>到 AOF 文件时，都会调用<code>fsync()</code>，将命令刷新到磁盘。这可以保证最好的数据持久性，但却会给系统带来极大的开销。</li>
<li><code>no</code>：Redis 只将命令<code>write()</code>到 AOF 文件。这会让 OS 决定何时将命令刷新到磁盘。</li>
<li><code>everysec</code>：除了将命令<code>write()</code>到 AOF 文件，Redis 还会每秒执行一次<code>fsync()</code>。在实践中，推荐使用这种设置，一定程度上可以保证数据持久性，又不会明显降低 Redis 性能。</li>
</ul>
<p>　　然而，AOF 持久化并不是没有缺点的：Redis 会不断将接收到的写命令追加到 AOF 文件中，导致 AOF 文件越来越大。过大的 AOF 文件会消耗磁盘空间，并且导致 Redis 重启时更加缓慢。为了解决这个问题，在适当情况下，Redis 会对 AOF 文件进行重写，去除文件中冗余的命令，以减小 AOF 文件的体积。在重写 AOF 文件期间， Redis 会启动一个子进程，由子进程负责对 AOF 文件进行重写。<br>　　可以通过下面两个配置项，控制 Redis 重写 AOF 文件的频率：</p>
<ul>
<li><code>auto-aof-rewrite-min-size 64mb</code></li>
<li><code>auto-aof-rewrite-percentage 100</code></li>
</ul>
<p>　　上面两个配置的作用：当 AOF 文件的体积大于 64MB，并且 AOF 文件的体积比上一次重写之后的体积大了至少一倍，那么 Redis 就会执行 AOF 重写。</p>
<p>优点：</p>
<ul>
<li>持久化频率高，数据可靠性高</li>
<li>没有额外的内存或CPU消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>文件体积大</li>
<li>文件大导致服务数据恢复时效率较低</li>
</ul>
<p><strong>面试话术：</strong></p>
<p>Redis 提供了两种数据持久化的方式，一种是 RDB，另一种是 AOF。<strong>默认情况下，Redis 使用的是 RDB 持久化。</strong></p>
<p>RDB持久化文件体积较小，但是保存数据的频率一般较低，可靠性差，容易丢失数据。另外RDB写数据时会采用Fork函数拷贝主进程，可能有额外的内存消耗，文件压缩也会有额外的CPU消耗。</p>
<p>AOF持久化<strong>可以做到每秒钟持久化一次</strong>，可靠性高。但是持久化文件体积较大，导致数据恢复时读取文件时间较长，效率略低</p>
<h3 id="3-3-Redis的集群方式有哪些？"><a href="#3-3-Redis的集群方式有哪些？" class="headerlink" title="3.3.Redis的集群方式有哪些？"></a>3.3.Redis的集群方式有哪些？</h3><p><strong>面试话术：</strong></p>
<p>Redis集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p>
<p><strong>主从集群</strong>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，<strong>目的是保证Redis的高可用</strong>。</p>
<p><strong>分片集群</strong>是数据分片，我们会让多个Redis节点组成集群，并将16383个插槽分到不同的节点上。存储数据时利用对key做hash运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让Redis能存储更多数据。</strong></p>
<p>1）主从集群</p>
<p>主从集群，也是读写分离集群。一般都是一主多从方式。</p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<ul>
<li>写数据时只能通过主节点完成</li>
<li>读数据可以从任何节点完成</li>
<li>如果配置了<code>哨兵节点</code>，当master宕机时，哨兵会从salve节点选出一个新的主。</li>
</ul>
<p>主从集群分两种：</p>
<p><img src="/../pic/1574821993599.png" alt="1574821993599"> <img src="/../pic/1574822026037.png" alt="1574822026037"> </p>
<p>带有哨兵的集群：</p>
<p><img src="/../pic/1574822077190.png" alt="1574822077190"></p>
<p>2）分片集群</p>
<p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p>
<p><img src="/../pic/1574822184467.png" alt="1574822184467"> </p>
<p>集群特征：</p>
<ul>
<li><p>每个节点都保存不同数据</p>
</li>
<li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>
</li>
<li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>
</li>
<li><p>客户端与redis节点直连,不需要中间proxy层连接集群中任何一个可用节点都可以访问到数据</p>
</li>
<li><p>redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上，实现动态伸缩</p>
</li>
</ul>
<p>为了保证Redis中每个节点的高可用，我们还可以给每个节点创建replication（slave节点），如图：</p>
<p><img src="/../pic/1574822584357.png" alt="1574822584357"></p>
<p>出现故障时，主从可以及时切换：</p>
<p><img src="/../pic/1574822602109.png" alt="1574822602109"></p>
<h3 id="3-4-Redis的常用数据类型有哪些？"><a href="#3-4-Redis的常用数据类型有哪些？" class="headerlink" title="3.4.Redis的常用数据类型有哪些？"></a>3.4.Redis的常用数据类型有哪些？</h3><p>支持多种类型的数据结构，主要区别是value存储的数据格式不同：</p>
<ul>
<li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p>
</li>
<li><p>list：按照添加顺序保持顺序的字符串列表。</p>
</li>
<li><p>set：无序的字符串集合，不存在重复的元素。</p>
</li>
<li><p>sorted set：已排序的字符串集合。</p>
</li>
<li><p>hash：key-value对格式</p>
</li>
</ul>
<h3 id="3-5-聊一下Redis事务机制"><a href="#3-5-聊一下Redis事务机制" class="headerlink" title="3.5.聊一下Redis事务机制"></a>3.5.聊一下Redis事务机制</h3><p><strong>相关资料：</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="http://redisdoc.com/topic/transaction.html">http://redisdoc.com/topic/transaction.html</a></p>
<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p>
<ul>
<li><code>MULTI</code>: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li>
<li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis不会执行其它事务的命令。</li>
<li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li>
<li><code>WATCH</code>：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li>
</ul>
<p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。<ul>
<li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li>
</ul>
</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<ul>
<li>即使事务中有某个&#x2F;某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li>
</ul>
</li>
</ul>
<p>为什么 Redis 不支持回滚（roll back）？</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<p><strong>面试话术：</strong></p>
<p>Redis事务其实是把一系列Redis命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p>
<p>为了弥补不能回滚的问题，Redis会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p>
<p>因此，只要程序员编程是正确的，理论上说Redis会正确执行所有事务，无需回滚。</p>
<p>面试官：如果事务执行一半的时候Redis宕机怎么办？</p>
<p>Redis有持久化机制，因为可靠性问题，我们一般使用AOF持久化。事务的所有命令也会写入AOF文件，但是如果在执行EXEC命令之前，Redis已经宕机，则AOF文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
<h3 id="3-6-Redis的Key过期策略"><a href="#3-6-Redis的Key过期策略" class="headerlink" title="3.6.Redis的Key过期策略"></a>3.6.Redis的Key过期策略</h3><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h4><h5 id="为什么需要内存回收？"><a href="#为什么需要内存回收？" class="headerlink" title="为什么需要内存回收？"></a>为什么需要内存回收？</h5><ul>
<li>1、在Redis中，set指令可以指定key的过期时间，当过期时间到达以后，key就失效了；</li>
<li>2、Redis是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li>
</ul>
<p>基于以上两点，为了保证Redis能继续提供可靠的服务，Redis需要一种机制清理掉<strong>不常用的、无效的、多余的</strong>数据，失效后的数据需要及时清理，这就需要内存回收了。</p>
<p>Redis的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p>
<h5 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h5><p>删除达到过期时间的key。</p>
<ul>
<li>1）定时删除</li>
</ul>
<p>对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是<strong>占用了大量的CPU资源去处理过期的数据</strong>，会<strong>影响Redis</strong>的吞吐量和响应时间。</p>
<ul>
<li>2）惰性删除</li>
</ul>
<p>当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地节省CPU资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</p>
<blockquote>
<p>在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p>
</blockquote>
<ul>
<li>3）定期删除</li>
</ul>
<p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>在Redis中，<code>同时使用了定期删除和惰性删除</code>。不过Redis定期删除采用的是<strong>随机抽取的方式删除部分Key</strong>，因此不能保证过期key 100%的删除。</p>
<p>Redis结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期key较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期key堆积在内存中，导致redis内存耗尽，当内存耗尽之后，有新的key到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的key？</p>
<h5 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h5><p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>
<p>Redis的内存淘汰机制包括：</p>
<ul>
<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 key（这个是最常用的）。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 key。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 key 优先移除。</li>
</ul>
<blockquote>
<p>在配置文件中，通过maxmemory-policy可以配置要使用哪一个淘汰机制。</p>
</blockquote>
<p>什么时候会进行淘汰？</p>
<p>Redis会在每一次处理命令的时候（processCommand函数调用freeMemoryIfNeeded）判断当前redis是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key。</p>
<p>在淘汰key时，Redis默认最常用的是LRU算法（Latest Recently Used）。Redis通过在每一个redisObject保存lru属性来保存key最近的访问时间，在实现LRU算法时直接读取key的lru属性。</p>
<p>具体实现时，Redis遍历每一个db，从每一个db中随机抽取一批样本key，默认是3个key，再从这3个key中，删除最近最少使用的key。</p>
<h4 id="面试话术："><a href="#面试话术：" class="headerlink" title="面试话术："></a>面试话术：</h4><p>Redis过期策略包含<strong>定期删除</strong>和<strong>惰性删除</strong>两部分(是没有定时删除的，因为定时删除太耗费CPU性能了)。定期删除是在Redis内部有一个定时任务，会定期删除一些过期的key。惰性删除是当用户查询某个Key时，会检查这个Key是否已经过期，如果没过期则返回用户，如果过期则删除。</p>
<p>但是这两个策略都无法保证过期key一定删除，漏网之鱼越来越多，还可能导致内存溢出。<strong>当发生内存不足问题时，Redis还会做内存回收</strong>。内存回收采用LRU策略，就是最近最少使用。其原理就是<strong>记录每个Key的最近使用时间，内存回收时，随机抽取一些Key，比较其使用时间，把最老的几个删除。</strong></p>
<p>Redis的逻辑是：最近使用过的，很可能再次被使用</p>
<h3 id="3-7-Redis在项目中的哪些地方有用到"><a href="#3-7-Redis在项目中的哪些地方有用到" class="headerlink" title="3.7.Redis在项目中的哪些地方有用到?"></a>3.7.Redis在项目中的哪些地方有用到?</h3><p>（1）共享session</p>
<p>在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。</p>
<p>（2）数据缓存</p>
<p>Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。</p>
<p>（3）异步队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub&#x2F;sub这样的专用结构，用于1对N的消息通信模式。</p>
<p>（4）分布式锁</p>
<p>Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p>
<h3 id="3-8-Redis的缓存击穿、缓存雪崩、缓存穿透"><a href="#3-8-Redis的缓存击穿、缓存雪崩、缓存穿透" class="headerlink" title="3.8.Redis的缓存击穿、缓存雪崩、缓存穿透"></a>3.8.Redis的缓存击穿、缓存雪崩、缓存穿透</h3><h4 id="1）缓存穿透"><a href="#1）缓存穿透" class="headerlink" title="1）缓存穿透"></a>1）缓存穿透</h4><p>参考资料：</p>
<ul>
<li><p>什么是缓存穿透</p>
<ul>
<li>正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</li>
</ul>
</li>
<li><p>穿透带来的问题</p>
<ul>
<li>试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以<strong>为这些key对应的值设置为null 丢到缓存里面去</strong>。后面再出现查询这个key 的请求的时候，直接返回null 。这样，就不用在到数据库中去走一圈了，但是<strong>别忘了设置过期时间</strong>。</li>
<li>BloomFilter（布隆过滤）：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</li>
</ul>
</li>
</ul>
<p><strong>话术：</strong></p>
<p>缓存穿透有两种解决方案：<strong>其一</strong>是把不存在的key设置null值到缓存中。<strong>其二</strong>是使用布隆过滤器，在查询缓存前先通过布隆过滤器判断key是否存在，存在再去查询缓存。</p>
<p>设置null值可能被恶意针对，攻击者使用大量不存在的不重复key ，那么方案一就会缓存大量不存在key数据。此时我们还可以对Key规定格式模板，然后对不存在的key做<strong>正则规范</strong>匹配，如果完全不符合就不用存null值到redis，而是直接返回错误。</p>
<h4 id="2）缓存击穿"><a href="#2）缓存击穿" class="headerlink" title="2）缓存击穿"></a>2）缓存击穿</h4><p><strong>相关资料</strong>：</p>
<ul>
<li>什么是缓存击穿？</li>
</ul>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p>当这个key在失效的瞬间，redis查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<ul>
<li>解决方案：<ul>
<li>使用互斥锁(mutex key)：mutex，就是互斥。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用Redis的SETNX去set一个互斥key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</li>
<li>软过期：也就是逻辑过期，不使用redis提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</li>
</ul>
</li>
</ul>
<p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p>
<p><strong>面试话术</strong>：</p>
<p>缓存击穿主要担心的是某个Key过期，更新缓存时引起对数据库的突发高并发访问。因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如Redis的setnx命令就能实现互斥效果。</p>
<h4 id="3）缓存雪崩"><a href="#3）缓存雪崩" class="headerlink" title="3）缓存雪崩"></a>3）缓存雪崩</h4><p><strong>相关资料</strong>：</p>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>
<p>解决方案：</p>
<ul>
<li>数据分类分批处理：采取不同分类数据，缓存不同周期</li>
<li>相同分类数据：采用固定时长加随机数方式设置缓存</li>
<li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li>
<li>避免redis节点宕机引起雪崩，搭建主从集群，保证高可用</li>
</ul>
<p><strong>面试话术：</strong></p>
<p>解决缓存雪崩问题的关键是让缓存Key的过期时间分散。因此我们可以<strong>把数据按照业务分类，然后设置不同过期时间。</strong>相同业务类型的key，设置固定时长加随机数。尽可能保证每个Key的过期时间都不相同。</p>
<p>另外，Redis宕机也可能导致缓存雪崩，因此我们还要搭建Redis主从集群及哨兵监控，保证Redis的高可用。</p>
<h3 id="3-9-缓存冷热数据分离"><a href="#3-9-缓存冷热数据分离" class="headerlink" title="3.9.缓存冷热数据分离"></a>3.9.缓存冷热数据分离</h3><p><strong>背景资料</strong>：</p>
<p>Redis使用的是内存存储，当需要海量数据存储时，成本非常高。</p>
<p>经过调研发现，当前主流DDR3内存和主流SATA SSD的单位成本价格差距大概在20倍左右，为了优化redis机器综合成本，我们考虑实现基于<strong>热度统计 的数据分级存储</strong>及数据在RAM&#x2F;FLASH之间的动态交换，从而大幅度降低成本，达到性能与成本的高平衡。</p>
<p>基本思路：基于key访问次数(LFU)的热度统计算法识别出热点数据，并将热点数据保留在redis中，对于无访问&#x2F;访问次数少的数据则转存到SSD上，如果SSD上的key再次变热，则重新将其加载到redis内存中。</p>
<p>目前流行的高性能磁盘存储，并且遵循Redis协议的方案包括：</p>
<ul>
<li>SSDB：<a target="_blank" rel="noopener" href="http://ssdb.io/zh_cn/">http://ssdb.io/zh_cn/</a></li>
<li>RocksDB：<a target="_blank" rel="noopener" href="https://rocksdb.org.cn/">https://rocksdb.org.cn/</a></li>
</ul>
<p>因此，我们就需要在应用程序与缓存服务之间引入代理，实现Redis和SSD之间的切换，如图：</p>
<p><img src="/../pic/image-20200521115702956.png" alt="image-20200521115702956"></p>
<p>这样的代理方案阿里云提供的就有。当然也有一些开源方案，例如：<a target="_blank" rel="noopener" href="https://github.com/JingchengLi/swapdb">https://github.com/JingchengLi/swapdb</a></p>
<h3 id="3-10-Redis实现分布式锁"><a href="#3-10-Redis实现分布式锁" class="headerlink" title="3.10.Redis实现分布式锁"></a>3.10.Redis实现分布式锁</h3><p>分布式锁要满足的条件：</p>
<ul>
<li>多进程互斥：同一时刻，只有一个进程可以获取锁</li>
<li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li>
<li>阻塞锁（可选）：获取锁失败时可否重试</li>
<li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li>
</ul>
<h4 id="1）最基本的分布式锁："><a href="#1）最基本的分布式锁：" class="headerlink" title="1）最基本的分布式锁："></a>1）最基本的分布式锁：</h4><p>利用Redis的setnx命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用expire命令给锁设置一个有效期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx lock thread-01 # 尝试获取锁</span><br><span class="line">expire lock 10 # 设置有效期</span><br></pre></td></tr></table></figure>

<p><strong>面试官问题1</strong>：如果expire之前服务宕机怎么办？</p>
<p>要保证setnx和expire命令的原子性。redis的set命令可以满足：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value [NX] [EX time] </span><br></pre></td></tr></table></figure>

<p>需要添加nx和ex的选项：</p>
<ul>
<li>NX：与setnx一致，第一次执行成功</li>
<li>EX：设置过期时间</li>
</ul>
<p><strong>面试官问题2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p>
<p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p>
<p>但是这两步操作要保证原子性，需要通过Lua脚本来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h4 id="2）可重入分布式锁"><a href="#2）可重入分布式锁" class="headerlink" title="2）可重入分布式锁"></a>2）可重入分布式锁</h4><p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p>
<p><img src="/../pic/1574824172228.png" alt="1574824172228"> </p>
<p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p>
<p>获取锁的步骤：</p>
<ul>
<li>1、判断lock是否存在 <code>EXISTS lock</code><ul>
<li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul>
<li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>
<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li>
</ul>
</li>
</ul>
</li>
<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>
<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>释放锁的步骤：</p>
<ul>
<li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经失效，不用管了</li>
<li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>
</ul>
</li>
<li>2、判断重入次数是否为0：<ul>
<li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li>
<li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>对应的Lua脚本如下：</p>
<p>首先是获取锁：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>然后是释放锁：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h4 id="3）高可用的锁"><a href="#3）高可用的锁" class="headerlink" title="3）高可用的锁"></a>3）高可用的锁</h4><p><code>面试官问题</code>：redis分布式锁依赖与redis，如果redis宕机则锁失效。如何解决？</p>
<p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p>
<p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p>
<p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程A获取锁，master还没有把数据备份到slave，master宕机，slave升级为master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p>
<p>关于这个问题，Redis官网给出了解决方案，使用RedLock思路可以解决：</p>
<blockquote>
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（<em>没有</em>在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ol>
</blockquote>
<h3 id="3-11-如何实现数据库与缓存数据一致？"><a href="#3-11-如何实现数据库与缓存数据一致？" class="headerlink" title="3.11.如何实现数据库与缓存数据一致？"></a>3.11.如何实现数据库与缓存数据一致？</h3><p>面试话术：</p>
<p>实现方案有下面几种：</p>
<ul>
<li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对Redis的修改逻辑，保证一致。</li>
<li>跨服务缓存同步：服务A调用了服务B，并对查询结果缓存。服务B数据库修改，可以通过MQ通知服务A，服务A修改Redis缓存数据</li>
<li>通用方案：使用Canal框架，伪装成MySQL的salve节点，监听MySQL的binLog变化，然后修改Redis缓存数据</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小白菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">http://example.com/2022/10/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">是小白菜哦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring-cloud/">spring cloud</a></div><div class="post_share"><div class="social-share" data-image="https://hakaimg.com/i/2022/08/08/nytkjo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/01/Dubbo/"><img class="prev-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Dubbo</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="next-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小白菜</div><div class="author-info__description">头发多多</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xiaobaicai350"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Xiaobaicai350" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1499487526@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阳光斑斓 微风含香 爱与四季 皆是向往 <img height="230" lengh="230" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1.gif"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text">微服务技术栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">认识微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">单体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">分布式架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud"><span class="toc-number">2.4.</span> <span class="toc-text">SpringCloud</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E7%9F%A5%E8%AF%86"><span class="toc-number">2.5.</span> <span class="toc-text">内容知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AF%B9%E6%AF%94"><span class="toc-number">2.6.</span> <span class="toc-text">技术栈对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">服务拆分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RestTemplate%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">RestTemplate远程调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">5.</span> <span class="toc-text">Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">5.1.</span> <span class="toc-text">搭建注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-number">5.2.</span> <span class="toc-text">服务注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96"><span class="toc-number">5.3.</span> <span class="toc-text">服务拉取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">6.</span> <span class="toc-text">Ribbon负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA"><span class="toc-number">6.1.</span> <span class="toc-text">源码跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.</span> <span class="toc-text">流程总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.</span> <span class="toc-text">负载均衡策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5"><span class="toc-number">6.4.</span> <span class="toc-text">自定义策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.5.</span> <span class="toc-text">饥饿加载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">7.</span> <span class="toc-text">Nacos注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-1"><span class="toc-number">7.1.</span> <span class="toc-text">服务注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">分级存储模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4"><span class="toc-number">7.2.1.</span> <span class="toc-text">配置集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NacosRule"><span class="toc-number">7.3.</span> <span class="toc-text">NacosRule</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE"><span class="toc-number">7.4.</span> <span class="toc-text">权重配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB"><span class="toc-number">7.5.</span> <span class="toc-text">环境隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAnamespace"><span class="toc-number">7.5.1.</span> <span class="toc-text">创建namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEnamespace"><span class="toc-number">7.5.2.</span> <span class="toc-text">配置namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nacos%E5%92%8CEureka%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.6.</span> <span class="toc-text">Nacos和Eureka的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.7.</span> <span class="toc-text">临时实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.</span> <span class="toc-text">Nacos配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="toc-number">8.1.</span> <span class="toc-text">创建配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-number">8.2.</span> <span class="toc-text">拉取配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.3.</span> <span class="toc-text">一个微服务中配置多个配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">8.4.</span> <span class="toc-text">配置热更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RefreshScope"><span class="toc-number">8.4.1.</span> <span class="toc-text">@RefreshScope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationProperties"><span class="toc-number">8.4.2.</span> <span class="toc-text">@ConfigurationProperties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">8.5.</span> <span class="toc-text">配置共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.6.</span> <span class="toc-text">配置优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos%E9%9B%86%E7%BE%A4"><span class="toc-number">9.</span> <span class="toc-text">Nacos集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">架构介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.2.</span> <span class="toc-text">初始化数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AENacos"><span class="toc-number">9.3.</span> <span class="toc-text">配置Nacos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">Nginx反向代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">Feign远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E4%BD%BF%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text">Feign使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="toc-number">10.2.</span> <span class="toc-text">自定义配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.4.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">10.4.1.</span> <span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">10.4.2.</span> <span class="toc-text">抽取方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gateway%E7%BD%91%E5%85%B3"><span class="toc-number">11.</span> <span class="toc-text">Gateway网关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">入门使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">11.2.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82"><span class="toc-number">11.3.</span> <span class="toc-text">断言工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="toc-number">11.4.</span> <span class="toc-text">过滤器工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">11.5.</span> <span class="toc-text">全局过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">11.6.</span> <span class="toc-text">过滤器顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">11.7.</span> <span class="toc-text">跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">11.8.</span> <span class="toc-text">网关相关配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">RabbitMQ消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">12.1.</span> <span class="toc-text">同步异步通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">12.2.</span> <span class="toc-text">MQ消息队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97"><span class="toc-number">13.</span> <span class="toc-text">RabbitMQ部署指南</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2"><span class="toc-number">14.</span> <span class="toc-text">1.单机部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">14.1.</span> <span class="toc-text">1.1.下载镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AE%89%E8%A3%85MQ"><span class="toc-number">14.2.</span> <span class="toc-text">1.2.安装MQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">14.3.</span> <span class="toc-text">入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#publisher%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.3.1.</span> <span class="toc-text">publisher实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.3.2.</span> <span class="toc-text">consumer实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringAMQP"><span class="toc-number">14.4.</span> <span class="toc-text">SpringAMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BasicQueue"><span class="toc-number">14.4.1.</span> <span class="toc-text">BasicQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue"><span class="toc-number">14.4.2.</span> <span class="toc-text">WorkQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-x2F-%E8%AE%A2%E9%98%85"><span class="toc-number">14.4.3.</span> <span class="toc-text">发布&#x2F;订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fanout"><span class="toc-number">14.4.3.1.</span> <span class="toc-text">Fanout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct"><span class="toc-number">14.4.3.2.</span> <span class="toc-text">Direct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic"><span class="toc-number">14.4.3.3.</span> <span class="toc-text">Topic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">14.4.4.</span> <span class="toc-text">消息转换器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ELasticsearch%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-number">15.</span> <span class="toc-text">ELasticsearch搜索引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">15.1.</span> <span class="toc-text">倒排索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%92%8C%E5%AD%97%E6%AE%B5"><span class="toc-number">15.2.</span> <span class="toc-text">文档和字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E6%98%A0%E5%B0%84"><span class="toc-number">15.3.</span> <span class="toc-text">索引和映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Elasticsearch"><span class="toc-number">15.4.</span> <span class="toc-text">安装Elasticsearch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85kibana"><span class="toc-number">15.5.</span> <span class="toc-text">安装kibana</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85IK%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">15.6.</span> <span class="toc-text">安装IK分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%AF%8D%E8%AF%8D%E5%85%B8"><span class="toc-number">15.7.</span> <span class="toc-text">扩展词词典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">15.8.</span> <span class="toc-text">索引库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84"><span class="toc-number">15.8.1.</span> <span class="toc-text">Mapping属性映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BA%93%E5%92%8C%E6%98%A0%E5%B0%84"><span class="toc-number">15.8.2.</span> <span class="toc-text">创建索引库和映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">15.8.3.</span> <span class="toc-text">修改索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">15.8.4.</span> <span class="toc-text">删除索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">15.8.5.</span> <span class="toc-text">查询索引库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">15.9.</span> <span class="toc-text">DSL文档操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%96%87%E6%A1%A3"><span class="toc-number">15.9.1.</span> <span class="toc-text">新增文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3"><span class="toc-number">15.9.2.</span> <span class="toc-text">修改文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3"><span class="toc-number">15.9.3.</span> <span class="toc-text">查询文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3"><span class="toc-number">15.9.4.</span> <span class="toc-text">删除文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestClient%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">15.10.</span> <span class="toc-text">RestClient文档操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96RestClient"><span class="toc-number">15.10.1.</span> <span class="toc-text">初始化RestClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">15.10.2.</span> <span class="toc-text">创建索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E5%BA%93-1"><span class="toc-number">15.10.3.</span> <span class="toc-text">删除索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">15.10.4.</span> <span class="toc-text">判断索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%96%87%E6%A1%A3-1"><span class="toc-number">15.10.5.</span> <span class="toc-text">新增文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3-1"><span class="toc-number">15.10.6.</span> <span class="toc-text">查询文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3-1"><span class="toc-number">15.10.7.</span> <span class="toc-text">删除文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3-1"><span class="toc-number">15.10.8.</span> <span class="toc-text">修改文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%96%87%E6%A1%A3"><span class="toc-number">15.10.9.</span> <span class="toc-text">批量导入文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.</span> <span class="toc-text">DSL文档查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89"><span class="toc-number">15.11.1.</span> <span class="toc-text">查询所有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2"><span class="toc-number">15.11.2.</span> <span class="toc-text">全文检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%87%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.3.</span> <span class="toc-text">精准查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#term%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.3.1.</span> <span class="toc-text">term查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#range%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.3.2.</span> <span class="toc-text">range查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.4.</span> <span class="toc-text">地理坐标查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.5.</span> <span class="toc-text">复合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AE%97%E5%88%86"><span class="toc-number">15.11.6.</span> <span class="toc-text">相关性算分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%88%86%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.7.</span> <span class="toc-text">算分函数查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.11.8.</span> <span class="toc-text">布尔查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">15.12.</span> <span class="toc-text">搜索结果处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">15.12.1.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">15.12.2.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BA%AE"><span class="toc-number">15.12.3.</span> <span class="toc-text">高亮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestClient%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.13.</span> <span class="toc-text">RestClient文档查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82"><span class="toc-number">15.13.1.</span> <span class="toc-text">发起查询请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%9F%A5%E8%AF%A2%E5%93%8D%E5%BA%94"><span class="toc-number">15.13.2.</span> <span class="toc-text">解析查询响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#match%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.13.3.</span> <span class="toc-text">match查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.13.4.</span> <span class="toc-text">精确查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">15.13.5.</span> <span class="toc-text">布尔查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E3%80%81%E5%88%86%E9%A1%B5"><span class="toc-number">15.13.6.</span> <span class="toc-text">排序、分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BA%AE-1"><span class="toc-number">15.13.7.</span> <span class="toc-text">高亮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">15.13.8.</span> <span class="toc-text">地理坐标查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E5%BE%97%E5%88%86"><span class="toc-number">15.13.9.</span> <span class="toc-text">相关性得分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-number">15.14.</span> <span class="toc-text">DSL数据聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bucket%E8%81%9A%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">15.14.1.</span> <span class="toc-text">Bucket聚合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metric%E8%81%9A%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">15.14.2.</span> <span class="toc-text">Metric聚合语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestAPI%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-number">15.15.</span> <span class="toc-text">RestAPI数据聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">15.16.</span> <span class="toc-text">自动补全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">15.16.1.</span> <span class="toc-text">拼音分词器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">15.16.2.</span> <span class="toc-text">自定义分词器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.16.3.</span> <span class="toc-text">自动补全查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaAPI"><span class="toc-number">15.16.4.</span> <span class="toc-text">JavaAPI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">15.17.</span> <span class="toc-text">数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-number">15.17.1.</span> <span class="toc-text">同步调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5"><span class="toc-number">15.17.2.</span> <span class="toc-text">异步通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACbinlog"><span class="toc-number">15.17.3.</span> <span class="toc-text">监听binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">15.17.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">15.17.5.</span> <span class="toc-text">实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Elasticsearch%E9%9B%86%E7%BE%A4"><span class="toc-number">16.</span> <span class="toc-text">Elasticsearch集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4"><span class="toc-number">16.1.</span> <span class="toc-text">部署集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAElasticsearch"><span class="toc-number">16.1.1.</span> <span class="toc-text">搭建Elasticsearch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-number">16.1.2.</span> <span class="toc-text">集群状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BA%93-1"><span class="toc-number">16.1.3.</span> <span class="toc-text">创建索引库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%81%8C%E8%B4%A3%E5%88%92%E5%88%86"><span class="toc-number">16.2.</span> <span class="toc-text">集群职责划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98"><span class="toc-number">16.3.</span> <span class="toc-text">集群脑裂问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">16.4.</span> <span class="toc-text">集群分布式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">16.5.</span> <span class="toc-text">集群分布式查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">16.6.</span> <span class="toc-text">集群故障转移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">17.</span> <span class="toc-text">JMeter压力测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8"><span class="toc-number">17.1.</span> <span class="toc-text">安装启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%AD%E6%96%87"><span class="toc-number">17.2.</span> <span class="toc-text">修改中文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">17.3.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sentine%E6%B5%81%E9%87%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">18.</span> <span class="toc-text">Sentine流量组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">18.1.</span> <span class="toc-text">雪崩问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Sentinel"><span class="toc-number">18.2.</span> <span class="toc-text">初识Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">18.3.</span> <span class="toc-text">整合Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">18.4.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF"><span class="toc-number">18.4.1.</span> <span class="toc-text">簇点链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.4.2.</span> <span class="toc-text">流控模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.4.2.1.</span> <span class="toc-text">直接模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.4.2.2.</span> <span class="toc-text">关联模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.4.2.3.</span> <span class="toc-text">链路模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C"><span class="toc-number">18.5.</span> <span class="toc-text">流控效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="toc-number">18.5.1.</span> <span class="toc-text">快速失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Warm-up"><span class="toc-number">18.5.2.</span> <span class="toc-text">Warm up</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">18.5.3.</span> <span class="toc-text">排队等待</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">18.6.</span> <span class="toc-text">热点参数限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">18.6.1.</span> <span class="toc-text">全局参数限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81-1"><span class="toc-number">18.6.2.</span> <span class="toc-text">热点参数限流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="toc-number">18.7.</span> <span class="toc-text">隔离和降级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">18.7.1.</span> <span class="toc-text">Feign整合Sentinel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="toc-number">18.7.2.</span> <span class="toc-text">线程隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">18.7.3.</span> <span class="toc-text">熔断降级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E8%B0%83%E7%94%A8"><span class="toc-number">18.7.3.1.</span> <span class="toc-text">慢调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">18.7.3.2.</span> <span class="toc-text">异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">18.8.</span> <span class="toc-text">授权规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C"><span class="toc-number">18.9.</span> <span class="toc-text">自定义异常结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">18.10.</span> <span class="toc-text">规则持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pull%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.10.1.</span> <span class="toc-text">pull模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.10.2.</span> <span class="toc-text">push模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">19.</span> <span class="toc-text">Seata分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">19.1.</span> <span class="toc-text">分布式事务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">19.2.</span> <span class="toc-text">解决分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">19.2.1.</span> <span class="toc-text">CAP定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Consistency%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">19.2.1.1.</span> <span class="toc-text">Consistency一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Availability%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">19.2.1.2.</span> <span class="toc-text">Availability可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Partition-Tolerance%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99"><span class="toc-number">19.2.1.3.</span> <span class="toc-text">Partition Tolerance分区容错</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-number">19.2.2.</span> <span class="toc-text">BASE理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2Seata"><span class="toc-number">19.3.</span> <span class="toc-text">部署Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">19.3.1.</span> <span class="toc-text">Seata的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2TC%E6%9C%8D%E5%8A%A1"><span class="toc-number">19.3.2.</span> <span class="toc-text">部署TC服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90"><span class="toc-number">19.3.3.</span> <span class="toc-text">Seata微服务集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TC%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%9C%B0%E5%AE%B9%E7%81%BE"><span class="toc-number">19.3.4.</span> <span class="toc-text">TC服务异地容灾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.4.</span> <span class="toc-text">XA模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">19.4.1.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.4.2.</span> <span class="toc-text">实现XA模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.5.</span> <span class="toc-text">AT模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">19.5.1.</span> <span class="toc-text">流程梳理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AT%E4%B8%8EXA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.5.2.</span> <span class="toc-text">AT与XA的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">19.5.3.</span> <span class="toc-text">脏写问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">19.5.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.5.5.</span> <span class="toc-text">实现AT模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.6.</span> <span class="toc-text">TCC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">19.6.1.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%9B%9E%E6%BB%9A"><span class="toc-number">19.6.2.</span> <span class="toc-text">空回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%82%AC%E6%8C%82"><span class="toc-number">19.6.3.</span> <span class="toc-text">业务悬挂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0TCC%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.6.4.</span> <span class="toc-text">实现TCC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">19.6.4.1.</span> <span class="toc-text">设计数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8ETCC%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.6.4.2.</span> <span class="toc-text">声明TCC接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">19.6.4.3.</span> <span class="toc-text">编写实现类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SAGA%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.7.</span> <span class="toc-text">SAGA模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">19.7.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">20.</span> <span class="toc-text">Redis分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">20.1.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">20.1.1.</span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">20.1.2.</span> <span class="toc-text">AOF持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94"><span class="toc-number">20.1.3.</span> <span class="toc-text">RDB和AOF对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">20.2.</span> <span class="toc-text">Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E"><span class="toc-number">20.2.1.</span> <span class="toc-text">搭建主从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">20.2.2.</span> <span class="toc-text">同步原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">20.2.2.1.</span> <span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">20.2.2.2.</span> <span class="toc-text">增量同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">20.2.3.</span> <span class="toc-text">主从同步优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="toc-number">20.3.</span> <span class="toc-text">Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">20.3.1.</span> <span class="toc-text">哨兵的作用和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-number">20.3.2.</span> <span class="toc-text">搭建哨兵集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">20.3.2.1.</span> <span class="toc-text">集群结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%AE%9E%E4%BE%8B%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">20.3.2.2.</span> <span class="toc-text">准备实例和配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">20.3.2.3.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">20.3.2.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisTemplate%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.3.3.</span> <span class="toc-text">RedisTemplate的哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">20.3.3.1.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AERedis%E5%9C%B0%E5%9D%80"><span class="toc-number">20.3.3.2.</span> <span class="toc-text">配置Redis地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">20.3.3.3.</span> <span class="toc-text">配置读写分离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">20.4.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">20.4.1.</span> <span class="toc-text">搭建分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84-1"><span class="toc-number">20.4.1.1.</span> <span class="toc-text">集群结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%AE%9E%E4%BE%8B%E5%92%8C%E9%85%8D%E7%BD%AE-1"><span class="toc-number">20.4.1.2.</span> <span class="toc-text">准备实例和配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-1"><span class="toc-number">20.4.1.3.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">20.4.1.4.</span> <span class="toc-text">创建集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">20.4.1.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">20.4.2.</span> <span class="toc-text">散列插槽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD%E5%8E%9F%E7%90%86"><span class="toc-number">20.4.2.1.</span> <span class="toc-text">插槽原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">20.4.2.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="toc-number">20.4.3.</span> <span class="toc-text">集群伸缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">20.4.3.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84redis%E5%AE%9E%E4%BE%8B"><span class="toc-number">20.4.3.2.</span> <span class="toc-text">创建新的redis实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9%E5%88%B0redis"><span class="toc-number">20.4.3.3.</span> <span class="toc-text">添加新节点到redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8F%92%E6%A7%BD"><span class="toc-number">20.4.3.4.</span> <span class="toc-text">转移插槽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">20.4.4.</span> <span class="toc-text">故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">20.4.4.1.</span> <span class="toc-text">自动故障转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">20.4.4.2.</span> <span class="toc-text">手动故障转移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">20.4.5.</span> <span class="toc-text">RedisTemplate访问分片集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">21.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">21.1.</span> <span class="toc-text">什么是多级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">21.2.</span> <span class="toc-text">JVM进程缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%A1%88%E4%BE%8B"><span class="toc-number">21.2.1.</span> <span class="toc-text">导入案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AF%BC%E5%85%A5%E8%AF%B4%E6%98%8E"><span class="toc-number">22.</span> <span class="toc-text">案例导入说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85MySQL"><span class="toc-number">23.</span> <span class="toc-text">1.安装MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%87%86%E5%A4%87%E7%9B%AE%E5%BD%95"><span class="toc-number">23.1.</span> <span class="toc-text">1.1.准备目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">23.2.</span> <span class="toc-text">1.2.运行命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">23.3.</span> <span class="toc-text">1.3.修改配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%87%8D%E5%90%AF"><span class="toc-number">23.4.</span> <span class="toc-text">1.4.重启</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AF%BC%E5%85%A5SQL"><span class="toc-number">24.</span> <span class="toc-text">2.导入SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AF%BC%E5%85%A5Demo%E5%B7%A5%E7%A8%8B"><span class="toc-number">25.</span> <span class="toc-text">3.导入Demo工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81"><span class="toc-number">25.1.</span> <span class="toc-text">3.1.分页查询商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%B0%E5%A2%9E%E5%95%86%E5%93%81"><span class="toc-number">25.2.</span> <span class="toc-text">3.2.新增商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BF%AE%E6%94%B9%E5%95%86%E5%93%81"><span class="toc-number">25.3.</span> <span class="toc-text">3.3.修改商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BF%AE%E6%94%B9%E5%BA%93%E5%AD%98"><span class="toc-number">25.4.</span> <span class="toc-text">3.4.修改库存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%88%A0%E9%99%A4%E5%95%86%E5%93%81"><span class="toc-number">25.5.</span> <span class="toc-text">3.5.删除商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81"><span class="toc-number">25.6.</span> <span class="toc-text">3.6.根据id查询商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%BA%93%E5%AD%98"><span class="toc-number">25.7.</span> <span class="toc-text">3.7.根据id查询库存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%90%AF%E5%8A%A8"><span class="toc-number">25.8.</span> <span class="toc-text">3.8.启动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AF%BC%E5%85%A5%E5%95%86%E5%93%81%E6%9F%A5%E8%AF%A2%E9%A1%B5%E9%9D%A2"><span class="toc-number">26.</span> <span class="toc-text">4.导入商品查询页面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%BF%90%E8%A1%8Cnginx%E6%9C%8D%E5%8A%A1"><span class="toc-number">26.1.</span> <span class="toc-text">4.1.运行nginx服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">26.2.</span> <span class="toc-text">4.2.反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Caffeine"><span class="toc-number">26.2.1.</span> <span class="toc-text">初识Caffeine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">26.2.2.</span> <span class="toc-text">实现JVM进程缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">26.2.2.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">26.2.2.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8"><span class="toc-number">26.3.</span> <span class="toc-text">Lua语法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Lua"><span class="toc-number">26.3.1.</span> <span class="toc-text">初识Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloWorld"><span class="toc-number">26.3.1.1.</span> <span class="toc-text">HelloWorld</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="toc-number">26.3.2.</span> <span class="toc-text">变量和循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.3.2.1.</span> <span class="toc-text">Lua的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">26.3.2.2.</span> <span class="toc-text">声明变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">26.3.2.3.</span> <span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">26.3.3.</span> <span class="toc-text">条件控制、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">26.3.3.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">26.3.3.2.</span> <span class="toc-text">条件控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">26.3.3.3.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">26.4.</span> <span class="toc-text">实现多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85OpenResty"><span class="toc-number">26.4.1.</span> <span class="toc-text">安装OpenResty</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85OpenResty-1"><span class="toc-number">27.</span> <span class="toc-text">安装OpenResty</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85"><span class="toc-number">28.</span> <span class="toc-text">1.安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E5%BA%93"><span class="toc-number">28.1.</span> <span class="toc-text">1）安装开发库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89%E5%AE%89%E8%A3%85OpenResty%E4%BB%93%E5%BA%93"><span class="toc-number">28.2.</span> <span class="toc-text">2）安装OpenResty仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%89%E5%AE%89%E8%A3%85OpenResty"><span class="toc-number">28.3.</span> <span class="toc-text">3）安装OpenResty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89%E5%AE%89%E8%A3%85opm%E5%B7%A5%E5%85%B7"><span class="toc-number">28.4.</span> <span class="toc-text">4）安装opm工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">28.5.</span> <span class="toc-text">5）目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89%E9%85%8D%E7%BD%AEnginx%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">28.6.</span> <span class="toc-text">6）配置nginx的环境变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">29.</span> <span class="toc-text">2.启动和运行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A4%87%E6%B3%A8"><span class="toc-number">30.</span> <span class="toc-text">3.备注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenResty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">30.0.1.</span> <span class="toc-text">OpenResty快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">30.0.1.1.</span> <span class="toc-text">反向代理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenResty%E7%9B%91%E5%90%AC%E8%AF%B7%E6%B1%82"><span class="toc-number">30.0.1.2.</span> <span class="toc-text">OpenResty监听请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99item-lua"><span class="toc-number">30.0.1.3.</span> <span class="toc-text">编写item.lua</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-number">30.0.2.</span> <span class="toc-text">请求参数处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84API"><span class="toc-number">30.0.2.1.</span> <span class="toc-text">获取参数的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E"><span class="toc-number">30.0.2.2.</span> <span class="toc-text">获取参数并返回</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Tomcat"><span class="toc-number">30.0.3.</span> <span class="toc-text">查询Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84API"><span class="toc-number">30.0.3.1.</span> <span class="toc-text">发送http请求的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85http%E5%B7%A5%E5%85%B7"><span class="toc-number">30.0.3.2.</span> <span class="toc-text">封装http工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CJSON%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">30.0.3.3.</span> <span class="toc-text">CJSON工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Tomcat%E6%9F%A5%E8%AF%A2"><span class="toc-number">30.0.3.4.</span> <span class="toc-text">实现Tomcat查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EID%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">30.0.3.5.</span> <span class="toc-text">基于ID负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%8E%9F%E7%90%86"><span class="toc-number">30.0.3.5.1.</span> <span class="toc-text">1）原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">30.0.3.5.2.</span> <span class="toc-text">2）实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-number">30.0.3.5.3.</span> <span class="toc-text">3）测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">30.0.4.</span> <span class="toc-text">Redis缓存预热</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Redis%E7%BC%93%E5%AD%98"><span class="toc-number">30.0.5.</span> <span class="toc-text">查询Redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7"><span class="toc-number">30.0.5.1.</span> <span class="toc-text">封装Redis工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Redis%E6%9F%A5%E8%AF%A2"><span class="toc-number">30.0.5.2.</span> <span class="toc-text">实现Redis查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">30.0.6.</span> <span class="toc-text">Nginx本地缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98API"><span class="toc-number">30.0.6.1.</span> <span class="toc-text">本地缓存API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2"><span class="toc-number">30.0.6.2.</span> <span class="toc-text">实现本地缓存查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">30.1.</span> <span class="toc-text">缓存同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">30.1.1.</span> <span class="toc-text">数据同步策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Canal"><span class="toc-number">30.1.2.</span> <span class="toc-text">安装Canal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Canal"><span class="toc-number">30.1.2.1.</span> <span class="toc-text">认识Canal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Canal-1"><span class="toc-number">30.1.2.2.</span> <span class="toc-text">安装Canal</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AECanal"><span class="toc-number">31.</span> <span class="toc-text">安装和配置Canal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AFMySQL%E4%B8%BB%E4%BB%8E"><span class="toc-number">32.</span> <span class="toc-text">1.开启MySQL主从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%BC%80%E5%90%AFbinlog"><span class="toc-number">32.1.</span> <span class="toc-text">1.1.开启binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90"><span class="toc-number">32.2.</span> <span class="toc-text">1.2.设置用户权限</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85Canal"><span class="toc-number">33.</span> <span class="toc-text">2.安装Canal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">33.1.</span> <span class="toc-text">2.1.创建网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%89%E8%A3%85Canal"><span class="toc-number">33.2.</span> <span class="toc-text">2.3.安装Canal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACCanal"><span class="toc-number">33.2.1.</span> <span class="toc-text">监听Canal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">33.2.1.1.</span> <span class="toc-text">引入依赖：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">33.2.1.2.</span> <span class="toc-text">编写配置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9Item%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">33.2.1.3.</span> <span class="toc-text">修改Item实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">33.2.1.4.</span> <span class="toc-text">编写监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">33.2.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1-%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">34.</span> <span class="toc-text">服务异步通信-高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">34.1.</span> <span class="toc-text">消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">34.1.1.</span> <span class="toc-text">生产者消息确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">34.1.1.1.</span> <span class="toc-text">修改配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Return%E5%9B%9E%E8%B0%83"><span class="toc-number">34.1.1.2.</span> <span class="toc-text">定义Return回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89ConfirmCallback"><span class="toc-number">34.1.1.3.</span> <span class="toc-text">定义ConfirmCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">34.1.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">34.1.2.</span> <span class="toc-text">消息持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">34.1.2.1.</span> <span class="toc-text">交换机持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">34.1.2.2.</span> <span class="toc-text">队列持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-1"><span class="toc-number">34.1.2.3.</span> <span class="toc-text">消息持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">34.1.3.</span> <span class="toc-text">消费者消息确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BAnone%E6%A8%A1%E5%BC%8F"><span class="toc-number">34.1.3.1.</span> <span class="toc-text">演示none模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BAauto%E6%A8%A1%E5%BC%8F"><span class="toc-number">34.1.3.2.</span> <span class="toc-text">演示auto模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">34.1.4.</span> <span class="toc-text">消费失败重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%87%8D%E8%AF%95"><span class="toc-number">34.1.4.1.</span> <span class="toc-text">本地重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">34.1.4.2.</span> <span class="toc-text">失败策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">34.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">34.2.</span> <span class="toc-text">死信交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">34.2.1.</span> <span class="toc-text">初识死信交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">34.2.1.1.</span> <span class="toc-text">什么是死信交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E6%94%B6%E6%AD%BB%E4%BF%A1%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">34.2.1.2.</span> <span class="toc-text">利用死信交换机接收死信（拓展）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">34.2.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TTL"><span class="toc-number">34.2.2.</span> <span class="toc-text">TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%B6%85%E6%97%B6%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">34.2.2.1.</span> <span class="toc-text">接收超时死信的死信交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8C%87%E5%AE%9ATTL"><span class="toc-number">34.2.2.2.</span> <span class="toc-text">声明一个队列，并且指定TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%97%B6%EF%BC%8C%E8%AE%BE%E5%AE%9ATTL"><span class="toc-number">34.2.2.3.</span> <span class="toc-text">发送消息时，设定TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">34.2.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">34.2.3.</span> <span class="toc-text">延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85DelayExchange%E6%8F%92%E4%BB%B6"><span class="toc-number">34.2.3.1.</span> <span class="toc-text">安装DelayExchange插件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85DelayExchange%E6%8F%92%E4%BB%B6"><span class="toc-number">35.</span> <span class="toc-text">2.安装DelayExchange插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6"><span class="toc-number">35.1.</span> <span class="toc-text">2.1.下载插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6"><span class="toc-number">35.2.</span> <span class="toc-text">2.2.上传插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"><span class="toc-number">35.3.</span> <span class="toc-text">2.3.安装插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayExchange%E5%8E%9F%E7%90%86"><span class="toc-number">35.3.0.1.</span> <span class="toc-text">DelayExchange原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DelayExchange"><span class="toc-number">35.3.0.2.</span> <span class="toc-text">使用DelayExchange</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%A3%B0%E6%98%8EDelayExchange%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">35.3.0.2.1.</span> <span class="toc-text">1）声明DelayExchange交换机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">35.3.0.2.2.</span> <span class="toc-text">2）发送消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">35.3.0.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">35.4.</span> <span class="toc-text">惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">35.4.1.</span> <span class="toc-text">消息堆积问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97-1"><span class="toc-number">35.4.2.</span> <span class="toc-text">惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AElazy-queue"><span class="toc-number">35.4.2.1.</span> <span class="toc-text">基于命令行设置lazy-queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Bean%E5%A3%B0%E6%98%8Elazy-queue"><span class="toc-number">35.4.2.2.</span> <span class="toc-text">基于@Bean声明lazy-queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-RabbitListener%E5%A3%B0%E6%98%8ELazyQueue"><span class="toc-number">35.4.2.3.</span> <span class="toc-text">基于@RabbitListener声明LazyQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%91%E9%80%81%E8%80%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">35.4.2.4.</span> <span class="toc-text">使用发送者进行测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">35.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E9%9B%86%E7%BE%A4"><span class="toc-number">35.5.</span> <span class="toc-text">MQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB"><span class="toc-number">35.5.1.</span> <span class="toc-text">集群分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">35.5.2.</span> <span class="toc-text">普通集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">35.5.2.1.</span> <span class="toc-text">集群结构和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">35.5.2.2.</span> <span class="toc-text">部署</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">36.</span> <span class="toc-text">3.集群部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB"><span class="toc-number">36.1.</span> <span class="toc-text">2.1.集群分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%8E%B7%E5%8F%96cookie"><span class="toc-number">36.2.</span> <span class="toc-text">2.2.获取cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%87%86%E5%A4%87%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">36.3.</span> <span class="toc-text">2.3.准备集群配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">36.4.</span> <span class="toc-text">2.4.启动集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%B5%8B%E8%AF%95"><span class="toc-number">36.5.</span> <span class="toc-text">2.5.测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E6%B5%8B%E8%AF%95"><span class="toc-number">36.5.1.</span> <span class="toc-text">2.5.1.数据共享测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-number">36.5.2.</span> <span class="toc-text">2.5.2.可用性测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">36.5.3.</span> <span class="toc-text">镜像集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E5%BE%81-1"><span class="toc-number">36.5.3.1.</span> <span class="toc-text">集群结构和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-1"><span class="toc-number">36.5.3.2.</span> <span class="toc-text">部署</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.</span> <span class="toc-text">4.镜像模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">37.1.</span> <span class="toc-text">4.1.镜像模式的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">37.2.</span> <span class="toc-text">4.2.镜像模式的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-exactly%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.2.1.</span> <span class="toc-text">4.2.1.exactly模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-all%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.2.2.</span> <span class="toc-text">4.2.2.all模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-nodes%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.2.3.</span> <span class="toc-text">4.2.3.nodes模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B5%8B%E8%AF%95"><span class="toc-number">37.3.</span> <span class="toc-text">4.3.测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">37.3.1.</span> <span class="toc-text">4.3.1.测试数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%B5%8B%E8%AF%95%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">37.3.2.</span> <span class="toc-text">4.3.2.测试高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">37.3.3.</span> <span class="toc-text">仲裁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%89%B9%E5%BE%81"><span class="toc-number">37.3.3.1.</span> <span class="toc-text">集群特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-2"><span class="toc-number">37.3.3.2.</span> <span class="toc-text">部署</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">38.</span> <span class="toc-text">5.仲裁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%B7%BB%E5%8A%A0%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">38.1.</span> <span class="toc-text">5.1.添加仲裁队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B5%8B%E8%AF%95"><span class="toc-number">38.2.</span> <span class="toc-text">5.2.测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-number">38.3.</span> <span class="toc-text">5.3.集群扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">38.3.1.</span> <span class="toc-text">5.3.1.加入集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%A2%9E%E5%8A%A0%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97%E5%89%AF%E6%9C%AC"><span class="toc-number">38.3.2.</span> <span class="toc-text">5.3.2.增加仲裁队列副本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">38.3.2.1.</span> <span class="toc-text">Java代码创建仲裁队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringAMQP%E8%BF%9E%E6%8E%A5MQ%E9%9B%86%E7%BE%A4"><span class="toc-number">38.3.2.2.</span> <span class="toc-text">SpringAMQP连接MQ集群</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">39.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AF%87"><span class="toc-number">39.1.</span> <span class="toc-text">1.微服务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SpringCloud%E5%B8%B8%E8%A7%81%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">39.1.1.</span> <span class="toc-text">1.1.SpringCloud常见组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Nacos%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">39.1.2.</span> <span class="toc-text">1.2.Nacos的服务注册表结构是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Nacos%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E9%98%BF%E9%87%8C%E5%86%85%E9%83%A8%E6%95%B0%E5%8D%81%E4%B8%87%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8E%8B%E5%8A%9B%EF%BC%9F"><span class="toc-number">39.1.3.</span> <span class="toc-text">1.3.Nacos如何支撑阿里内部数十万服务注册压力？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Nacos%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">39.1.4.</span> <span class="toc-text">1.4.Nacos如何避免并发读写冲突问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Nacos%E4%B8%8EEureka%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">39.1.5.</span> <span class="toc-text">1.5.Nacos与Eureka的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Sentinel%E7%9A%84%E9%99%90%E6%B5%81%E4%B8%8EGateway%E7%9A%84%E9%99%90%E6%B5%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-number">39.1.6.</span> <span class="toc-text">1.6.Sentinel的限流与Gateway的限流有什么差别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Sentinel%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E4%B8%8EHystix%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB"><span class="toc-number">39.1.7.</span> <span class="toc-text">1.7.Sentinel的线程隔离与Hystix的线程隔离有什么差别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MQ%E7%AF%87"><span class="toc-number">39.2.</span> <span class="toc-text">2.MQ篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BD%A0%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86RabbitMQ%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E5%AE%83%E7%9A%84MQ%EF%BC%9F"><span class="toc-number">39.2.1.</span> <span class="toc-text">2.1.你们为什么选择了RabbitMQ而不是其它的MQ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-RabbitMQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">39.2.2.</span> <span class="toc-text">2.2.RabbitMQ如何确保消息的不丢失？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-RabbitMQ%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%EF%BC%9F"><span class="toc-number">39.2.3.</span> <span class="toc-text">2.3.RabbitMQ如何避免消息堆积？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">39.2.4.</span> <span class="toc-text">2.4.RabbitMQ如何保证消息的有序性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2MQ%E6%B6%88%E6%81%AF%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="toc-number">39.2.5.</span> <span class="toc-text">2.5.如何防止MQ消息被重复消费？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81RabbitMQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">39.2.6.</span> <span class="toc-text">2.6.如何保证RabbitMQ的高可用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E4%BD%BF%E7%94%A8MQ%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">39.2.7.</span> <span class="toc-text">2.7.使用MQ可以解决那些问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E7%AF%87"><span class="toc-number">39.3.</span> <span class="toc-text">3.Redis篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Redis%E4%B8%8EMemcache%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">39.3.1.</span> <span class="toc-text">3.1.Redis与Memcache的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">39.3.2.</span> <span class="toc-text">3.2.Redis的单线程问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">39.3.3.</span> <span class="toc-text">3.2.Redis的持久化方案有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">39.3.4.</span> <span class="toc-text">3.3.Redis的集群方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">39.3.5.</span> <span class="toc-text">3.4.Redis的常用数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%81%8A%E4%B8%80%E4%B8%8BRedis%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">39.3.6.</span> <span class="toc-text">3.5.聊一下Redis事务机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Redis%E7%9A%84Key%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">39.3.7.</span> <span class="toc-text">3.6.Redis的Key过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A"><span class="toc-number">39.3.7.1.</span> <span class="toc-text">参考资料：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">39.3.7.1.1.</span> <span class="toc-text">为什么需要内存回收？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">39.3.7.1.2.</span> <span class="toc-text">过期删除策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">39.3.7.1.3.</span> <span class="toc-text">内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%EF%BC%9A"><span class="toc-number">39.3.7.2.</span> <span class="toc-text">面试话术：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E6%9C%89%E7%94%A8%E5%88%B0"><span class="toc-number">39.3.8.</span> <span class="toc-text">3.7.Redis在项目中的哪些地方有用到?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-Redis%E7%9A%84%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">39.3.9.</span> <span class="toc-text">3.8.Redis的缓存击穿、缓存雪崩、缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">39.3.9.1.</span> <span class="toc-text">1）缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">39.3.9.2.</span> <span class="toc-text">2）缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">39.3.9.3.</span> <span class="toc-text">3）缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E7%BC%93%E5%AD%98%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">39.3.10.</span> <span class="toc-text">3.9.缓存冷热数据分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">39.3.11.</span> <span class="toc-text">3.10.Redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A"><span class="toc-number">39.3.11.1.</span> <span class="toc-text">1）最基本的分布式锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">39.3.11.2.</span> <span class="toc-text">2）可重入分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%94%81"><span class="toc-number">39.3.11.3.</span> <span class="toc-text">3）高可用的锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="toc-number">39.3.12.</span> <span class="toc-text">3.11.如何实现数据库与缓存数据一致？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantLock/" title="深入理解ReentrantLock">深入理解ReentrantLock</a><time datetime="2023-08-20T12:31:06.000Z" title="发表于 2023-08-20 20:31:06">2023-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/19/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/" title="线程八锁">线程八锁</a><time datetime="2023-08-19T08:50:12.000Z" title="发表于 2023-08-19 16:50:12">2023-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/18/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a><time datetime="2023-08-18T07:12:06.000Z" title="发表于 2023-08-18 15:12:06">2023-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%85%A8%E9%9D%A2%E6%8F%AD%E7%A7%98/" title="Redis网络模型全面揭秘">Redis网络模型全面揭秘</a><time datetime="2023-08-08T03:29:32.000Z" title="发表于 2023-08-08 11:29:32">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/" title="彻底弄懂Redis的内存策略">彻底弄懂Redis的内存策略</a><time datetime="2023-08-08T03:05:02.000Z" title="发表于 2023-08-08 11:05:02">2023-08-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://hakaimg.com/i/2022/08/08/nytkjo.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 小白菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到小白菜的blog~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>