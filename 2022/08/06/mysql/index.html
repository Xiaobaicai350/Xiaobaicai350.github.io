<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>mysql | 是小白菜哦</title><meta name="keywords" content="mysql"><meta name="author" content="小白菜"><meta name="copyright" content="小白菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sql、DB、DBMS之间的关系   DB: DBMS: SQL:    DataBase（数据库，数据库实际上在硬盘上以文件的形式存在） DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer…） 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。	SQL属于高级语言。只要能看懂英">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://example.com/2022/08/06/mysql/index.html">
<meta property="og:site_name" content="是小白菜哦">
<meta property="og:description" content="sql、DB、DBMS之间的关系   DB: DBMS: SQL:    DataBase（数据库，数据库实际上在硬盘上以文件的形式存在） DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer…） 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。	SQL属于高级语言。只要能看懂英">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hakaimg.com/i/2022/08/11/xhvqca.jpg">
<meta property="article:published_time" content="2022-08-06T06:53:21.000Z">
<meta property="article:modified_time" content="2023-03-14T11:26:53.999Z">
<meta property="article:author" content="小白菜">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hakaimg.com/i/2022/08/11/xhvqca.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/132124.png"><link rel="canonical" href="http://example.com/2022/08/06/mysql/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-14 19:26:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://hakaimg.com/i/2022/08/11/xhvqca.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">是小白菜哦</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-06T06:53:21.000Z" title="发表于 2022-08-06 14:53:21">2022-08-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-14T11:26:53.999Z" title="更新于 2023-03-14 19:26:53">2023-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="sql、DB、DBMS之间的关系"><a href="#sql、DB、DBMS之间的关系" class="headerlink" title="sql、DB、DBMS之间的关系"></a>sql、DB、DBMS之间的关系</h1><table>
<thead>
<tr>
<th>DB:</th>
<th>DBMS:</th>
<th>SQL:</th>
</tr>
</thead>
<tbody><tr>
<td>DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）</td>
<td>DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer…）</td>
<td>结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。<br/>	SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。<br/>	SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。）</td>
</tr>
</tbody></table>
<p>DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。<br>DBMS -(执行)-&gt; SQL -(操作)-&gt; DB</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><strong>表：table</strong></p>
<p>表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</p>
<p>一个表包括行和列：<br>    行：被称为数据&#x2F;记录(data)<br>    列：被称为字段(column)</p>
<pre><code>学号(int)	   姓名(varchar)	  年龄(int)
------------------------------------
110			张三				20
120			李四				21
</code></pre>
<p>每一个字段应该包括哪些属性？<br>字段名、数据类型、相关的约束。</p>
<h1 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h1><p>DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。<br>DML（数据操作语言）：insert delete update，对<strong>表当中的数据</strong>进行增删改。<br>DDL（数据定义语言）：create drop alter，对<strong>表结构</strong>的增删改。<br>TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)<br>DCL（数据控制语言）: grant授权、revoke撤销权限等。</p>
<h1 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h1><pre><code>第一步：登录mysql数据库管理系统
    dos命令窗口：
        mysql -uroot -p333
第二步：查看有哪些数据库
    show databases; (这个不是SQL语句，属于MySQL的命令。)
第三步：创建属于我们自己的数据库
    create database bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
第四步：使用bjpowernode数据
    use bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
第五步：查看当前使用的数据库中有哪些表？
    show tables; (这个不是SQL语句，属于MySQL的命令。)
第六步：初始化数据（导入外部数据）
    mysql&gt; source D:\course\05-MySQL\resources\bjpowernode.sql（这个是外部数据的地址）
</code></pre>
<h1 id="sql脚本"><a href="#sql脚本" class="headerlink" title="sql脚本"></a>sql脚本</h1><p>bjpowernode.sql，这个文件以sql结尾，这样的文件被称为“sql脚本”。什么是sql脚本呢？</p>
<p>​	当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。<br>​	注意：直接使用source命令可以执行sql脚本。</p>
<p><strong>格式</strong></p>
<p><strong>mysql&gt;source (sql脚本的绝对路径)</strong></p>
<p>​	sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。</p>
<h1 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h1><p>drop database 数据库名;</p>
<h1 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h1><p>desc 表名;</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p> select database(); 查看当前使用的是哪个数据库</p>
<p>select version(); 查看mysql的版本号。</p>
<p>\c   命令，结束一条语句。</p>
<p>exit 命令，退出mysql。</p>
<h1 id="简单的查询语句（DQL）"><a href="#简单的查询语句（DQL）" class="headerlink" title="简单的查询语句（DQL）"></a>简单的查询语句（DQL）</h1><p>语法格式：<br>    select 字段名1,字段名2,字段名3,…. from 表名;</p>
<p>提示：<br>    1、任何一条sql语句以“;”结尾。<br>    2、sql语句不区分大小写。</p>
<p><strong>查询员工的年薪？</strong>（字段可以参与数学运算。）<br>select ename,sal * 12 from emp;</p>
<p> <strong>给查询结果的列 重命名？</strong><br>    select ename,sal * 12 as yearsal from emp;<br><strong>别名中有中文，但是需要单引号括起来，（实测不用单引号仍然可以使用）</strong><br>    select ename,sal * 12 as 年薪 from emp; &#x2F;&#x2F; 错误<br>    select ename,sal * 12 as ‘年薪’ from emp;<br>    注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。	<br><strong>as关键字可以省略</strong>（可以 加一个空格）<br>    mysql&gt; select empno,ename,sal * 12 yearsal from emp;</p>
<p><strong>查询所有字段？</strong><br>    select * from emp; &#x2F;&#x2F; 实际开发中不建议使用*，效率较低。</p>
<p>SELECT 查询还可以对常数进行查询。</p>
<p>对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的 取值是我们指定的，而不是从数据表中动态取出的。 </p>
<p>你可能会问为什么我们还要对常数进行查询呢？</p>
<p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个 固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。 </p>
<p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个 字段固定值为“尚硅谷”，可以这样写：</p>
<p><img src="/../pic/image-20220821180052400.png" alt="image-20220821180052400"></p>
<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><p>​	语法格式：<br>​		select<br>​			字段,字段…<br>​		from<br>​			表名<br>​		where<br>​			条件;</p>
<p>执行顺序：先from，然后where，最后select</p>
<h2 id="等于-x3D"><a href="#等于-x3D" class="headerlink" title="等于&#x3D;"></a>等于&#x3D;</h2><p>查询工资等于5000的员工姓名？<br>        select ename from emp where sal &#x3D; 5000;</p>
<p>查询SMITH的工资？<br>        select sal from emp where ename &#x3D; ‘SMITH’; &#x2F;&#x2F; 字符串使用单引号括起来。</p>
<p>找出工资高于3000的员工？<br>        select ename,sal from emp where sal &gt; 3000;</p>
<hr>
<p>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</p>
<p>在使用等号运算符时，遵循如下规则：</p>
<ul>
<li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li>
<li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li>
</ul>
<p>对比：SQL中赋值符号使用 :&#x3D; </p>
<p><img src="/../pic/image-20220821183832846.png" alt="image-20220821183832846"></p>
<p><img src="/../pic/image-20220821183838126.png" alt="image-20220821183838126"></p>
<p>#查询salary&#x3D;10000，注意在Java中比较是&#x3D;&#x3D; </p>
<p>SELECT employee_id,salary FROM employees WHERE salary &#x3D; 10000;</p>
<h2 id="不等于！-lt-gt"><a href="#不等于！-lt-gt" class="headerlink" title="不等于！&lt;&gt;"></a>不等于！&lt;&gt;</h2><p>找出工资不等于3000的？<br>        select ename,sal from emp where sal &lt;&gt; 3000;<br>        select ename,sal from emp where sal !&#x3D; 3000;</p>
<h2 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h2><p>找出工资在1100和3000之间的员工，包括1100和3000？<br>        select ename,sal from emp where sal &gt;&#x3D; 1100 and sal &lt;&#x3D; 3000;<br>        select ename,sal from emp where sal between 1100 and 3000; &#x2F;&#x2F; between…and…是闭区间 [1100 ~ 3000]</p>
<p>​		select ename,sal from emp where sal between 3000 and 1100; &#x2F;&#x2F; 查询不到任何数据</p>
<p><em>between and在使用的时候必须左小右大。</em></p>
<p>between and除了可以使用在数字方面之外，还可以使用在字符串方面。<br>        select ename from emp where ename between ‘A’ and ‘C’;</p>
<h2 id="为null"><a href="#为null" class="headerlink" title="为null"></a>为null</h2><p><strong>找出哪些人津贴为NULL？</strong><br>            在数据库当中NULL不是一个值，代表什么也没有，为空。<br>            空不是一个值，不能用等号衡量。<br>            必须使用 is null或者is not null</p>
<p>select ename,sal,comm from emp where comm is null;</p>
<h2 id="不是is-not"><a href="#不是is-not" class="headerlink" title="不是is not"></a>不是is not</h2><p>找出哪些人津贴不为NULL？<br>            select ename,sal,comm from emp where comm is not null;</p>
<p>找出哪些人没有津贴？<br>            select ename,sal,comm from emp where comm is null or comm &#x3D; 0;</p>
<h2 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a><strong>逻辑非运算符</strong></h2><p>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；</p>
<p>当给定的值为NULL时，返回NULL。</p>
<p><img src="/../pic/image-20220821194142737.png" alt="image-20220821194142737"></p>
<h2 id="逻辑与运算符"><a href="#逻辑与运算符" class="headerlink" title="逻辑与运算符"></a><strong>逻辑与运算符</strong></h2><p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为<strong>非0值</strong>，并且都<strong>不为NULL</strong>时，返回</p>
<p>1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p>
<p><img src="/../pic/image-20220821195255884.png" alt="image-20220821195255884"></p>
<h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>找出工作岗位是MANAGER和SALESMAN的员工？<br>            select ename,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’;</p>
<p>and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。<br>            select ename,sal,deptno from emp where sal &gt; 1000 and deptno &#x3D; 20 or deptno &#x3D; 30; &#x2F;&#x2F; 错误的<br>            select ename,sal,deptno from emp where sal &gt; 1000 and (deptno &#x3D; 20 or deptno &#x3D; 30); &#x2F;&#x2F; 正确的。<br>            注意：当运算符的优先级不确定的时候加小括号。</p>
<p>注意：</p>
<p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合</p>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>in等同于or：找出工作岗位是MANAGER和SALESMAN的员工？<br>            select ename,job from emp where job &#x3D; ‘SALESMAN’ or job &#x3D; ‘MANAGER’;<br>            select ename,job from emp where job in(‘SALESMAN’, ‘MANAGER’)；</p>
<p>​			select ename,job from emp where sal in(800, 5000); &#x2F;&#x2F; in后面的值不是区间，是具体的值。</p>
<p><img src="/../pic/image-20220822103332755.png" alt="image-20220822103332755"></p>
<h2 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h2><p>not in: 不在这几个值当中。<br>            select ename,job from emp where sal not in(800, 5000);</p>
<h2 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h2><p>​			找出名字当中含有O的？<br>​				（在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是_）<br>​				%代表任意多个字符，_代表任意1个字符。<br>​				select ename from emp where ename like ‘%O%’;</p>
<p>找出名字中第二个字母是A的？<br>                select ename from emp where ename like ‘_A%’;</p>
<p>找出名字中有下划线的？</p>
<p>select name from t_user where name like ‘%_%’;（这样是错误的）</p>
<p>需要转义字符</p>
<p>select name from t_user where name like ‘%\_%’;</p>
<p>找出名字中最后一个字母是T的？<br>                select ename from emp where ename like ‘%T’;</p>
<h2 id="REGEXP运算符"><a href="#REGEXP运算符" class="headerlink" title="REGEXP运算符"></a>REGEXP运算符</h2><p>REGEXP运算符用来匹配字符串，语法格式为： expr REGEXP 匹配条件 。如果expr满足匹配条件，返回1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）‘^’匹配以该字符后面的字符开头的字符串。 </span><br><span class="line">（2）‘$’匹配以该字符前面的字符结尾的字符串。 </span><br><span class="line">（3）‘.’匹配任何一个单字符。 </span><br><span class="line">（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。 </span><br><span class="line">（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字， 而“*”匹配任何数量的任何字符。</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220821193852253.png" alt="image-20220821193852253"></p>
<h1 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h1><p>按照工资升序，找出员工名和薪资？<br>    select<br>        ename,sal<br>    from<br>        emp<br>    order by<br>        sal;</p>
<p>注意：默认是升序。怎么指定升序或者降序呢？asc表示升序，desc表示降序。<br>    select ename , sal from emp order by sal; &#x2F;&#x2F; 升序<br>    select ename , sal from emp order by sal asc; &#x2F;&#x2F; 升序<br>    select ename , sal from emp order by sal desc; &#x2F;&#x2F; 降序。</p>
<p>按照工资的降序排列，当工资相同的时候再按照名字的升序排列。<br>    select ename,sal from emp order by sal desc;<br>    select ename,sal from emp order by sal desc , ename asc;<br>    注意：<strong>越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段</strong>。</p>
<p>找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。<br>    select<br>        ename,job,sal<br>    from<br>        emp<br>    where<br>        job &#x3D; ‘SALESMAN’<br>    order by<br>        sal desc;</p>
<h1 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h1><p>什么是单行处理函数？<br>        输入一行，输出一行。</p>
<p>计算每个员工的年薪？<br>        select ename,(sal+comm)<em>12 as yearsal from emp;<br>        重点：*<em>所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。</em></em></p>
<h2 id="now"><a href="#now" class="headerlink" title="now"></a>now</h2><p>可以获取系统的当前时间</p>
<h2 id="ifnull"><a href="#ifnull" class="headerlink" title="ifnull"></a>ifnull</h2><p>​		使用ifnull函数：<br>​		select ename,(sal+ifnull(comm,0))12 as yearsal from emp;</p>
<p>ifnull() 空处理函数？<br>        ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。<br>        select ename,ifnull(comm,0) as comm from emp；</p>
<p>ifnull函数的用法ifnull（数据，被当作哪个值）</p>
<p>如果“数据”为null的时候，把这个数据结构当作哪个值</p>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>格式化数字 ：format(数字，’格式’)</p>
<p>select ename ,format(sal,’$999,999’)as sal from emp</p>
<h2 id="str-to-data"><a href="#str-to-data" class="headerlink" title="str_to_data"></a>str_to_data</h2><table>
<thead>
<tr>
<th>MySQL日期格式</th>
</tr>
</thead>
<tbody><tr>
<td>%Y   年</td>
</tr>
<tr>
<td>%m  月</td>
</tr>
<tr>
<td>%d  日</td>
</tr>
<tr>
<td>%h 时</td>
</tr>
<tr>
<td>%i 分</td>
</tr>
<tr>
<td>%s 秒</td>
</tr>
</tbody></table>
<p>将字符串varchar类型转换乘date类型</p>
<p>str_to_data(‘字符串日期’,‘日期格式’)</p>
<p>如果你提供的日期字符串是这个格式，str_to_data函数就不需要啦，也就是说直接在插入的时候就是这个格式’2003-01-12’这个格式，会进行自动类型转换</p>
<h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a>date_format</h2><p>将data类型转换成具有一定格式的varchar字符串类型</p>
<p>data_format（日期类型数据，’日期格式’） 通常在查询日期时使用</p>
<p>select id,name,data_format(birth,’%m&#x2F;%d&#x2F;%Y’)as birth from t_user;</p>
<p><img src="/../pic/image-20220418224249555.png" alt="image-20220418224249555"></p>
<h1 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h1><p>分组函数还有另一个名字：多行处理函数。<br>    多行处理函数的特点：输入多行，最终输出的结果是1行。	</p>
<p>​	count 计数<br>​	sum 求和<br>​	avg 平均值<br>​	max 最大值<br>​	min 最小值</p>
<p><strong>所有的分组函数都是对“某一组”数据进行操作的，分组函数在使用的时候必须先进行分组，然后才能使用</strong></p>
<p><strong>如果没有对数据进行分组整张表默认为一组</strong></p>
<p>找出工资总和？<br>    select sum(sal) from emp;<br>找出最高工资？<br>    select max(sal) from emp;<br>找出最低工资？<br>    select min(sal) from emp;<br>找出平均工资？<br>    select avg(sal) from emp;<br>找出总人数？<br>    select count(*) from emp;<br>    select count(ename) from emp;</p>
<p>分组函数一共5个。</p>
<p><strong>分组函数自动忽略NULL。</strong></p>
<p><font color="red"><strong>分组函数不能直接使用在where子句中</strong></font></p>
<p>select ename,sal from emp where sal &gt; avg(sal); &#x2F;&#x2F;ERROR 1111 (HY000): Invalid use of group function<br>            思考以上的错误信息：无效的使用了分组函数？<br>                原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why????<br>                怎么解释？<br>                    因为group by是在where执行之后才会执行的。</p>
<p>为什么select sum（comm）from emp 可以用</p>
<p>因为默认分为了一张表，select最后执行，已经分好组了</p>
<p>count(*)和count(具体的某个字段)，他们有什么区别？<br>    count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关），可以算上null</p>
<p>因为每一行记录不可能都为null，一列数据中有一列不为null，则这行数据就是有效的</p>
<p>​	count(comm): 表示统计comm字段中不为NULL的数据总数量。</p>
<p><strong>分组函数也能组合起来用：</strong><br>    select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;  </p>
<p>找出工资高于平均工资的员工？<br>        第一步：找出平均工资<br>            select avg(sal) from emp;</p>
<p>第二步：找出高于平均工资的员工<br>            select ename,sal from emp where sal &gt; 2073.214286;</p>
<p>select ename,sal from emp where sal &gt; (select avg(sal) from emp);</p>
<h1 id="group-by-和-having"><a href="#group-by-和-having" class="headerlink" title="group by 和 having"></a>group by 和 having</h1><p>group by ： 按照某个字段或者某些字段进行分组。<br>    having : having是对分组之后的数据进行再次过滤。但是having不能单独使用</p>
<p>where和having的区别，where是筛选出来再分组，having是分组之后再筛选</p>
<p><strong>having不可以单独使用</strong></p>
<p>优化策略：where和having，优先选择where，where实在完成不了了，再使用having  </p>
<p>找出每个工作岗位的最高薪资。<br>    select max(sal),job from emp group by job;</p>
<p>注意：分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。<br>    &#x3D;&#x3D;<strong>并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。</strong>&#x3D;&#x3D;<br>    当一条sql语句没有group by的话，整张表的数据会自成一组。</p>
<p>select ename,max(sal),job from emp group by job;<br>以上在mysql当中，查询结果是有的，但是结果没有意义，在Oracle数据库当中会报错。语法错误。<br>Oracle的语法规则比MySQL语法规则严谨。<br>记住一个规则<strong>：当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段(就是根据某个字段分组那个字段)</strong></p>
<p>每个工作岗位的平均薪资？<br>    select job,avg(sal) from emp group by job;</p>
<p>多个字段能不能联合起来一块分组？</p>
<p>​	案例：找出每个部门不同工作岗位的最高薪资。<br>​	</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	deptno,job,<span class="built_in">max</span>(sal)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	deptno,job;</span><br></pre></td></tr></table></figure>

<p>技巧：两个字段联合分组（在分组中分组）也就是套娃</p>
<p><strong>找出每个部门的最高薪资，要求显示薪资大于2900的数据。</strong></p>
<p>​	第一步：找出每个部门的最高薪资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(sal),deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>

<p>第二步：找出薪资大于2900</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(sal),deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="built_in">max</span>(sal) <span class="operator">&gt;</span> <span class="number">2900</span>; # 这种方式效率低。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(sal),deptno <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> <span class="number">2900</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno;  #效率较高，建议能够使用<span class="keyword">where</span>过滤的尽量使用<span class="keyword">where</span>。</span><br></pre></td></tr></table></figure>

<p>找出每个部门的平均薪资，要求显示薪资大于2000的数据。</p>
<p>第一步：找出每个部门的平均薪资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>

<p>第二步：要求显示薪资大于2000的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="built_in">avg</span>(sal) <span class="operator">&gt;</span> <span class="number">2000</span>;	</span><br></pre></td></tr></table></figure>

<p>where后面不能使用分组函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="built_in">avg</span>(sal) <span class="operator">&gt;</span> <span class="number">2000</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno;	<span class="operator">/</span><span class="operator">/</span> 错误了。</span><br></pre></td></tr></table></figure>

<p>这种情况只能使用having过滤。</p>
<h2 id="WITH-ROLLUP关键字"><a href="#WITH-ROLLUP关键字" class="headerlink" title="WITH ROLLUP关键字"></a>WITH ROLLUP关键字</h2><p><img src="/../pic/image-20220821205811597.png" alt="image-20220821205811597"></p>
<p>注意：</p>
<p>&#x3D;&#x3D;使用 WITH ROLLUP，此函数是对聚合函数进行求和，注意 with rollup是对 group by 后的<strong>第一个字段</strong>，进行分组求和。&#x3D;&#x3D;</p>
<h1 id="一个完整的DQL语句怎么写"><a href="#一个完整的DQL语句怎么写" class="headerlink" title="一个完整的DQL语句怎么写"></a>一个完整的DQL语句怎么写</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	select		5</span><br><span class="line">​		..</span><br><span class="line">​	from			1	</span><br><span class="line">​		..</span><br><span class="line">​	where			2</span><br><span class="line">​		..</span><br><span class="line">​	group by		3</span><br><span class="line">​		..</span><br><span class="line">​	having		4</span><br><span class="line">​		..</span><br><span class="line">​	order by		6</span><br><span class="line">​		..</span><br></pre></td></tr></table></figure>



<h1 id="查询结果集的去重（distinct）"><a href="#查询结果集的去重（distinct）" class="headerlink" title="查询结果集的去重（distinct）"></a>查询结果集的去重（distinct）</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> job <span class="keyword">from</span> emp; # <span class="keyword">distinct</span>关键字去除重复记录。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ename,<span class="keyword">distinct</span> job <span class="keyword">from</span> emp; # 这个<span class="keyword">sql</span>语句是错误的。</span><br></pre></td></tr></table></figure>

<p>记住：<strong>distinct只能出现在所有字段的最前面</strong>（所有记录联合起来去重复记录）</p>
<p>统计岗位的数量？<br>select count(distinct job) from emp;</p>
<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>​	在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。<br>​	在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。</p>
<h2 id="连接查询的分类"><a href="#连接查询的分类" class="headerlink" title="连接查询的分类"></a>连接查询的分类</h2><p>​	根据语法出现的年代来划分的话，包括：<br>​		SQL92（一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员）<br>​		SQL99（比较新的语法）<br>​	</p>
<p>根据表的连接方式来划分，包括：<br>    内连接：<br>        等值连接<br>        非等值连接<br>        自连接<br>    外连接：<br>        左外连接（左连接）<br>        右外连接（右连接）<br>    全连接（这个不讲，很少用！）</p>
<h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）</p>
<p>笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</p>
<p>关于表的别名：<br>    select </p>
<p>​		e.ename,d.dname </p>
<p>​		from emp e,dept d;<br>​	表的别名有什么好处？<br>​		第一：执行效率高。<br>​		第二：可读性好。</p>
<p>怎么避免笛卡尔积现象？当然是加条件进行过滤。<br>思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？<br>    不会，次数还是那么多次。只不过显示的是有效记录。</p>
<p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。<br>    select	<br>        e.ename,d.dname<br>    from<br>        emp e , dept d<br>    where<br>        e.deptno &#x3D; d.deptno; &#x2F;&#x2F;SQL92，以后不用。</p>
<h1 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h1><h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><p>等值连接：最大特点是：条件是等量关系。</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on</span><br><span class="line">		e.deptno = d.deptno;</span><br></pre></td></tr></table></figure>

<p>案例：查询每个员工的部门名称，要求显示员工名和部门名。</p>
<p>SQL92:（太老，不用了）</p>
<p>SQL92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放在了where后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e, dept d</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

<p>SQL99：（常用的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">		e.ename,d.dname</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		emp e</span><br><span class="line">	<span class="keyword">join</span></span><br><span class="line">		dept d</span><br><span class="line">	<span class="keyword">on</span></span><br><span class="line">		e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; inner可以省略的，带着inner目的是可读性好一些。（这两个是等价的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>





<p>sql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	A</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	B</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	连接条件</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	筛选条件</span><br></pre></td></tr></table></figure>

<p>SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。</p>
<p>sql92:使用(+)创建连接(这个了解就行)</p>
<p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。 Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p>
<h2 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h2><p>最大的特点是：连接条件中的关系是非等量关系。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。<br>select ename,sal from emp;<br>+——–+———+<br>| ename  | sal     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| ALLEN  | 1600.00 |<br>| WARD   | 1250.00 |<br>| JONES  | 2975.00 |<br>| MARTIN | 1250.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| SCOTT  | 3000.00 |<br>| KING   | 5000.00 |<br>| TURNER | 1500.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| FORD   | 3000.00 |<br>| MILLER | 1300.00 |<br>+——–+———+</p>
<p>mysql&gt; select * from salgrade; s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; inner可以省略</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SMITH  |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>最大的特点是：<strong>一张表看做两张表</strong>。自己连接自己。</p>
<p>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。<br> select empno,ename,mgr from emp;<br>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+<br>emp b 领导表<br>+——-+——–+<br>| empno | ename  |<br>+——-+——–+<br>|  7566 | JONES  |<br>|  7698 | BLAKE  |<br>|  7782 | CLARK  |<br>|  7788 | SCOTT  |<br>|  7839 | KING   |<br>|  7902 | FORD   |<br>+——-+——–+</p>
<p>员工的领导编号 &#x3D; 领导的员工编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="keyword">as</span> <span class="string">&#x27;员工名&#x27;</span>,b.ename <span class="keyword">as</span> <span class="string">&#x27;领导名&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;<span class="operator">/</span><span class="operator">/</span>员工的领导编号等于领导的编号</span><br></pre></td></tr></table></figure>

<p>+——–+——–+<br>| 员工名 | 领导名 |<br>+——–+——–+<br>| SMITH  | FORD   |<br>| ALLEN  | BLAKE  |<br>| WARD   | BLAKE  |<br>| JONES  | KING   |<br>| MARTIN | BLAKE  |<br>| BLAKE  | KING   |<br>| CLARK  | KING   |<br>| SCOTT  | JONES  |<br>| TURNER | BLAKE  |<br>| ADAMS  | SCOTT  |<br>| JAMES  | BLAKE  |<br>| FORD   | JONES  |<br>| MILLER | CLARK  |<br>+——–+——–+</p>
<p>没有king</p>
<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><p>​	<br>什么是外连接，和内连接有什么区别？</p>
<p>内连接：<br>    假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。<br>    AB两张表没有主副之分，两张表是平等的。</p>
<p>外连接：<br>    假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中<br>    的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p>
<p>外连接的分类？<br>    左外连接（左连接）：表示左边的这张表是主表。<br>    右外连接（右连接）：表示右边的这张表是主表。</p>
<p>​	左连接有右连接的写法，右连接也会有对应的左连接的写法。</p>
<p>案例：找出每个员工的上级领导？（所有员工必须全部查询出来。）</p>
<p>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+<br>emp b 领导表<br>+——-+——–+<br>| empno | ename  |<br>+——-+——–+<br>|  7566 | JONES  |<br>|  7698 | BLAKE  |<br>|  7782 | CLARK  |<br>|  7788 | SCOTT  |<br>|  7839 | KING   |<br>|  7902 | FORD   |<br>+——-+——–+</p>
<p>内连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>外连接：（左外连接&#x2F;左连接）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span><span class="operator">/</span><span class="operator">/</span><span class="keyword">left</span>代表将<span class="keyword">join</span>关键字左边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着查询右边的表</span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; join前面的outer是可以省略的。带着可读性强</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>外连接：（右外连接&#x2F;右连接）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; outer可以省略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>+——–+——-+<br>| 员工      | 领导    |<br>+——–+——-+<br>| SMITH  | FORD  |<br>| ALLEN  | BLAKE |<br>| WARD   | BLAKE |<br>| JONES  | KING  |<br>| MARTIN | BLAKE |<br>| BLAKE  | KING  |<br>| CLARK  | KING  |<br>| SCOTT  | JONES |<br>| KING   | NULL  |<br>| TURNER | BLAKE |<br>| ADAMS  | SCOTT |<br>| JAMES  | BLAKE |<br>| FORD   | JONES |<br>| MILLER | CLARK |<br>+——–+——-+</p>
<p>外连接最重要的特点是：主表的数据无条件的全部查询出来。</p>
<p>案例：找出哪个部门没有员工？<br>EMP表<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>DEPT<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	e.empno <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h2 id="三张表连接查询"><a href="#三张表连接查询" class="headerlink" title="三张表连接查询"></a>三张表连接查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	A</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	B</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">    A和B的连接条件</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	C</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	A和C的连接条件</span><br></pre></td></tr></table></figure>

<p>一条sql中内连接和外连接可以混合，都可以出现</p>
<p>案例：找出每一个员工的部门名称以及工资等级。<br>EMP e<br>+——-+——–+———+——–+<br>| empno | ename  | sal     | deptno |<br>+——-+——–+———+——–+<br>|  7369 | SMITH  |  800.00 |     20 |<br>|  7499 | ALLEN  | 1600.00 |     30 |<br>|  7521 | WARD   | 1250.00 |     30 |<br>|  7566 | JONES  | 2975.00 |     20 |<br>|  7654 | MARTIN | 1250.00 |     30 |<br>|  7698 | BLAKE  | 2850.00 |     30 |<br>|  7782 | CLARK  | 2450.00 |     10 |<br>|  7788 | SCOTT  | 3000.00 |     20 |<br>|  7839 | KING   | 5000.00 |     10 |<br>|  7844 | TURNER | 1500.00 |     30 |<br>|  7876 | ADAMS  | 1100.00 |     20 |<br>|  7900 | JAMES  |  950.00 |     30 |<br>|  7902 | FORD   | 3000.00 |     20 |<br>|  7934 | MILLER | 1300.00 |     10 |<br>+——-+——–+———+——–+<br>DEPT d<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+<br>SALGRADE s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+ </p>
<p>表示：A表和B表先进行表连接，连接之后A表继续和C表进行连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>+——–+————+——-+<br>| ename  | dname      | grade |<br>+——–+————+——-+<br>| SMITH  | RESEARCH   |     1 |<br>| ALLEN  | SALES      |     3 |<br>| WARD   | SALES      |     2 |<br>| JONES  | RESEARCH   |     4 |<br>| MARTIN | SALES      |     2 |<br>| BLAKE  | SALES      |     4 |<br>| CLARK  | ACCOUNTING |     4 |<br>| SCOTT  | RESEARCH   |     4 |<br>| KING   | ACCOUNTING |     5 |<br>| TURNER | SALES      |     3 |<br>| ADAMS  | RESEARCH   |     1 |<br>| JAMES  | SALES      |     1 |<br>| FORD   | RESEARCH   |     4 |<br>| MILLER | ACCOUNTING |     2 |<br>+——–+————+——-+</p>
<p>案例：找出每一个员工的部门名称、工资等级、以及上级领导。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename <span class="string">&#x27;员工&#x27;</span>,d.dname,s.grade,e1.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span><span class="operator">/</span><span class="operator">/</span>注意这个<span class="keyword">left</span></span><br><span class="line">	emp e1</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.mgr <span class="operator">=</span> e1.empno;</span><br></pre></td></tr></table></figure>



<p>+——–+————+——-+——-+<br>| 员工      | dname      | grade | 领导    |<br>+——–+————+——-+——-+<br>| SMITH  | RESEARCH   |     1 | FORD  |<br>| ALLEN  | SALES      |     3 | BLAKE |<br>| WARD   | SALES      |     2 | BLAKE |<br>| JONES  | RESEARCH   |     4 | KING  |<br>| MARTIN | SALES      |     2 | BLAKE |<br>| BLAKE  | SALES      |     4 | KING  |<br>| CLARK  | ACCOUNTING |     4 | KING  |<br>| SCOTT  | RESEARCH   |     4 | JONES |<br>| KING   | ACCOUNTING |     5 | NULL  |<br>| TURNER | SALES      |     3 | BLAKE |<br>| ADAMS  | RESEARCH   |     1 | SCOTT |<br>| JAMES  | SALES      |     1 | BLAKE |<br>| FORD   | RESEARCH   |     4 | JONES |<br>| MILLER | ACCOUNTING |     2 | CLARK |<br>+——–+————+——-+——-+</p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>​	<strong>select语句当中嵌套select语句，被嵌套的select语句是子查询。</strong></p>
<p>思路：<strong>把查询到的结果也当成一张新表</strong></p>
<p>​	子查询可以出现在哪里？<br>​			这三个位置都是可以的</p>
<p>​	</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">		..(<span class="keyword">select</span>).</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		..(<span class="keyword">select</span>).</span><br><span class="line">	<span class="keyword">where</span></span><br><span class="line">		..(<span class="keyword">select</span>).</span><br></pre></td></tr></table></figure>



<h2 id="where子句中使用子查询"><a href="#where子句中使用子查询" class="headerlink" title="where子句中使用子查询"></a>where子句中使用子查询</h2><p>案例：找出高于平均薪资的员工信息。<br>select * from emp where sal &gt; avg(sal); &#x2F;&#x2F;错误的写法，where后面不能直接使用分组函数。</p>
<p>第一步：找出平均薪资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	+————-+<br>​	| avg(sal)    |<br>​	+————-+<br>​	| 2073.214286 |<br>​	+————-+</p>
</blockquote>
<p>第二步：where过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where sal &gt; 2073.214286;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​	+——-+——-+———–+——+————+———+——+——–+<br>​	| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |<br>​	+——-+——-+———–+——+————+———+——+——–+<br>​	|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |<br>​	|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |<br>​	|  7782 | CLARK | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |<br>​	|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |<br>​	|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |<br>​	|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |<br>​	+——-+——-+———–+——+————+———+——+——–+</p>
</blockquote>
<p>第一步和第二步合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp);</span><br></pre></td></tr></table></figure>

<h2 id="from后面嵌套子查询"><a href="#from后面嵌套子查询" class="headerlink" title="from后面嵌套子查询"></a>from后面嵌套子查询</h2><p>案例：找出每个部门平均薪水的等级。<br>第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+————-+<br>| deptno | avgsal      |<br>+——–+————-+<br>|     10 | 2916.666667 |<br>|     20 | 2175.000000 |<br>|     30 | 1566.666667 |<br>+——–+————-+</p>
</blockquote>
<p>第二步：将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是：t.avgsal between s.losal and s.hisalz</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	t.<span class="operator">*</span>,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	(<span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno) t</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	t.avgsal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+————-+——-+<br>| deptno | avgsal      | grade |<br>+——–+————-+——-+<br>|     30 | 1566.666667 |     3 |<br>|     10 | 2916.666667 |     4 |<br>|     20 | 2175.000000 |     4 |<br>+——–+————-+——-+</p>
</blockquote>
<p>案例：找出每个部门平均的薪水等级。<br>第一步：找出每个员工的薪水等级。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.ename,e.sal,e.deptno,s.grade </span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">join</span> salgrade s </span><br><span class="line"><span class="keyword">on</span> e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+———+——–+——-+<br>| ename  | sal     | deptno | grade |<br>+——–+———+——–+——-+<br>| SMITH  |  800.00 |     20 |     1 |<br>| ALLEN  | 1600.00 |     30 |     3 |<br>| WARD   | 1250.00 |     30 |     2 |<br>| JONES  | 2975.00 |     20 |     4 |<br>| MARTIN | 1250.00 |     30 |     2 |<br>| BLAKE  | 2850.00 |     30 |     4 |<br>| CLARK  | 2450.00 |     10 |     4 |<br>| SCOTT  | 3000.00 |     20 |     4 |<br>| KING   | 5000.00 |     10 |     5 |<br>| TURNER | 1500.00 |     30 |     3 |<br>| ADAMS  | 1100.00 |     20 |     1 |<br>| JAMES  |  950.00 |     30 |     1 |<br>| FORD   | 3000.00 |     20 |     4 |<br>| MILLER | 1300.00 |     10 |     2 |<br>+——–+———+——–+——-+</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">第二步：基于以上结果，继续按照deptno分组，求grade平均值。</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.deptno,<span class="built_in">avg</span>(s.grade)</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	emp e </span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">	salgrade s </span><br><span class="line"><span class="keyword">on</span> </span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	e.deptno;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+————–+<br>| deptno | avg(s.grade) |<br>+——–+————–+<br>|     10 |       3.6667 |<br>|     20 |       2.8000 |<br>|     30 |       2.5000 |<br>+——–+————–+</p>
</blockquote>
<h2 id="在select后面嵌套子查询。"><a href="#在select后面嵌套子查询。" class="headerlink" title="在select后面嵌套子查询。"></a>在select后面嵌套子查询。</h2><p>（了解即可）</p>
<p>案例：找出每个员工所在的部门名称，要求显示员工名和部门名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

<p>这两个是等价的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,(<span class="keyword">select</span> d.dname <span class="keyword">from</span> dept d <span class="keyword">where</span> e.deptno <span class="operator">=</span> d.deptno) <span class="keyword">as</span> dname </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	emp e;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| SMITH  | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| JONES  | RESEARCH   |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| CLARK  | ACCOUNTING |<br>| SCOTT  | RESEARCH   |<br>| KING   | ACCOUNTING |<br>| TURNER | SALES      |<br>| ADAMS  | RESEARCH   |<br>| JAMES  | SALES      |<br>| FORD   | RESEARCH   |<br>| MILLER | ACCOUNTING |<br>+——–+————+</p>
</blockquote>
<h1 id="union-（可以将查询结果集合并）"><a href="#union-（可以将查询结果集合并）" class="headerlink" title="union （可以将查询结果集合并）"></a>union （可以将查询结果集合并）</h1><p>union的效率要高一些，对于表连接来说，每连接一次新表，则匹配的次数要成倍的翻</p>
<p>但是union可以减少匹配的次数，再减少匹配的次数的情况下，还可以完成两个结果集的拼接</p>
<p>案例：找出工作岗位是SALESMAN和MANAGER的员工？</p>
<p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+———-+<br>| ename  | job      |<br>+——–+———-+<br>| ALLEN  | SALESMAN |<br>| WARD   | SALESMAN |<br>| JONES  | MANAGER  |<br>| MARTIN | SALESMAN |<br>| BLAKE  | MANAGER  |<br>| CLARK  | MANAGER  |<br>| TURNER | SALESMAN |<br>+——–+———-+</p>
</blockquote>
<p>第三种：union</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,job <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> ename,job <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+———-+<br>| ename  | job      |<br>+——–+———-+<br>| JONES  | MANAGER  |<br>| BLAKE  | MANAGER  |<br>| CLARK  | MANAGER  |<br>| ALLEN  | SALESMAN |<br>| WARD   | SALESMAN |<br>| MARTIN | SALESMAN |<br>| TURNER | SALESMAN |<br>+——–+———-+</p>
</blockquote>
<p>两张不相干的表中的数据拼接在一起显示？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> dname <span class="keyword">from</span> dept;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+————+<br>| ename      |<br>+————+<br>| SMITH      |<br>| ALLEN      |<br>| WARD       |<br>| JONES      |<br>| MARTIN     |<br>| BLAKE      |<br>| CLARK      |<br>| SCOTT      |<br>| KING       |<br>| TURNER     |<br>| ADAMS      |<br>| JAMES      |<br>| FORD       |<br>| MILLER     |<br>| ACCOUNTING |<br>| RESEARCH   |<br>| SALES      |<br>| OPERATIONS |<br>+————+</p>
</blockquote>
<p>union在进行结果集合并的时候，要求两个结果的结果集的<strong>列数</strong>相同，数据结构的<strong>类型</strong>也要相同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">union</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> dname <span class="keyword">from</span> dept;</span><br><span class="line">ERROR <span class="number">1222</span> (<span class="number">21000</span>): The used <span class="keyword">SELECT</span> statements have a different number <span class="keyword">of</span> columns</span><br><span class="line">#翻译 ：使用的 <span class="keyword">SELECT</span> 语句具有不同的列数</span><br></pre></td></tr></table></figure>

<h1 id="limit-分页查询"><a href="#limit-分页查询" class="headerlink" title="limit (分页查询)"></a>limit (分页查询)</h1><p>limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum）</p>
<p>limit取结果集中的部分数据，这时它的作用。</p>
<p>&#x3D;&#x3D;MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。&#x3D;&#x3D;</p>
<h2 id="语法机制："><a href="#语法机制：" class="headerlink" title="语法机制："></a>语法机制：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit startIndex, length</span><br><span class="line">		# startIndex表示起始位置，从<span class="number">0</span>开始，<span class="number">0</span>表示第一条数据。</span><br><span class="line">		# length表示取几个</span><br><span class="line">	# 也可以limit lenth </span><br></pre></td></tr></table></figure>



<p>案例：取出工资前5名的员工（思路：降序取前5个）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>取前5个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> limit <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="limit是sql语句最后执行的-一个环节："><a href="#limit是sql语句最后执行的-一个环节：" class="headerlink" title="limit是sql语句最后执行的 一个环节："></a><strong>limit是sql语句最后执行的 一个环节</strong>：</h2><p>​	</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>		<span class="number">5</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">from</span>			<span class="number">1</span></span><br><span class="line">		...		</span><br><span class="line">	<span class="keyword">where</span>			<span class="number">2</span></span><br><span class="line">		...	</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span>		<span class="number">3</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">having</span>		<span class="number">4</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span>		<span class="number">6</span></span><br><span class="line">		...</span><br><span class="line">        limit			<span class="number">7</span></span><br><span class="line">        ...;</span><br></pre></td></tr></table></figure>

<p>案例：找出工资排名在第4到第9名的员工？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> limit <span class="number">3</span>,<span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>+——–+———+<br>​| ename  | sal     |<br>​+——–+———+<br>​| JONES  | 2975.00 |<br>​| BLAKE  | 2850.00 |<br>​| CLARK  | 2450.00 |<br>​| ALLEN  | 1600.00 |<br>​| TURNER | 1500.00 |<br>​| MILLER | 1300.00 |<br>​+——–+———+</p>
</blockquote>
<h2 id="通用的标准分页sql"><a href="#通用的标准分页sql" class="headerlink" title="通用的标准分页sql"></a>通用的标准分页sql</h2><p>每页显示3条记录：<br>第1页：0, 3<br>第2页：3, 3<br>第3页：6, 3<br>第4页：9, 3<br>第5页：12, 3</p>
<p>每页显示pageSize条记录：<br>第pageNo页：(pageNo - 1) * pageSize, pageSize</p>
<p>pageSize是什么？是每页显示多少条记录<br>pageNo是什么？显示第几页</p>
<p>java代码{<br>    int pageNo &#x3D; 2; &#x2F;&#x2F; 页码是2<br>    int pageSize &#x3D; 10; &#x2F;&#x2F; 每页显示10条</p>
<p>} </p>
<p><strong>公式为</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit (pageNo <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> pageSize, pageSize</span><br></pre></td></tr></table></figure>

<h1 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h1><p>表名在数据库当中一般建议以：<code>t_或者tbl_</code>开始。</p>
<h2 id="建表语句的语法格式"><a href="#建表语句的语法格式" class="headerlink" title="建表语句的语法格式"></a>建表语句的语法格式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">		字段名<span class="number">1</span> 数据类型,</span><br><span class="line">		字段名<span class="number">2</span> 数据类型,</span><br><span class="line">		字段名<span class="number">3</span> 数据类型,</span><br><span class="line">		....</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h2 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h2><p>关于MySQL当中字段的数据类型？以下只说常见的</p>
<blockquote>
<p>​	int		整数型(java中的int)最长11位<br>​	bigint	长整型(java中的long)<br>​	float		浮点型(java中的float double)最长255<br>​	char		定长字符串(String)最长255<br>​	varchar	可变长字符串(StringBuffer&#x2F;StringBuilder)<br>​	date		日期类型 （对应Java中的java.sql.Date类型）<br>​	BLOB		二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object）<br>​	CLOB		字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object）<br>​	……</p>
</blockquote>
<h3 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h3><p>char和varchar怎么选择？<br>    在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char。<br>    当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。</p>
<h2 id="date和datetime"><a href="#date和datetime" class="headerlink" title="date和datetime"></a>date和datetime</h2><p>date是短日期，只包含年月日信息</p>
<p>datetime是长日期，包括年月日时分秒信息</p>
<p><img src="/../pic/image-20220418225206478.png" alt="image-20220418225206478"></p>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><p>​	drop table 表名; &#x2F;&#x2F; 这个通用。<br>​	drop table if exists 表名; &#x2F;&#x2F; oracle不支持这种写法。</p>
<h1 id="insert语句插入数据"><a href="#insert语句插入数据" class="headerlink" title="insert语句插入数据"></a>insert语句插入数据</h1><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,字段名<span class="number">3</span>,....) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>,....)；</span><br></pre></td></tr></table></figure>

<p>​	要求：字段的数量和值的数量相同，并且数据类型要对应相同。<br>​	<strong>字段名和值要一一对应。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student(name) <span class="keyword">values</span>(<span class="string">&#x27;wangwu&#x27;</span>); <span class="operator">/</span><span class="operator">/</span> 除name字段之外，剩下的所有字段自动插入<span class="keyword">NULL</span>。</span><br></pre></td></tr></table></figure>

<p>需要注意的地方：<br>    当一条insert语句执行成功之后，表格当中必然会多一行记录。<br>    即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行<br>    insert语句插入数据了，只能使用update进行更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 字段可以省略不写，但是后面的<span class="keyword">value</span>对数量和顺序都有要求。</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;gaosan2ban&#x27;</span>,<span class="string">&#x27;1986-10-23&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;gaosan2ban&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1136</span> (<span class="number">21</span>S01): <span class="keyword">Column</span> count doesn<span class="string">&#x27;t match value count at row 1</span></span><br></pre></td></tr></table></figure>





<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 一次插入多行数据,用逗号隔开(最常用的方法)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student</span><br><span class="line">	(<span class="keyword">no</span>,name,sex,classno,birth) </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">	(<span class="number">3</span>,<span class="string">&#x27;rose&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;gaosi2ban&#x27;</span>,<span class="string">&#x27;1952-12-14&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;laotie&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;gaosi2ban&#x27;</span>,<span class="string">&#x27;1955-12-14&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="表的复制（快速创建表）"><a href="#表的复制（快速创建表）" class="headerlink" title="表的复制（快速创建表）"></a>表的复制（快速创建表）</h2><p>​	语法：<br>​		</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">as</span> <span class="keyword">select</span>语句;</span><br></pre></td></tr></table></figure>

<p>​		将查询结果当做表创建出来。 </p>
<p><img src="/../pic/image-20220822111644612.png" alt="image-20220822111644612"></p>
<h2 id="将查询结果插入到一张表中"><a href="#将查询结果插入到一张表中" class="headerlink" title="将查询结果插入到一张表中"></a>将查询结果插入到一张表中</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept;</span><br></pre></td></tr></table></figure>

<h1 id="修改数据：update"><a href="#修改数据：update" class="headerlink" title="修改数据：update"></a>修改数据：update</h1><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>





<p>字段名如果是中文也不需要加单引号，直接用就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 让字段的值在原来的基础上加1</span><br><span class="line"></span><br><span class="line">set (字段名)=(字段名)+1</span><br></pre></td></tr></table></figure>

<p>案例：将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHIBU</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> dept1 <span class="keyword">set</span> loc <span class="operator">=</span> <span class="string">&#x27;SHANGHAI&#x27;</span>, dname <span class="operator">=</span> <span class="string">&#x27;RENSHIBU&#x27;</span> <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">update</span> dept1 <span class="keyword">set</span> loc <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>, dname <span class="operator">=</span> <span class="string">&#x27;y&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>没有条件整张表数据全部更新。</strong></p>
<h1 id="删除数据：delete"><a href="#删除数据：delete" class="headerlink" title="删除数据：delete"></a>删除数据：delete</h1><p>​	语法格式：<br>​		</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;	</span><br></pre></td></tr></table></figure>

<p>注意：<strong>没有条件全部删除。</strong></p>
<p>删除部门号等于10的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> dept1 <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>删除所有记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> dept1;</span><br></pre></td></tr></table></figure>

<h2 id="快速删除表中的数据"><a href="#快速删除表中的数据" class="headerlink" title="快速删除表中的数据"></a>快速删除表中的数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> dept1    # 这种删除数据的方式比较慢</span><br></pre></td></tr></table></figure>

<p>delete 语句删除数据的原理是 表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放</p>
<p>这种删除的缺点是：删除效率比较低</p>
<p>这种删除的优点是：支持回滚，后悔了可以再恢复</p>
<h3 id="物理删除（快速）"><a href="#物理删除（快速）" class="headerlink" title="物理删除（快速）"></a>物理删除（快速）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;   # 表被截断，不可回滚。永久丢失。</span><br></pre></td></tr></table></figure>

<p>当我们想要清空某张表时，往往会使用truncate语句</p>
<p><strong>truncate截短的；被删节的</strong></p>
<p>truncate不能删除单条数据</p>
<p>delete属于dml </p>
<p>truncate 属于ddl</p>
<h1 id="对于表结构的修改"><a href="#对于表结构的修改" class="headerlink" title="对于表结构的修改"></a>对于表结构的修改</h1><p>使用工具完成即可，因为在实际开发中表一旦设计好之后，对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使<br>需要修改表结构，我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。<br>出现在java代码当中的sql包括：insert delete update select（这些都是表中的数据操作。）</p>
<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><p>CRUD操作<br>Create（增） Retrieve（检索） Update（修改） Delete（删除）</p>
<h1 id="约束-Constraint"><a href="#约束-Constraint" class="headerlink" title="约束(Constraint)"></a>约束(Constraint)</h1><p>​	在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的<br>​	合法性、有效性、完整性。</p>
<p>​	常见的约束<br>​		非空约束(not null)：约束的字段不能为NULL<br>​		唯一约束(unique)：约束的字段不能重复<br>​		主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）<br>​		外键约束(foreign key)：…（简称FK）<br>​		检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。</p>
<h2 id="非空约束-not-null"><a href="#非空约束-not-null" class="headerlink" title="非空约束 not null"></a>非空约束 not null</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,password) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1364</span> (HY000): Field <span class="string">&#x27;username&#x27;</span> doesn<span class="string">&#x27;t have a default value</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username,password) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;123&#x27;</span>);  # 这个是OK的</span><br></pre></td></tr></table></figure>

<h2 id="唯一性约束（unique）"><a href="#唯一性约束（unique）" class="headerlink" title="唯一性约束（unique）"></a>唯一性约束（unique）</h2><p>​	</p>
<p><strong>唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。</strong>（可以有多个null）</p>
<p>案例：给某一列添加unique</p>
<p>注意：not null约束只有列级约束。没有表级约束。</p>
<h3 id="联合唯一"><a href="#联合唯一" class="headerlink" title="联合唯一"></a>联合唯一</h3><p>新需求：name和email两个字段联合起来具有唯一性</p>
<p>需要这样子创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line"></span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span>(name,email)   # <span class="operator">*</span><span class="operator">*</span>约束没有添加到列的后面，这种约束被称为表级约束<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>name 和email联合起来唯一！</p>
<p><strong>什么时候使用表级约束呢</strong></p>
<p>需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束</p>
<p>在mysql种，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的<strong>身份证号码</strong>一样。）	</p>
<p>任何一张表都应该有主键。 </p>
<p>给一张表添加主键约束呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,  <span class="operator">/</span><span class="operator">/</span> 列级约束</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	email <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username,email) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zs&#x27;</span>,<span class="string">&#x27;zs@123.com&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username,email) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27;ls@123.com&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username,email) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;ww&#x27;</span>,<span class="string">&#x27;ww@123.com&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> email      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zs       <span class="operator">|</span> zs<span class="variable">@123</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> ls       <span class="operator">|</span> ls<span class="variable">@123</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> ww       <span class="operator">|</span> ww<span class="variable">@123</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username,email) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;jack@123.com&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username,email) <span class="keyword">values</span>(<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;jack@123.com&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1364</span> (HY000): Field <span class="string">&#x27;id&#x27;</span> doesn<span class="string">&#x27;t have a default value</span></span><br></pre></td></tr></table></figure>

<p>根据以上的测试得出：id是主键，因为添加了主键约束，主键字段中的数据不能为NULL，也不能重复。<br>主键的特点：不能为NULL，也不能重复。</p>
<ul>
<li><p>主键相关的术语？<br>主键约束 : primary key<br>主键字段 : id字段添加primary key之后，id叫做主键字段<br>主键值 : id字段中的每一个值都是主键值。</p>
</li>
<li><p>主键有什么作用？</p>
<ul>
<li>表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。</li>
<li>主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。）</li>
</ul>
</li>
<li><p>主键的分类？<br>根据主键字段的字段数量来划分：<br>单一主键（推荐的，常用的。）<br>复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）<br>根据主键性质来划分：<br>自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）<br>业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）<br>              最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。</p>
</li>
<li><p>一张表的主键约束只能有1个。（必须记住）</p>
</li>
<li><p>使用表级约束方式定义主键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	<span class="keyword">primary</span> key(id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zs&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;ls&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;cs&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,username) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;cx&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以下内容是演示以下复合主键，不需要掌握：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">		id <span class="type">int</span>,</span><br><span class="line">		username <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">		password <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">		<span class="keyword">primary</span> key(id,username)</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">insert</span> .......</span><br></pre></td></tr></table></figure>


</li>
<li><p>mysql提供主键值自增：（非常重要。）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key <span class="operator">*</span><span class="operator">*</span>auto_increment,<span class="operator">*</span><span class="operator">*</span> <span class="operator">/</span><span class="operator">/</span> id字段自动维护一个自增的数字，从<span class="number">1</span>开始，以<span class="number">1</span>递增。</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;b&#x27;</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(username) <span class="keyword">values</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user;</span><br></pre></td></tr></table></figure>

<p>提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。</p>
</li>
</ul>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ul>
<li><p>关于外键约束的相关术语：<br>外键约束: foreign key一种约束<br>外键字段：添加有外键约束的字段<br>外键值：外键字段中的每一个值。</p>
</li>
<li><p>业务背景：<br>请设计数据库表，用来维护学生和班级的信息？<br>第一种方案：一张表存储所有数据<br>​	no(pk)			name			classno			classname</p>
<p>​	1					zs1				101				北京大兴区经济技术开发区亦庄二中高三1班<br>​	2					zs2				101				北京大兴区经济技术开发区亦庄二中高三1班<br>​	3					zs3				102				北京大兴区经济技术开发区亦庄二中高三2班<br>​	4					zs4				102				北京大兴区经济技术开发区亦庄二中高三2班<br>​	5					zs5				102				北京大兴区经济技术开发区亦庄二中高三2班<br>​	缺点：冗余。【不推荐】</p>
<p>​	第二种方案：两张表（班级表和学生表）<br>​	t_class 班级表</p>
<p>​	cno(pk)		cname</p>
<p>​	101		北京大兴区经济技术开发区亦庄二中高三1班<br>​	102		北京大兴区经济技术开发区亦庄二中高三2班</p>
<p>​	t_student 学生表</p>
<p>​	sno(pk)		sname				classno(该字段添加外键约束fk)</p>
<p>​	1				zs1				101<br>​	2				zs2				101<br>​	3				zs3				102<br>​	4				zs4				102<br>​	5				zs5				102</p>
</li>
<li><p>将以上表的建表语句写出来：</p>
<p><strong>t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。</strong></p>
<p>子表用着父表的东西，所以要先删除子表</p>
<p>顺序要求：<br>删除数据的时候，先删除子表，再删除父表。<br>添加数据的时候，先添加父表，在添加子表。<br>创建表的时候，先创建父表，再创建子表。<br>删除表的时候，先删除子表，在删除父表。<br>外键也是有约束的：</p>
<p>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。</p>
<p><img src="/../pic/image-20220822120346613.png" alt="image-20220822120346613"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_student;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_class(</span><br><span class="line">	cno <span class="type">int</span>,</span><br><span class="line">	cname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	<span class="keyword">primary</span> key(cno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student(</span><br><span class="line">	sno <span class="type">int</span>,</span><br><span class="line">	sname <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	classno <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">primary</span> key(sno),</span><br><span class="line">	<span class="operator">*</span><span class="operator">*</span><span class="keyword">foreign</span> key(classno) <span class="keyword">references</span> t_class(cno)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_class <span class="keyword">values</span>(<span class="number">101</span>,<span class="string">&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_class <span class="keyword">values</span>(<span class="number">102</span>,<span class="string">&#x27;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zs1&#x27;</span>,<span class="number">101</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;zs2&#x27;</span>,<span class="number">101</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;zs3&#x27;</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;zs4&#x27;</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;zs5&#x27;</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;zs6&#x27;</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_class;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">103</span>);<span class="operator">/</span><span class="operator">/</span>没有这个班级</span><br><span class="line">ERROR <span class="number">1452</span> (<span class="number">23000</span>): Cannot <span class="keyword">add</span> <span class="keyword">or</span> <span class="keyword">update</span> a child <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`bjpowernode`.<span class="type">INT</span> `t_student_ibfk_1` <span class="keyword">FOREIGN</span> KEY (`classno`) <span class="keyword">REFERENCES</span> `t_class` (`cno`))<span class="operator">/</span><span class="operator">/</span>报错信息</span><br></pre></td></tr></table></figure>


</li>
<li><p>外键值可以为NULL？<br>外键可以为NULL。</p>
</li>
<li><p>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？<br>注意：被引用的字段不一定是主键，但至少具有unique约束。</p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>​	（整个内容属于了解内容）</p>
<p>​	存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，<br>​	就是“表的存储方式”）</p>
<p>​	mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。<br>​	每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p>
<p><img src="/../pic/image-20220419230054870.png" alt="image-20220419230054870"></p>
<p><img src="/../pic/image-20220419230038249.png" alt="image-20220419230038249"></p>
<p>2.1、完整的建表语句<br>    CREATE TABLE <code>t_x</code> (<br>      <code>id</code> int(11) DEFAULT NULL<br>    ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>​	注意：在MySQL当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。</p>
<p>​	建表的时候可以指定存储引擎，也可以指定字符集。</p>
<p>​	mysql默认使用的存储引擎是InnoDB方式。<br>​	默认采用的字符集是UTF8</p>
<h2 id="Engine-MyISAM"><a href="#Engine-MyISAM" class="headerlink" title="Engine: MyISAM"></a>Engine: MyISAM</h2><p>​			  Support: YES<br>​			  Comment: MyISAM storage engine<br>​		Transactions: NO<br>​					 XA: NO<br>​		  Savepoints: NO<br>​		<br>​		MyISAM这种存储引擎不支持事务。<br>​		MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。<br>​		MyISAM采用三个文件组织一张表：<br>​			xxx.frm（存储格式的文件）<br>​			xxx.MYD（存储表中数据的文件）<br>​			xxx.MYI（存储表中索引的文件）</p>
<p><strong>对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引</strong></p>
<p>​		优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。<br>​		缺点：不支持事务。</p>
<hr>
<h2 id="Engine-InnoDB"><a href="#Engine-InnoDB" class="headerlink" title="Engine: InnoDB"></a>Engine: InnoDB</h2><p>​			  Support: DEFAULT<br>​			  Comment: Supports transactions, row-level locking, and foreign keys<br>​		Transactions: YES<br>​					 XA: YES<br>​		  Savepoints: YES<br>​			InnoDB存储引擎：提供一组用来记录事务性活动的日志文件<br>​		优点：支持<strong>事务</strong>、行级锁、外键等。这种存储引擎数据的安全得到保障。<br>​		InnoDB存储引擎的特点是：<strong>非常安全！！</strong><br>​		表的结构存储在xxx.frm文件中<br>​		数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。</p>
<p>​			（表空间是一个逻辑名称，表空间存储数据+索引）<br>​		这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。<br>​		InnoDB支持级联删除和级联更新。<br>​	</p>
<hr>
<h2 id="Engine-MEMORY"><a href="#Engine-MEMORY" class="headerlink" title="Engine: MEMORY"></a>Engine: MEMORY</h2><p>​			  Support: YES<br>​			  Comment: Hash based, stored in memory, useful for temporary tables<br>​		Transactions: NO<br>​					 XA: NO<br>​		  Savepoints: NO<br>​		<br>​		缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。（目的就是快）<br>​		优点：查询速度最快。<br>​		以前叫做HEPA(堆)引擎。</p>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>​	<strong>一个事务是一个完整的业务逻辑单元，是一个最小的工作单元,不可再分。</strong></p>
<p>什么是完整的业务逻辑：</p>
<p>​	比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：<br>​		update t_act set balance &#x3D; balance - 10000 where actno &#x3D; ‘act-001’;<br>​		update t_act set balance &#x3D; balance + 10000 where actno &#x3D; ‘act-002’;<br>​	<br>​	以上两条DML语句必须同时成功，或者同时失败，不可再分，这样才能保证钱是正确的，不允许出现一条成功，一条失败。</p>
<p>​	要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。</p>
<h2 id="mysql事务默认情况下是自动提交的。"><a href="#mysql事务默认情况下是自动提交的。" class="headerlink" title="mysql事务默认情况下是自动提交的。"></a><strong>mysql事务默认情况下是自动提交的。</strong></h2><p>（什么是自动提交？只要执行任意一条DML语句则提交一次。）</p>
<p>这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功后再提交，所以不能执行一条就提交一条</p>
<p>怎么关闭自动提交？start transaction;（开启事务）</p>
<p><strong>提交一次就需要开启一次事务</strong></p>
<h2 id="只有DML语句才有事务"><a href="#只有DML语句才有事务" class="headerlink" title="只有DML语句才有事务"></a>只有DML语句才有事务</h2><p>insert delete update	</p>
<p>为什么？</p>
<p>因为它们这三个语句都是和数据库表当中的“数据”相关的。</p>
<p>动数据的东西</p>
<p>​	事务的存在是为了保证数据的完整性，安全性。</p>
<h2 id="存在事务的目的"><a href="#存在事务的目的" class="headerlink" title="存在事务的目的"></a>存在事务的目的</h2><p>假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？<br>    <strong>不需要事务。</strong><br>    但实际情况不是这样的，通常一个“事儿（事务【业务】）”需要多条DML语句共同联合完成。</p>
<p>说到底，一个事务其实就是多条DML语句同时成功，或者同时失败</p>
<h2 id="事务是如何做到同时成功和同时失败的"><a href="#事务是如何做到同时成功和同时失败的" class="headerlink" title="事务是如何做到同时成功和同时失败的"></a>事务是如何做到同时成功和同时失败的</h2><p>InnoDB存储引擎：提供一组用来记录<strong>事务性活动的日志文件</strong></p>
<p>事务开始了；</p>
<p>insert</p>
<p>insert</p>
<p>update</p>
<p>事务结束了</p>
<p>在事务的执行过程中，每一条DML的操作都会记录到‘事务性活动的日志文件’中，在事务的执行过程中，我们可以提交事务，也可以回滚事务</p>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p><strong>commit;语句</strong></p>
<p>清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中，提交事务标志着事务的结束，并且是一种全部成功的结束</p>
<h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><p><strong>rollback;语句</strong></p>
<p>将之前的DML操作全部撤销，并且清空事务性活动的日志文件，回滚事务标志着事务的结束，并且是一种全部失败的结束</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>​	事务包括四大特性：ACID<br>​	A: 原子性：事务是最小的工作单元，不可再分。<br>​	C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。<br>​	I：隔离性：事务A与事务B之间具有隔离。A事务再操作一张表的时候，另一个事务B也操作这张表会怎摸样</p>
<p>隔离性涉及到隔离级别，具体看下一小节</p>
<p>​	D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
<h2 id="事务之间的隔离性"><a href="#事务之间的隔离性" class="headerlink" title="事务之间的隔离性"></a>事务之间的隔离性</h2><p>A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄，这就是事务的隔离级别，这道墙越厚，表示隔离级别越高	</p>
<p>事务隔离性存在隔离级别，理论上隔离级别包括4个：</p>
<h3 id="第一级别：读未提交（read-uncommitted）"><a href="#第一级别：读未提交（read-uncommitted）" class="headerlink" title="第一级别：读未提交（read uncommitted）"></a><strong>第一级别：读未提交（read uncommitted）</strong></h3><p>​			对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。<br>​			读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。</p>
<h3 id="第二级别：读已提交（read-committed）"><a href="#第二级别：读已提交（read-committed）" class="headerlink" title="第二级别：读已提交（read committed）"></a>第二级别：读已提交（read committed）</h3><p>​			对方<strong>事务提交</strong>之后的数据我方可以读取到。<br>​			这种隔离级别解决了: 脏读现象没有了。<br>​			读已提交存在的问题是：不可重复读。</p>
<p>不可重复读：</p>
<p>​		在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读的时候，读到的数据是4条，3不等于4，称为不可重复读取</p>
<p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实</p>
<p>Oracle数据库默认的隔离级别就是read committed</p>
<h3 id="第三级别：可重复读（repeatable-read）"><a href="#第三级别：可重复读（repeatable-read）" class="headerlink" title="第三级别：可重复读（repeatable read）"></a>第三级别：可重复读（repeatable read）</h3><p>可重复读取：事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的，即使B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读.			</p>
<p>银行合计问题：从1点select到3点，得到的还是1点前的数据</p>
<p>​			这种隔离级别解决了：不可重复读问题。<br>​			这种隔离级别存在的问题是：读取到的数据是幻象。</p>
<h3 id="第四级别：序列化读-x2F-串行化读（serializable）"><a href="#第四级别：序列化读-x2F-串行化读（serializable）" class="headerlink" title="第四级别：序列化读&#x2F;串行化读（serializable）"></a>第四级别：序列化读&#x2F;串行化读（serializable）</h3><p>​			解决了所有问题。<br>​			效率低。需要事务排队。<br>synchronized，线程同步（这个是事务同步）		</p>
<p>这种隔离级别表示事务排队，不能并发</p>
<p>（不能两个客户端同时操作一张表）</p>
<p>​		oracle数据库默认的隔离级别是：读已提交。<br>​		mysql数据库默认的隔离级别是：可重复读。</p>
<p>3.6、演示事务</p>
<ul>
<li><p>准备表：<br>drop table if exists t_user;<br>create table t_user(<br>id int primary key auto_increment,<br>username varchar(255)<br>);</p>
</li>
<li><p>演示：使用start transaction;关闭自动提交机制。<br>mysql&gt; start transaction;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; insert into t_user(username) values(‘lisi’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>|  2 | lisi     |<br>+—-+———-+<br>2 rows in set (0.00 sec)</p>
<p>mysql&gt; insert into t_user(username) values(‘wangwu’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>|  2 | lisi     |<br>|  3 | wangwu   |<br>+—-+———-+<br>3 rows in set (0.00 sec)</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.02 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>+—-+———-+</p>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; start transaction;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; insert into t_user(username) values(‘wangwu’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; insert into t_user(username) values(‘rose’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; insert into t_user(username) values(‘jack’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>|  4 | wangwu   |<br>|  5 | rose     |<br>|  6 | jack     |<br>+—-+———-+<br>4 rows in set (0.00 sec)</p>
<p>mysql&gt; commit;<br>Query OK, 0 rows affected (0.04 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>|  4 | wangwu   |<br>|  5 | rose     |<br>|  6 | jack     |<br>+—-+———-+<br>4 rows in set (0.00 sec)</p>
<p>mysql&gt; rollback;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from t_user;<br>+—-+———-+<br>| id | username |<br>+—-+———-+<br>|  1 | zs       |<br>|  4 | wangwu   |<br>|  5 | rose     |<br>|  6 | jack     |<br>+—-+———-+<br>4 rows in set (0.00 sec)</p>
</li>
<li><p>演示两个事务，假如隔离级别<br>演示第1级别：读未提交<br>set global transaction isolation level read uncommitted;<br>演示第2级别：读已提交<br>set global transaction isolation level read committed;<br>演示第3级别：可重复读<br>set global transaction isolation level repeatable read;</p>
</li>
<li><p>mysql远程登录：mysql -h192.168.151.18 -uroot -p444</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>注意：<strong>主键和具有unique约束的字段自动会添加索引。</strong><br>根据主键查询效率较高。尽量根据主键检索。</p>
<h2 id="创建索引对象-怎么删除索引对象"><a href="#创建索引对象-怎么删除索引对象" class="headerlink" title="创建索引对象,怎么删除索引对象"></a>创建索引对象,怎么删除索引对象</h2><p>​	创建索引对象：<br>​		create index 索引名称 on 表名(字段名);<br>​	删除索引对象：<br>​		drop index 索引名称 on 表名;</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>​	单一索引：给单个字段添加索引<br>​	复合索引: 给多个字段联合起来添加1个索引<br>​	主键索引：主键上会自动添加索引<br>​	唯一索引：有unique约束的字段上会自动添加索引<br>​	….</p>
<p>唯一性比较弱的字段上添加索引用处不大</p>
<p>越唯一，效率越高</p>
<h2 id="什么是索引？有什么用？"><a href="#什么是索引？有什么用？" class="headerlink" title="什么是索引？有什么用？"></a>什么是索引？有什么用？</h2><p>​	索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制，</p>
<p>一张表的一个字段可以添加一个索引，多个字段联合起来也可以添加索引</p>
<p><strong>索引就相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。通过目录可以快速的找到对应的资源。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一本字典来说，查找某个汉字有两种方式：</span><br><span class="line"></span><br><span class="line">第一种方式：一页一页挨着找，知道找到为止，这种属于全表扫描，效率比较低</span><br><span class="line"></span><br><span class="line">第二种方式：先通过目录去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找这种属于根据索引检索，效率很高；</span><br></pre></td></tr></table></figure>







<p>​	在数据库方面，查询一张表的时候有两种检索方式：<br>​		第一种方式：全表扫描<br>​		第二种方式：根据索引检索（效率很高）</p>
<h2 id="什么时候考虑给字段添加索引？（满足什么条件）"><a href="#什么时候考虑给字段添加索引？（满足什么条件）" class="headerlink" title="什么时候考虑给字段添加索引？（满足什么条件）"></a>什么时候考虑给字段添加索引？（满足什么条件）</h2><ul>
<li>数据量庞大。（根据客户的需求，根据线上的环境）</li>
<li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护。DML之后，索引需要重新排序）</li>
<li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li>
</ul>
<p>	</p>
<h2 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h2><p>在任何数据库中，任何一张表的任何记录在硬盘存储上都有一个硬盘的物理存储编号</p>
<p>​	</p>
<p>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，<br>    最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率<br>    是最高的。<br>        select ename from emp where ename &#x3D; ‘SMITH’;<br>        通过索引转换为：<br>        select ename from emp where 物理地址 &#x3D; 0x3;</p>
<p><img src="/../pic/image-20220429214915322.png" alt="image-20220429214915322"></p>
<p><strong>索引底层采用的数据结构是：B + Tree</strong>(多路搜索二叉树)</p>
<p>索引为什么可以提高检索效率呢？</p>
<p>​		<strong>其实最根本的原理是缩小了扫描的范围。</strong><br>​	</p>
<p>​	索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中<br>​	的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改<br>​	这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>​	添加索引是给某一个字段，或者说某些字段添加索引。</p>
<p>​	select ename,sal from emp where ename &#x3D; ‘SMITH’;<br>​	当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。<br>​	当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p>
<h2 id="索引什么时候失效？"><a href="#索引什么时候失效？" class="headerlink" title="索引什么时候失效？"></a>索引什么时候失效？</h2><p>​	select ename from emp where ename like ‘%A%’;<br>1.模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p>
<p>尽量避免模糊查询的时候以“%”开始</p>
<p>2.使用or的时候会失效，如果使用or，那么要求or两边的条件字段都要有索引，才能走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效</p>
<p>3.复合索引的时候没有使用左侧的列查找，索引失效</p>
<p>复合索引就是两个字段或者更多的字段联合起来添加一个索引，叫做复合索引</p>
<p>4.where当中索引列参加了数学运算，索引失效</p>
<p>字段参加数学运算！！</p>
<p>select * from emp where sal-1&#x3D;1000;</p>
<p>5.在where当中，索引列使用了函数</p>
<p>select * from emp where lower(ename);</p>
<h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h1><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和 修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
<p><strong>站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</strong></p>
<p>对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）<br>可以对视图进行CRUD操作。</p>
<p><strong>引用原表的数据，进行映射</strong></p>
<h2 id="创建视图，删除视图"><a href="#创建视图，删除视图" class="headerlink" title="创建视图，删除视图"></a>创建视图，删除视图</h2><p><img src="/../pic/image-20220822153529436.png" alt="image-20220822153529436"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> myview <span class="keyword">as</span> <span class="keyword">select</span> empno,ename <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> myview;</span><br></pre></td></tr></table></figure>

<p>​	注意：只有DQL语句才能以视图对象的方式创建出来。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>​	视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员<br>​	只对视图对象进行CRUD。</p>
<h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><p>含义：</p>
<p>存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句 的封装。 </p>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用 存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p>好处：</p>
<p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </p>
<p>2、减少操作过程中的失误，提高效率 </p>
<p>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </p>
<p>4、减少了 SQL 语句暴露在 网上的风险，也提高了数据查询的安全性</p>
<p>分类：</p>
<p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<p> 1、没有参数（无参数无返回） </p>
<p>2、仅仅带 IN 类型（有参数无返回） </p>
<p>3、仅仅带 OUT 类型（无参数有返 回） </p>
<p>4、既带 IN 又带 OUT（有参数有返回） </p>
<p>5、带 INOUT（有参数有返回） </p>
<p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220822165745492.png" alt="image-20220822165745492"></p>
<p>举例：</p>
<h3 id="1-无参数无返回值"><a href="#1-无参数无返回值" class="headerlink" title="1.无参数无返回值"></a>1.无参数无返回值</h3><p><img src="/../pic/image-20220822204326389.png" alt="image-20220822204326389"></p>
<h3 id="2-无参数有返回值"><a href="#2-无参数有返回值" class="headerlink" title="2.无参数有返回值"></a>2.无参数有返回值</h3><p><img src="/../pic/image-20220822205036091.png" alt="image-20220822205036091"></p>
<p><img src="/../pic/image-20220822205159130.png" alt="image-20220822205159130"></p>
<h3 id="3-有参数无返回值"><a href="#3-有参数无返回值" class="headerlink" title="3.有参数无返回值"></a>3.有参数无返回值</h3><p><img src="/../pic/image-20220822205426894.png" alt="image-20220822205426894"></p>
<h3 id="4-有参数有返回值"><a href="#4-有参数有返回值" class="headerlink" title="4.有参数有返回值"></a>4.有参数有返回值</h3><p><img src="/../pic/image-20220822205753282.png" alt="image-20220822205753282"></p>
<p>调用</p>
<p><img src="/../pic/image-20220822205923593.png" alt="image-20220822205923593"></p>
<p>有参数多个返回值</p>
<p><img src="/../pic/image-20220824115605342.png" alt="image-20220824115605342"></p>
<h3 id="5-inout的有参数有返回值的类型"><a href="#5-inout的有参数有返回值的类型" class="headerlink" title="5.inout的有参数有返回值的类型"></a>5.inout的有参数有返回值的类型</h3><p><img src="/../pic/image-20220822210327135.png" alt="image-20220822210327135"></p>
<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>参数列表相对于存储过程的区别是，函数只有in类型，也就是说参数只有输入的值</p>
<p>首先我们先知道，有的场景下是不需要加characteristics参数的，但是sql的语法就很扯淡，你不加他给你报错。</p>
<h3 id="不加characteristics出现报错情况"><a href="#不加characteristics出现报错情况" class="headerlink" title="不加characteristics出现报错情况"></a>不加characteristics出现报错情况</h3><p>若在创建存储函数中报错“ you might want to use the less safelog_bin_trust_function_creators variable ”，有两种处理方法：</p>
<p>方式1：</p>
<p>加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</p>
<p>方式2：</p>
<p>执行<code>SET GLOBAL log_bin_trust_function_creators = 1;</code>这条语句</p>
<h3 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h3><p>举例：</p>
<p><img src="/../pic/image-20220824074501952.png" alt="image-20220824074501952"></p>
<p>调用</p>
<p><img src="/../pic/image-20220824074537507.png" alt="image-20220824074537507"></p>
<h3 id="有参数"><a href="#有参数" class="headerlink" title="有参数"></a>有参数</h3><p><img src="/../pic/image-20220824075438248.png" alt="image-20220824075438248"></p>
<p>调用</p>
<p><img src="/../pic/image-20220824075454046.png" alt="image-20220824075454046"></p>
<h2 id="存储过程-x2F-函数的查看"><a href="#存储过程-x2F-函数的查看" class="headerlink" title="存储过程&#x2F;函数的查看"></a>存储过程&#x2F;函数的查看</h2><p>&#x3D;&#x3D;1&#x3D;&#x3D; <code> SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</code></p>
<p>举例</p>
<p><img src="/../pic/image-20220824080845170.png" alt="image-20220824080845170"></p>
<p>&#x3D;&#x3D;2&#x3D;&#x3D;使用SHOW STATUS语句查看存储过程&#x2F;函数 的状态信息</p>
<p><code> SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#39;pattern&#39;]</code></p>
<p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p>
<p>举例</p>
<p><img src="/../pic/image-20220824081155314.png" alt="image-20220824081155314"></p>
<p><img src="/../pic/image-20220824081219865.png" alt="image-20220824081219865"></p>
<h2 id="存储过程-x2F-函数的修改"><a href="#存储过程-x2F-函数的修改" class="headerlink" title="存储过程&#x2F;函数的修改"></a>存储过程&#x2F;函数的修改</h2><p>改动的方式比较有限,<strong>不能修改这个存储过程&#x2F;函数的功能</strong></p>
<p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有 不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220824113553389.png" alt="image-20220824113553389"></p>
<p>举例</p>
<p><img src="/../pic/image-20220824113810478.png" alt="image-20220824113810478"></p>
<h2 id="存储过程-x2F-函数的删除"><a href="#存储过程-x2F-函数的删除" class="headerlink" title="存储过程&#x2F;函数的删除"></a>存储过程&#x2F;函数的删除</h2><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名字</span><br></pre></td></tr></table></figure>

<p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误（进行一个判断，如果没有就不删除）</p>
<p><img src="/../pic/image-20220824114143614.png" alt="image-20220824114143614"></p>
<h1 id="变量、流程控制与游标"><a href="#变量、流程控制与游标" class="headerlink" title="变量、流程控制与游标"></a>变量、流程控制与游标</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量分为系统变量和用户变量</p>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字）</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制</p>
<p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><p>查看所有或部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%变量名称%&#x27;</span>;</span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%变量名称%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220824154009253.png" alt="image-20220824154009253"></p>
<p>查看指定系统变量</p>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变 量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名; #这种方法会先去session中找，再去全局中找</span><br></pre></td></tr></table></figure>

<h4 id="修改系统变量的值"><a href="#修改系统变量的值" class="headerlink" title="修改系统变量的值"></a>修改系统变量的值</h4><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。具体方法： </p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务） （my.ini）</p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值（这种方法改动修改是暂时改动，因为重启还是会加载配置文件中的变量数值）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>  max_connections <span class="operator">=</span> <span class="number">1000</span>; #这种是万金油改法</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220824154635995.png" alt="image-20220824154635995"></p>
<h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 <strong>一个“@”</strong> 开头。根据作用 范围不同，又分为 <strong>会话用户变量</strong>（主要是用@修饰的） 和 <strong>局部变量</strong>（不用@） 。</p>
<p>会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。 </p>
<p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</p>
<h4 id="会话用户变量"><a href="#会话用户变量" class="headerlink" title="会话用户变量"></a>会话用户变量</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式<span class="number">1</span>：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line">#方式<span class="number">2</span>：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字(这种方式来源于一个<span class="keyword">sql</span>语句查询的字段)</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure>

<p>举例</p>
<p><img src="/../pic/image-20220824160306240.png" alt="image-20220824160306240"></p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>定义：可以使用 DECLARE 语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的 BEGIN … END 中有效 </p>
<p>位置：只能放在 BEGIN … END 中，而且只能放在首部(如果有多个，可以往后排)</p>
<p>注意 &#x3D;&#x3D;局部变量需要指明变量类型&#x3D;&#x3D;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">#声明局部变量</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值]; # 如果没有<span class="keyword">DEFAULT</span>子句，初始值为<span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">2</span>,变量名<span class="number">3</span>,... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line">#为局部变量赋值</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">2</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line">#查看局部变量的值</span><br><span class="line"><span class="keyword">SELECT</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220824161559942.png" alt="image-20220824161559942"></p>
<h2 id="定义条件与处理程序（和异常捕获类似）"><a href="#定义条件与处理程序（和异常捕获类似）" class="headerlink" title="定义条件与处理程序（和异常捕获类似）"></a>定义条件与处理程序（和异常捕获类似）</h2><h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>&#x3D;&#x3D;定义条件&#x3D;&#x3D; 是事先定义程序执行过程中可能遇到的问题， 处理程序 定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能 力，避免程序异常停止运行。（和java中的异常类似）</p>
<p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的 错误条件 关联起来。这个名字可以随后被用在定义处理程序的 <code>DECLARE HANDLER </code>语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 错误名称 <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> 错误码（或错误条件）</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220828150715108.png" alt="image-20220828150715108"></p>
<p>例子：</p>
<p>定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line">#使用sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序（也就是发生错误后，调用这些相应的语句）。定义处理程序时，使用DECLARE语句 的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 处理方式 HANDLER <span class="keyword">FOR</span> 错误类型 处理语句</span><br></pre></td></tr></table></figure>

<p>其中处理方式，错误类型，处理语句分别的解释为：</p>
<p>&#x3D;&#x3D;处理方式&#x3D;&#x3D;：处理方式有3个取值：CONTINUE、EXIT、UNDO。<br>    CONTINUE ：表示遇到错误不处理，继续执行。<br>    EXIT ：表示遇到错误马上退出。<br>    UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</p>
<p>&#x3D;&#x3D;错误类型&#x3D;&#x3D;（即条件）可以有如下取值：</p>
<p>​	SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码；<br>​	MySQL_error_code ：匹配数值类型错误代码；<br>​	错误名称：表示DECLARE … CONDITION定义的错误条件名称。</p>
<p><strong>上面这上面分别指代的是错误码&#x2F;错误条件&#x2F;错误名称</strong></p>
<p>​	SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码；<br>​	NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码；<br>​	SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</p>
<p>&#x3D;&#x3D;处理语句&#x3D;&#x3D;：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是<br>像“ SET 变量 &#x3D; 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。</p>
<p>具体的使用例子</p>
<p><img src="/../pic/image-20220828152339455.png" alt="image-20220828152339455"></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程 就分为三大类：</p>
<p>顺序结构 ：程序从上往下依次执行<br>分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行<br>循环结构 ：程序满足一定条件下，重复执行一组语句</p>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<p>条件判断语句 ：IF 语句和 CASE 语句<br>循环语句 ：LOOP、WHILE 和 REPEAT 语句<br>跳转语句 ：ITERATE 和 LEAVE 语句</p>
<h3 id="分支结构之-IF"><a href="#分支结构之-IF" class="headerlink" title="分支结构之 IF"></a>分支结构之 IF</h3><p>IF 语句的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 表达式<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span></span><br><span class="line">[ELSEIF 表达式<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]……</span><br><span class="line">[<span class="keyword">ELSE</span> 操作N]</span><br><span class="line"><span class="keyword">END</span> IF</span><br></pre></td></tr></table></figure>

<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p>
<p>举例</p>
<p><img src="/../pic/image-20220828154500684.png" alt="image-20220828154500684"></p>
<h3 id="分支结构之CASE"><a href="#分支结构之CASE" class="headerlink" title="分支结构之CASE"></a>分支结构之CASE</h3><p>CASE 语句的语法结构1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line">	<span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line">	<span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">	<span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220829155615862.png" alt="image-20220829155615862"></p>
<p>CASE 语句的语法结构2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line">	<span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">    <span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220829155749956.png" alt="image-20220829155749956"></p>
<h3 id="循环结构之LOOP"><a href="#循环结构之LOOP" class="headerlink" title="循环结构之LOOP"></a>循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[loop_lobel:]LOOP</span><br><span class="line">	循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br></pre></td></tr></table></figure>

<p>其中，loop_label表示LOOP语句的标注名称（就是这个循环的名字），该参数可以省略。</p>
<p>举例：</p>
<p>使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p>
<p><strong>下面的代码块是写在BEGIN …END代码块中的</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    add_loop:LOOP</span><br><span class="line">        <span class="keyword">SET</span> id <span class="operator">=</span> id <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">            IF id <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">THEN</span> LEAVE add_loop;</span><br><span class="line">            <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> LOOP add_loop;</span><br></pre></td></tr></table></figure>

<h3 id="循环结构之WHILE"><a href="#循环结构之WHILE" class="headerlink" title="循环结构之WHILE"></a>循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。（和Java语法一样）WHILE语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;while_label&#x3D;&#x3D;为WHILE语句的标注名称</p>
<p>举例</p>
<p><img src="/../pic/image-20220829162249719.png" alt="image-20220829162249719"></p>
<h3 id="循环结构之REPEAT"><a href="#循环结构之REPEAT" class="headerlink" title="循环结构之REPEAT"></a>循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会 就继续执行循环，直到满足退出条件为止。(和dowhile类似)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[repeat_label:]REPEAT</span><br><span class="line">			循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p>repeat_label为REPEAT语句的标注名称，该参数可以省略；</p>
<p><img src="/../pic/image-20220829164733425.png" alt="image-20220829164733425"></p>
<h3 id="跳转语句之LEAVE语句"><a href="#跳转语句之LEAVE语句" class="headerlink" title="跳转语句之LEAVE语句"></a>跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<p>举例：</p>
<p>可以leave ，begin..end，不过要加标签名</p>
<p><img src="/../pic/image-20220829170919573.png" alt="image-20220829170919573"></p>
<p>也可以leave循环</p>
<p><img src="/../pic/image-20220829165521779.png" alt="image-20220829165521779"></p>
<h3 id="跳转语句之ITERATE语句"><a href="#跳转语句之ITERATE语句" class="headerlink" title="跳转语句之ITERATE语句"></a>跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序 转到语句段开头处。</p>
<p>如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
<p><img src="/../pic/image-20220829171503391.png" alt="image-20220829171503391"></p>
<p><img src="/../pic/image-20220829171902246.png" alt="image-20220829171902246"></p>
<p><img src="/../pic/image-20220829172226642.png" alt="image-20220829172226642"></p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一 条记录 ，并对记录的数据进行处理。</p>
<p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过 程开发的能力。</p>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了 指针的作用 ，我们可以通过操作游标来对数据行进行操作。</p>
<p>MySQL中游标可以在存储过程和函数中使用。</p>
<p><img src="/../pic/image-20220829173844761.png" alt="image-20220829173844761"></p>
<h3 id="使用游标需要四个步骤"><a href="#使用游标需要四个步骤" class="headerlink" title="使用游标需要四个步骤"></a>使用游标需要四个步骤</h3><h4 id="第一步，声明游标"><a href="#第一步，声明游标" class="headerlink" title="第一步，声明游标"></a>第一步，声明游标</h4><p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>Oracle中发生了一些变化：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement</span><br></pre></td></tr></table></figure>

<p>其中的</p>
<p>cursor_name代表的是游标名称</p>
<p>select_statement代表的是sql的查询语句，返回一个用于创建游标的结果集</p>
<p>例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cur_emp <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="第二步，打开游标"><a href="#第二步，打开游标" class="headerlink" title="第二步，打开游标"></a>第二步，打开游标</h4><p>打开游标的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的&#x3D;&#x3D;逐条读取&#x3D;&#x3D;结果集中的记录做准备。</p>
<h4 id="第三步，使用游标（从游标中取得数据）"><a href="#第三步，使用游标（从游标中取得数据）" class="headerlink" title="第三步，使用游标（从游标中取得数据）"></a>第三步，使用游标（从游标中取得数据）</h4><p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220829220022059.png" alt="image-20220829220022059"></p>
<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>注意：var_name必须在声明游标之前就定义好。</p>
<p>注意：游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致，否则，在存储过程执行的时 候，MySQL 会提示错误。</p>
<h4 id="第四步，关闭游标"><a href="#第四步，关闭游标" class="headerlink" title="第四步，关闭游标"></a>第四步，关闭游标</h4><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会 占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p>
<p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要再次检索需要再次打开游标。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明 OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> limit_total_salary <span class="keyword">DOUBLE</span>,<span class="keyword">OUT</span> total_count <span class="type">INT</span>)</span><br><span class="line">        <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">DECLARE</span> sum_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录累加的总工资</span><br><span class="line">            <span class="keyword">DECLARE</span> cursor_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录某一个工资值</span><br><span class="line">            <span class="keyword">DECLARE</span> emp_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录循环个数</span><br><span class="line">            #定义游标</span><br><span class="line">            <span class="keyword">DECLARE</span> emp_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            #打开游标</span><br><span class="line">            <span class="keyword">OPEN</span> emp_cursor;</span><br><span class="line">            REPEAT</span><br><span class="line">            #使用游标（从游标中获取数据）</span><br><span class="line">            <span class="keyword">FETCH</span> emp_cursor <span class="keyword">INTO</span> cursor_salary;</span><br><span class="line">            <span class="keyword">SET</span> sum_salary <span class="operator">=</span> sum_salary <span class="operator">+</span> cursor_salary;</span><br><span class="line">            <span class="keyword">SET</span> emp_count <span class="operator">=</span> emp_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">            UNTIL sum_salary <span class="operator">&gt;=</span> limit_total_salary</span><br><span class="line">            <span class="keyword">END</span> REPEAT;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">SET</span> total_count <span class="operator">=</span> emp_count;</span><br><span class="line">            #关闭游标</span><br><span class="line">            <span class="keyword">CLOSE</span> emp_cursor;</span><br><span class="line">        <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层 面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 </p>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。 </p>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分 别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时 在库存表中添加一条库存记录。</p>
<p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操作成为一个 原子操作（不可以再继续细分） ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。</p>
<p>这个时候，咱们可以使用触发器。<strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。</strong>这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<p>触发器是由事件来触发某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指 用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。 </p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来 实现。</p>
<h2 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h2><p>每个触发器是和表有高耦合关系的</p>
<p>创建触发器的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p><img src="/../pic/image-20220829224415605.png" alt="image-20220829224415605"></p>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><p>1.创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_trigger (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    t_note <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_trigger_log (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    t_log <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2.创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向 test_trigger_log数据表中插入before_insert的日志信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log (t_log)</span><br><span class="line">    <span class="keyword">VALUES</span>(<span class="string">&#x27;before_insert&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>在向test_trigger插入数据后会发现日志表也会插入一条数据</p>
<p>对于<img src="/../pic/image-20220829225708291.png" alt="image-20220829225708291"></p>
<p>我的理解是，如果在插入之前触发触发器，如果在触发器中抛出异常，那么执行的语句也不会执行。如果是插入之后执行，就不会有这种效果。</p>
<p>比如说下面这个例题</p>
<p>举例：定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查 将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错 误，从而使得添加失败。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> salary_check_trigger</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> mgrsalary <span class="keyword">DOUBLE</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> mgrsalary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> NEW.manager_id;</span><br><span class="line">    IF NEW.salary <span class="operator">&gt;</span> mgrsalary <span class="keyword">THEN</span></span><br><span class="line">    	SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;薪资高于领导薪资错误&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式1：查看当前数据库的所有触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>方式2：查看当前数据库中某个触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure>

<p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h1 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h1><p><strong>重点了解数据的备份</strong></p>
<h2 id="将数据库当中的数据导出"><a href="#将数据库当中的数据导出" class="headerlink" title="将数据库当中的数据导出"></a>将数据库当中的数据导出</h2><p>​	在windows的dos命令窗口中执行：（导出整个库）<br>​		mysqldump 数据库名&gt;D:文件名.sql -u 账号名 -p 密码</p>
<p><img src="/../pic/image-20220420153043126.png" alt="image-20220420153043126">	<br>    在windows的dos命令窗口中执行：（导出指定数据库当中的指定表)<br>        mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot –p123</p>
<h2 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h2><p>需要先登录上mysql，</p>
<p>之后创建数据库	</p>
<p>create database bjpowernode;</p>
<p>使用数据库</p>
<p>​	use bjpowernode;</p>
<p><img src="/../pic/image-20220420153151250.png" alt="image-20220420153151250">	</p>
<p>source D:\文件名.sql</p>
<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式*"></a>数据库设计三范式*</h1><p>​	</p>
<h2 id="什么是设计范式？"><a href="#什么是设计范式？" class="headerlink" title="什么是设计范式？"></a>什么是设计范式？</h2><p>​	设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p>
<h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p>​	<strong>任何一张表都应该有主键，并且每一个字段原子性不可再分。</strong></p>
<p><img src="/../pic/image-20220420153934118.png" alt="image-20220420153934118"></p>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p>​	<strong>建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。</strong></p>
<p><img src="/../pic/image-20220420154313748.png" alt="image-20220420154313748"> <img src="/../pic/image-20220420154722359.png" alt="image-20220420154722359"></p>
<h3 id="多对多怎么设计"><a href="#多对多怎么设计" class="headerlink" title="多对多怎么设计"></a>多对多怎么设计</h3><p>多对多，三张表，关系表两个外键</p>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>​	<strong>建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</strong></p>
<p><img src="/../pic/image-20220420155526040.png" alt="image-20220420155526040"></p>
<p><img src="/../pic/image-20220420155604474.png" alt="image-20220420155604474"></p>
<h3 id="一对多怎么设计"><a href="#一对多怎么设计" class="headerlink" title="一对多怎么设计"></a>一对多怎么设计</h3><p> 一对多，两张表，多的表加外键</p>
<h2 id="一对一怎么设计"><a href="#一对一怎么设计" class="headerlink" title="一对一怎么设计"></a>一对一怎么设计</h2><p><img src="/../pic/image-20220420160840832.png" alt="image-20220420160840832"></p>
<h1 id="牢记"><a href="#牢记" class="headerlink" title="牢记"></a>牢记</h1><p>数据库设计三范式是理论上的</p>
<p>实践和理论有时候有偏差</p>
<p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换速度</p>
<p>因为在sql中，表和表的连接次数越多，效率越低（笛卡尔积）</p>
<p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，</p>
<p>并且对于开发人员来说，<strong>sql语句的编写难度也会降低</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小白菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/06/mysql/">http://example.com/2022/08/06/mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">是小白菜哦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="https://hakaimg.com/i/2022/08/11/xhvqca.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/07/Docker/"><img class="prev-cover" src="https://hakaimg.com/i/2022/08/08/ngvkh5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/06/linux/"><img class="next-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小白菜</div><div class="author-info__description">头发多多</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xiaobaicai350"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Xiaobaicai350" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1499487526@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阳光斑斓 微风含香 爱与四季 皆是向往 <img height="230" lengh="230" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1.gif"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E3%80%81DB%E3%80%81DBMS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">sql、DB、DBMS之间的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">SQL语句的分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">4.</span> <span class="toc-text">导入数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E8%84%9A%E6%9C%AC"><span class="toc-number">5.</span> <span class="toc-text">sql脚本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">删除数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">查看表结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">8.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%88DQL%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">简单的查询语句（DQL）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.</span> <span class="toc-text">条件查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E4%BA%8E-x3D"><span class="toc-number">10.1.</span> <span class="toc-text">等于&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E%EF%BC%81-lt-gt"><span class="toc-number">10.2.</span> <span class="toc-text">不等于！&lt;&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#between-and"><span class="toc-number">10.3.</span> <span class="toc-text">between and</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BAnull"><span class="toc-number">10.4.</span> <span class="toc-text">为null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E6%98%AFis-not"><span class="toc-number">10.5.</span> <span class="toc-text">不是is not</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.7.</span> <span class="toc-text">逻辑与运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#or"><span class="toc-number">10.8.</span> <span class="toc-text">or</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in"><span class="toc-number">10.9.</span> <span class="toc-text">in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not-in"><span class="toc-number">10.10.</span> <span class="toc-text">not in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like"><span class="toc-number">10.11.</span> <span class="toc-text">模糊查询like</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REGEXP%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.12.</span> <span class="toc-text">REGEXP运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8Forder-by"><span class="toc-number">11.</span> <span class="toc-text">排序order by</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">单行处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#now"><span class="toc-number">12.1.</span> <span class="toc-text">now</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ifnull"><span class="toc-number">12.2.</span> <span class="toc-text">ifnull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#format"><span class="toc-number">12.3.</span> <span class="toc-text">format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#str-to-data"><span class="toc-number">12.4.</span> <span class="toc-text">str_to_data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#date-format"><span class="toc-number">12.5.</span> <span class="toc-text">date_format</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">分组函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#group-by-%E5%92%8C-having"><span class="toc-number">14.</span> <span class="toc-text">group by 和 having</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WITH-ROLLUP%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.1.</span> <span class="toc-text">WITH ROLLUP关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84DQL%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E5%86%99"><span class="toc-number">15.</span> <span class="toc-text">一个完整的DQL语句怎么写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%88distinct%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">查询结果集的去重（distinct）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">17.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">17.1.</span> <span class="toc-text">连接查询的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF"><span class="toc-number">17.2.</span> <span class="toc-text">笛卡尔积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">18.</span> <span class="toc-text">内连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">18.1.</span> <span class="toc-text">等值连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">18.2.</span> <span class="toc-text">非等值连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">18.3.</span> <span class="toc-text">自连接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">19.</span> <span class="toc-text">外连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%BC%A0%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">19.1.</span> <span class="toc-text">三张表连接查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">20.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#where%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">20.1.</span> <span class="toc-text">where子句中使用子查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#from%E5%90%8E%E9%9D%A2%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">20.2.</span> <span class="toc-text">from后面嵌套子查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8select%E5%90%8E%E9%9D%A2%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2%E3%80%82"><span class="toc-number">20.3.</span> <span class="toc-text">在select后面嵌套子查询。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#union-%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E5%90%88%E5%B9%B6%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">union （可以将查询结果集合并）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#limit-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">22.</span> <span class="toc-text">limit (分页查询)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">22.1.</span> <span class="toc-text">语法机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limit%E6%98%AFsql%E8%AF%AD%E5%8F%A5%E6%9C%80%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84-%E4%B8%80%E4%B8%AA%E7%8E%AF%E8%8A%82%EF%BC%9A"><span class="toc-number">22.2.</span> <span class="toc-text">limit是sql语句最后执行的 一个环节：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%87%E5%87%86%E5%88%86%E9%A1%B5sql"><span class="toc-number">22.3.</span> <span class="toc-text">通用的标准分页sql</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%EF%BC%9A"><span class="toc-number">23.</span> <span class="toc-text">创建表：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">23.1.</span> <span class="toc-text">建表语句的语法格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">23.2.</span> <span class="toc-text">字段的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E5%92%8Cvarchar"><span class="toc-number">23.2.1.</span> <span class="toc-text">char和varchar</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#date%E5%92%8Cdatetime"><span class="toc-number">23.3.</span> <span class="toc-text">date和datetime</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-number">24.</span> <span class="toc-text">删除表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#insert%E8%AF%AD%E5%8F%A5%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">25.</span> <span class="toc-text">insert语句插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E8%A1%A8%EF%BC%89"><span class="toc-number">25.1.</span> <span class="toc-text">表的复制（快速创建表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E5%88%B0%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD"><span class="toc-number">25.2.</span> <span class="toc-text">将查询结果插入到一张表中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%EF%BC%9Aupdate"><span class="toc-number">26.</span> <span class="toc-text">修改数据：update</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%9Adelete"><span class="toc-number">27.</span> <span class="toc-text">删除数据：delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">27.1.</span> <span class="toc-text">快速删除表中的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4%EF%BC%88%E5%BF%AB%E9%80%9F%EF%BC%89"><span class="toc-number">27.1.1.</span> <span class="toc-text">物理删除（快速）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">28.</span> <span class="toc-text">对于表结构的修改</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">29.</span> <span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F-Constraint"><span class="toc-number">30.</span> <span class="toc-text">约束(Constraint)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F-not-null"><span class="toc-number">30.1.</span> <span class="toc-text">非空约束 not null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F%EF%BC%88unique%EF%BC%89"><span class="toc-number">30.2.</span> <span class="toc-text">唯一性约束（unique）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E5%94%AF%E4%B8%80"><span class="toc-number">30.2.1.</span> <span class="toc-text">联合唯一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">30.3.</span> <span class="toc-text">主键约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">30.4.</span> <span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">31.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Engine-MyISAM"><span class="toc-number">31.1.</span> <span class="toc-text">Engine: MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Engine-InnoDB"><span class="toc-number">31.2.</span> <span class="toc-text">Engine: InnoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Engine-MEMORY"><span class="toc-number">31.3.</span> <span class="toc-text">Engine: MEMORY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%EF%BC%88Transaction%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">事务（Transaction）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">32.1.</span> <span class="toc-text">什么是事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E4%BA%8B%E5%8A%A1%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E7%9A%84%E3%80%82"><span class="toc-number">32.2.</span> <span class="toc-text">mysql事务默认情况下是自动提交的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89DML%E8%AF%AD%E5%8F%A5%E6%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1"><span class="toc-number">32.3.</span> <span class="toc-text">只有DML语句才有事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">32.4.</span> <span class="toc-text">存在事务的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%90%8C%E6%97%B6%E6%88%90%E5%8A%9F%E5%92%8C%E5%90%8C%E6%97%B6%E5%A4%B1%E8%B4%A5%E7%9A%84"><span class="toc-number">32.5.</span> <span class="toc-text">事务是如何做到同时成功和同时失败的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-number">32.5.1.</span> <span class="toc-text">提交事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1"><span class="toc-number">32.5.2.</span> <span class="toc-text">回滚事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">32.6.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">32.7.</span> <span class="toc-text">事务之间的隔离性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%AB%EF%BC%9A%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%88read-uncommitted%EF%BC%89"><span class="toc-number">32.7.1.</span> <span class="toc-text">第一级别：读未提交（read uncommitted）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%AB%EF%BC%9A%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%88read-committed%EF%BC%89"><span class="toc-number">32.7.2.</span> <span class="toc-text">第二级别：读已提交（read committed）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%BA%A7%E5%88%AB%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88repeatable-read%EF%BC%89"><span class="toc-number">32.7.3.</span> <span class="toc-text">第三级别：可重复读（repeatable read）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%BA%A7%E5%88%AB%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%BB-x2F-%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%AF%BB%EF%BC%88serializable%EF%BC%89"><span class="toc-number">32.7.4.</span> <span class="toc-text">第四级别：序列化读&#x2F;串行化读（serializable）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">33.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1-%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">33.1.</span> <span class="toc-text">创建索引对象,怎么删除索引对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">33.2.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">33.3.</span> <span class="toc-text">什么是索引？有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%80%83%E8%99%91%E7%BB%99%E5%AD%97%E6%AE%B5%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9F%EF%BC%88%E6%BB%A1%E8%B6%B3%E4%BB%80%E4%B9%88%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-number">33.4.</span> <span class="toc-text">什么时候考虑给字段添加索引？（满足什么条件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">33.5.</span> <span class="toc-text">索引的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">33.6.</span> <span class="toc-text">索引什么时候失效？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE-view"><span class="toc-number">34.</span> <span class="toc-text">视图(view)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE%EF%BC%8C%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">34.1.</span> <span class="toc-text">创建视图，删除视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">34.2.</span> <span class="toc-text">视图的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">存储过程与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">35.1.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">35.1.1.</span> <span class="toc-text">1.无参数无返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">35.1.2.</span> <span class="toc-text">2.无参数有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">35.1.3.</span> <span class="toc-text">3.有参数无返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">35.1.4.</span> <span class="toc-text">4.有参数有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-inout%E7%9A%84%E6%9C%89%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">35.1.5.</span> <span class="toc-text">5.inout的有参数有返回值的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">35.2.</span> <span class="toc-text">存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8A%A0characteristics%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-number">35.2.1.</span> <span class="toc-text">不加characteristics出现报错情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0"><span class="toc-number">35.2.2.</span> <span class="toc-text">无参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%8F%82%E6%95%B0"><span class="toc-number">35.2.3.</span> <span class="toc-text">有参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-x2F-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="toc-number">35.3.</span> <span class="toc-text">存储过程&#x2F;函数的查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-x2F-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">35.4.</span> <span class="toc-text">存储过程&#x2F;函数的修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-x2F-%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">35.5.</span> <span class="toc-text">存储过程&#x2F;函数的删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87"><span class="toc-number">36.</span> <span class="toc-text">变量、流程控制与游标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.1.</span> <span class="toc-text">系统变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.1.1.</span> <span class="toc-text">查看系统变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">36.1.1.2.</span> <span class="toc-text">修改系统变量的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.2.</span> <span class="toc-text">用户变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.2.1.</span> <span class="toc-text">会话用户变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">36.1.2.2.</span> <span class="toc-text">局部变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%92%8C%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E7%B1%BB%E4%BC%BC%EF%BC%89"><span class="toc-number">36.2.</span> <span class="toc-text">定义条件与处理程序（和异常捕获类似）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">36.2.1.</span> <span class="toc-text">定义条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">36.2.2.</span> <span class="toc-text">定义处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">36.3.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-IF"><span class="toc-number">36.3.1.</span> <span class="toc-text">分支结构之 IF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8BCASE"><span class="toc-number">36.3.2.</span> <span class="toc-text">分支结构之CASE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BLOOP"><span class="toc-number">36.3.3.</span> <span class="toc-text">循环结构之LOOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BWHILE"><span class="toc-number">36.3.4.</span> <span class="toc-text">循环结构之WHILE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BREPEAT"><span class="toc-number">36.3.5.</span> <span class="toc-text">循环结构之REPEAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8BLEAVE%E8%AF%AD%E5%8F%A5"><span class="toc-number">36.3.6.</span> <span class="toc-text">跳转语句之LEAVE语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8BITERATE%E8%AF%AD%E5%8F%A5"><span class="toc-number">36.3.7.</span> <span class="toc-text">跳转语句之ITERATE语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">36.4.</span> <span class="toc-text">游标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E9%9C%80%E8%A6%81%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">36.4.1.</span> <span class="toc-text">使用游标需要四个步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A3%B0%E6%98%8E%E6%B8%B8%E6%A0%87"><span class="toc-number">36.4.1.1.</span> <span class="toc-text">第一步，声明游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%8C%E6%89%93%E5%BC%80%E6%B8%B8%E6%A0%87"><span class="toc-number">36.4.1.2.</span> <span class="toc-text">第二步，打开游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%EF%BC%88%E4%BB%8E%E6%B8%B8%E6%A0%87%E4%B8%AD%E5%8F%96%E5%BE%97%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">36.4.1.3.</span> <span class="toc-text">第三步，使用游标（从游标中取得数据）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%8C%E5%85%B3%E9%97%AD%E6%B8%B8%E6%A0%87"><span class="toc-number">36.4.1.4.</span> <span class="toc-text">第四步，关闭游标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">36.4.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">36.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">37.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">37.1.</span> <span class="toc-text">触发器的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">37.2.</span> <span class="toc-text">代码举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">37.3.</span> <span class="toc-text">查看触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">37.4.</span> <span class="toc-text">删除触发器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DBA%E5%91%BD%E4%BB%A4"><span class="toc-number">38.</span> <span class="toc-text">DBA命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BD%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA"><span class="toc-number">38.1.</span> <span class="toc-text">将数据库当中的数据导出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE-1"><span class="toc-number">38.2.</span> <span class="toc-text">导入数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">39.</span> <span class="toc-text">数据库设计三范式*</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="toc-number">39.1.</span> <span class="toc-text">什么是设计范式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">39.2.</span> <span class="toc-text">第一范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">39.3.</span> <span class="toc-text">第二范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">39.3.1.</span> <span class="toc-text">多对多怎么设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">39.4.</span> <span class="toc-text">第三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">39.4.1.</span> <span class="toc-text">一对多怎么设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">39.5.</span> <span class="toc-text">一对一怎么设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A2%E8%AE%B0"><span class="toc-number">40.</span> <span class="toc-text">牢记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/TypeScript/" title="TypeScript">TypeScript</a><time datetime="2023-07-16T09:57:35.000Z" title="发表于 2023-07-16 17:57:35">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/React%E5%85%A8%E5%AE%B6%E6%A1%B6-%E6%8A%80%E6%9C%AF%E6%A0%88/" title="React全家桶(技术栈)">React全家桶(技术栈)</a><time datetime="2023-07-16T09:57:21.000Z" title="发表于 2023-07-16 17:57:21">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/03/%E5%B0%9A%E7%A1%85%E8%B0%B7Web%E5%89%8D%E7%AB%AFES6%E6%95%99%E7%A8%8B%EF%BC%8C%E6%B6%B5%E7%9B%96ES6-ES11/" title="尚硅谷Web前端ES6教程，涵盖ES6-ES11">尚硅谷Web前端ES6教程，涵盖ES6-ES11</a><time datetime="2023-07-03T00:43:42.000Z" title="发表于 2023-07-03 08:43:42">2023-07-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/30/2023%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%9B%BD%E9%99%85%E6%95%B0%E5%AD%97%E5%92%8C%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B/" title="2023年中国国际数字和软件服务创新大赛">2023年中国国际数字和软件服务创新大赛</a><time datetime="2023-06-30T10:18:35.000Z" title="发表于 2023-06-30 18:18:35">2023-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/29/SSH%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/" title="SSH框架复习">SSH框架复习</a><time datetime="2023-06-29T12:56:37.000Z" title="发表于 2023-06-29 20:56:37">2023-06-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://hakaimg.com/i/2022/08/11/xhvqca.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 小白菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到小白菜的blog~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>