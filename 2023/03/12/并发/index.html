<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>并发 | 是小白菜哦</title><meta name="author" content="小白菜"><meta name="copyright" content="小白菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程和线程进程与线程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。 进程就是用来加载指令、管理内存、管理 IO 的，当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（比如开两个qq），也有的程序只能启动一个实例进">
<meta property="og:type" content="article">
<meta property="og:title" content="并发">
<meta property="og:url" content="http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="是小白菜哦">
<meta property="og:description" content="进程和线程进程与线程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。 进程就是用来加载指令、管理内存、管理 IO 的，当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（比如开两个qq），也有的程序只能启动一个实例进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg">
<meta property="article:published_time" content="2023-03-12T09:12:57.000Z">
<meta property="article:modified_time" content="2023-07-16T09:56:03.742Z">
<meta property="article:author" content="小白菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/132124.png"><link rel="canonical" href="http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '并发',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-16 17:56:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">是小白菜哦</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-12T09:12:57.000Z" title="发表于 2023-03-12 17:12:57">2023-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-16T09:56:03.742Z" title="更新于 2023-07-16 17:56:03">2023-07-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="并发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。</li>
<li>进程就是用来加载指令、管理内存、管理 IO 的，当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（比如开两个qq），也有的程序只能启动一个实例进程（比如你打开了网易云音乐，再打开还是那个应用等）</li>
</ul>
<p><strong>二者对比</strong></p>
<ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 </p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享 </p>
</li>
<li><p>进程间通信较为复杂 </p>
</li>
<li><ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication） </li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p> 单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。总结为一句话就是： 微观串行，宏观并行 </p>
<p> 一般会将这种线程轮流使用 CPU 的做法称为并发， concurrent  </p>
<p>但是在多核cpu下，每个核都可以调度线程，这时候线程可以并行</p>
<p> 引用 Rob Pike 的一段描述： </p>
<ul>
<li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力 </li>
<li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li>
</ul>
<p>这里</p>
<p>并发的意思是比如你一个人做多件事情但是每个都做一点，就是应对</p>
<p>并行的意思就是两个人做两件事情，互不干扰</p>
<p><strong>例子</strong> </p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发 </li>
<li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）  </li>
<li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673361304968-e8178bb7-5183-4a2a-9ce4-bd522355ec47.png" alt="img"></p>
<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h2><p>原理之 Thread 与 Runnable 的关系 </p>
<p>分析 Thread 的源码，理清它与 Runnable 的关系 </p>
<p><strong>小结</strong> </p>
<ul>
<li>直接用Thread是把线程和任务合并在了一起，使用Runnable 是把线程和任务分开了 </li>
<li>用 Runnable 更容易与线程池等高级 API 配合 </li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<p> <strong>FutureTask 配合 Thread</strong></p>
<p>  FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<span class="comment">//这里创建了一个Callable的内部类</span></span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>

<h2 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h2><p><strong>windows</strong></p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist 查看进程</li>
<li>taskkill 杀死进程</li>
</ul>
<p><strong>linux</strong></p>
<ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li>
<li>kill 杀死进程</li>
<li>top 按大写 H 切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程（PID）的所有线程</li>
</ul>
<p><strong>Java</strong></p>
<ul>
<li>jps 命令查看所有 Java 进程</li>
<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<h2 id="原理之线程运行"><a href="#原理之线程运行" class="headerlink" title="原理之线程运行"></a>原理之线程运行</h2><p><strong>栈与栈帧</strong></p>
<p>Java Virtual Machine Stacks （Java 虚拟机栈）</p>
<p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h2 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h2><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念</p>
<p>程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1673416290996-a681950e-4987-4024-81e8-e38aae29bf15.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673416300822-4b63e3cb-c1ca-4127-a803-de36a48e3b2a.png" alt="img"></p>
<h2 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h2><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </p>
<p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码  </p>
<h2 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h2><p><strong>sleep</strong></p>
<p>\1. 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p>
<p>\2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
<p>\3. 睡眠结束后的线程未必会立刻得到执行</p>
<p>\4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<p><strong>yield</strong></p>
<p>\1. 调用 yield（让出） 会让当前线程从 Running 进入 Runnable 就绪状态（操作系统只会把时间片分配给Runnable状态的线程），然后调度执行其它线程</p>
<p>\2. 具体的实现依赖于操作系统的任务调度器（也就是说，如果没有其他线程需要cpu执行，那cpu仍然会执行调用yield方法的线程，直到执行完成）</p>
<p><strong>线程优先级</strong></p>
<p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
<p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
<p><strong>应用</strong></p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673422098553-0394474b-3be8-4731-bc52-541e1ce7301b.png" alt="img"></p>
<h2 id="join-方法详解"><a href="#join-方法详解" class="headerlink" title="join 方法详解"></a>join 方法详解</h2><p>Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。</p>
<h3 id="为什么需要-join"><a href="#为什么需要-join" class="headerlink" title="为什么需要 join"></a><strong>为什么需要 join</strong></h3><p> 下面的代码执行，打印 r 是什么？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这里的static仅仅是为了让主方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">//睡一秒钟</span></span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<ul>
<li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r&#x3D;10</li>
<li>而主线程一开始就要打印 r 的结果，所以只能打印出 r&#x3D;0</li>
</ul>
<p><strong>解决方法</strong></p>
<p>用 sleep 行不行？为什么？</p>
<p>可行也不太行，因为你并不知道那个线程里面会执行多长时间，也就无法编写sleep的时间</p>
<p>用 join，加在 t1.start() 之后即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这里的static仅仅是为了让主方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">//睡一秒钟</span></span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();<span class="comment">//哪个线程调用t1，就得阻塞直到t1线程执行完成</span></span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就是先了线程的同步</p>
<h3 id="有时效的-join"><a href="#有时效的-join" class="headerlink" title="有时效的 join"></a>有时效的 join</h3><p>可以给join方法里面加一个参数，意思是最大等待时间</p>
<ul>
<li>如果超过了这个最大等待时间那个线程还没执行完，就会不再进行阻塞当前线程，继续向下执行</li>
<li>如果还没超过那个最大等待时间就执行完了，也不会进行阻塞了，会继续往下执行</li>
</ul>
<h2 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h2><p>我的理解是 isInterrupted（）得到的方法的true或false，比如你打断了一个正常运行的线程，那他就是true（也就是被打断的意思），如果是处于sleep，wait，join 的线程 ，说明他不应该被打断啊，所以返回的是false </p>
<h3 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 sleep，wait，join 的线程</h3><p> 这几个方法都会让线程进入阻塞状态</p>
<p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     	sleep(<span class="number">1</span>);</span><br><span class="line">     &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     t1.start();</span><br><span class="line">     sleep(<span class="number">0.5</span>);</span><br><span class="line">     t1.interrupt();</span><br><span class="line"><span class="comment">//这里得到的答案是false，因为如果打断的时候该线程处于上面三种方法中，会自动修改那个线程的isInterrupted属性为false</span></span><br><span class="line">     log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h3><p> 打断正常运行的线程, 不会清空打断状态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">             <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();<span class="comment">//这里是true</span></span><br><span class="line">             <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">     t2.start();</span><br><span class="line">     sleep(<span class="number">0.5</span>);</span><br><span class="line">     t2.interrupt();<span class="comment">//会修改interrupted属性为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>这个模式是模拟如果要你编写一个监控系统，让你控制监控系统的开始和停止，并且停止需要优雅的停止</p>
<p><strong>错误思路</strong></p>
<ul>
<li><p>使用线程对象的 stop() 方法停止线程</p>
</li>
<li><ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
</ul>
</li>
<li><p>使用 System.exit(int) 方法停止线程</p>
</li>
<li><ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
</li>
</ul>
<p><strong>正确思路</strong></p>
<p>使用interrupt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//进行监控操作</span></span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//如果没有下面这条是不行的，具体看上面sleep的时候被打断</span></span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h3><p> 打断 park 线程, 不会清空打断状态属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">           LockSupport.park();</span><br><span class="line">           log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">           log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<span class="comment">//这时候为true，很像正常时候被打断之后的情况</span></span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       t1.start();</span><br><span class="line">       sleep(<span class="number">0.5</span>);</span><br><span class="line">       t1.interrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是： 如果打断标记已经是 true, 则 park 会失效  ，也就是说不会再使用park也不会停下来了，如果想再次暂停的话，需要把打断标记置为false</p>
<p> 提示 </p>
<p>可以使用 Thread.interrupted() 清除打断状态  </p>
<h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p> 还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673426276801-5d40b4b7-e51a-4c21-8f93-fe2800e79761.png" alt="img"></p>
<h2 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h2><p> 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。  </p>
<p> 举个例子：</p>
<p>垃圾回收器线程就是一种守护线程 </p>
<p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求  </p>
<p>从这里可以知道，这个守护线程就是打工人，老板跑路了，打工人就没必要干下去了</p>
<h2 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h2><p> 这是从 <strong>操作系统</strong> 层面来描述的  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673427830935-0ae94785-df0d-4fee-a5ac-23f0cfb2592e.png" alt="img"></p>
<ul>
<li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p>
</li>
<li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p>
</li>
<li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p>
</li>
<li><ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li><p>【阻塞状态】</p>
</li>
<li><ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ul>
<h2 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h2><p>这是从 Java API 层面来描述的 </p>
<p>根据 Thread.State 枚举，分为六种状态  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1673427912453-8a033157-fbc6-406c-a4da-ca00654f9ff6.png" alt="img"></p>
<ul>
<li>NEW 线程刚被创建，但是还没有调用 start() 方法</li>
<li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li>
<li>TERMINATED 当线程代码运行结束</li>
</ul>
<p>如何进入这些状态呢：下面举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">// runnable</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); <span class="comment">// timed_waiting</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); <span class="comment">// waiting</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123; <span class="comment">// blocked</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><p> 两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>问题分析</strong>  </p>
<p> 以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析 </p>
<p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：  （这个静态变量i以后会和局部变量i做对比）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 自增</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p> 而对应 i– 也是类似：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 自减</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p> 而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673787897607-73e6cc40-aadb-46c5-9674-e98c56cca233.png" alt="img"></p>
<p>如果是多线程的情况下，就有可能指令交错执行，所以要确保线程安全的问题</p>
<p>下面以一个出现负数的情况为例子：</p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673787962822-22c3296a-2009-49e8-a58f-cffac7c70720.png" alt="img"></p>
<p>出现正数的情况同理了</p>
<p><strong>临界区 Critical Section</strong>  </p>
<ul>
<li><p>一个程序运行多个线程本身是没有问题的</p>
</li>
<li><p>问题出在多个线程访问共享资源</p>
</li>
<li><ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p>
</li>
</ul>
<p> 例如，下面代码中的临界区  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">decrement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	 counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>竞态条件 Race Condition</strong>  </p>
<p> 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong>  </p>
<p>上面出现多种结果的情况就是竞态条件</p>
<h2 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h2><p>这种情况其实叫<strong>互斥</strong></p>
<p>​     为了避免临界区的竞态条件发生，有多种手段可以达到目的。 </p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock </li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>​     本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换  </p>
<p> 注意 </p>
<p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： </p>
<ul>
<li>互斥  是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 </li>
<li>同步  是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<p> 解决  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p> 语法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) <span class="comment">//利用synchronized把对象给锁住</span></span><br><span class="line">&#123;</span><br><span class="line">    临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 思考  </p>
<p> synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。  </p>
<h3 id="面向对象改进"><a href="#面向对象改进" class="headerlink" title="面向对象改进"></a>面向对象改进</h3><p> 把需要保护的共享变量放入一个类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            value--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                    room.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                    room.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span> , room.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h2><p>普通方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="所谓的“线程八锁”"><a href="#所谓的“线程八锁”" class="headerlink" title="所谓的“线程八锁”"></a>所谓的“线程八锁”</h3><p> 其实就是考察 synchronized 锁住的是哪个对象  </p>
<p> 情况1：12 或 21  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况2：1s后12，或 2 1s后 1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况3：3 1s 12 或 23 1s 1 或 32 1s 1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况4：2 1s 后 1  （因为锁的不是一个对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况5：2 1s 后 1  （锁住的不是一个对象，一个是类对象，一个是普通对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况6：1s 后12， 或 2 1s后 1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况7：2 1s 后 1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 情况8：1s 后12， 或 2 1s后 1  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><ul>
<li><p>如果它们没有共享，则线程安全</p>
</li>
<li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p>
</li>
<li><ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h3><ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>但局部变量引用的对象则未必</p>
</li>
<li><ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><h4 id="普通局部变量"><a href="#普通局部变量" class="headerlink" title="普通局部变量"></a>普通局部变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享  </p>
<p>下面是局部变量的字节码：（这就是上面提到过的跟静态成员变量相比）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line"> stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span>: istore_0</span><br><span class="line"> <span class="number">3</span>: iinc <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"> <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line"> LineNumberTable:</span><br><span class="line"> line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line"> line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line"> line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"> Start Length Slot Name Signature</span><br><span class="line"> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> i I</span><br></pre></td></tr></table></figure>

<p>每一个线程都会在栈中创建自己的局部变量：</p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673789840591-5e4b2046-4e4b-45ec-9f6e-f569dd6d8e08.png" alt="img"> </p>
<h4 id="局部变量的引用"><a href="#局部变量的引用" class="headerlink" title="局部变量的引用"></a>局部变量的引用</h4><p>局部变量的引用稍有不同 </p>
<p>先看一个成员变量的例子  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="comment">// &#123; 临界区, 会产生竞态条件</span></span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                test.method1(<span class="number">200</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然这种是线程不安全的， 其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错</p>
<p> 分析： </p>
<ul>
<li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量 </li>
<li>method3 与 method2 分析相同</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1673790483555-c6a69757-2912-4bd1-9fa5-0918541f4676.png" alt="img"></p>
<p> 将 list 修改为局部变量  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 那么就不会有上述问题了  </p>
<p>分析：</p>
<ul>
<li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li>
<li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</li>
<li>method3 的参数分析与 method2 相同</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1673790543560-f14a8d0e-aa5b-4c2f-8a57-aa63e0300975.png" alt="img"></p>
<p> 方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？ </p>
<ul>
<li>情况1：有其它线程调用 method2 和 method3 </li>
<li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                test.method1(<span class="number">200</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，子类又启动了一个新的线程，但是这个线程里面的代码，你不知道他啥时候执行，所以又会有线程安全的问题</p>
<p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】  </p>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为：</p>
<ul>
<li>它们的每个方法是原子的 </li>
<li>但注意它们多个方法的组合不是原子的，见后面分析</li>
</ul>
<p>Integer的读操作是线程安全的，写操作是线程不安全的，要想都线程安全，还是需要使用AtomicInteger</p>
<h3 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h3><p> 分析下面代码是否线程安全？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675128245862-f7711fd5-889f-48b6-a382-c359318e5f50.png" alt="img"></p>
<p>答案是不安全，虽然每个方法都是线程安全的方法，但是两个方法组合起来就线程不安全了</p>
<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p>
<p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Immutable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Immutable</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Immutable <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Immutable</span>(<span class="built_in">this</span>.value + v);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是创建一个新的对象</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p> 例1：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//不安全</span></span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">//安全</span></span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;<span class="comment">//安全按</span></span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//不安全</span></span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用上述变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 记录调用次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;<span class="comment">//这里需要加一个synchronized关键字，来保证多个线程进入这个方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 例3：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全？</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//no安全，因为spring默认创建对象是单例的，</span></span><br><span class="line">        <span class="comment">//解决方法就是用一个around环绕通知，把变量都做成局部变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0L</span>;<span class="comment">//可能有多个线程修改这个变量</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">            start = System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 例4：  </p>
<p>都是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 是否安全</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不安全！！这里会有多线程错误，conn被多个线程共享，可能会被其他线程改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 例6：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="comment">//安全，但是创建了多个userDao对象，浪费内存</span></span><br><span class="line">    <span class="type">private</span> <span class="variable">Connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 例7：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//不安全，子类又创建了线程，暴露出了地址</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sdf.parse(dateStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是String为了避免新建线程的。Sting类是final的，就是为了避免重写string然后再在子类中新建线程导致线程不安全（大聪明行为）</p>
<h2 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p> 以 32 位虚拟机为例  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675131066059-9d3b214b-0378-4733-9185-2ca9d3c25cd7.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675131101043-f12d6ef0-1252-45b2-a633-2765ba97f558.png" alt="img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675131114519-7248bd06-9cc6-49f6-8da2-a94d8c02d217.png" alt="img"></p>
<h3 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h3><p> Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong> </p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针 </p>
<p>Monitor 结构如下  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675131283044-56a10c41-35ba-474a-948d-465b87297c91.png" alt="img"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，<strong>Monitor中只能有一个 Owner</strong></li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但<strong>条件不满足</strong>进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<p> 注意： </p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
<h3 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对应的字节码为  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line"> descriptor: ([Ljava/lang/String;)V</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">     Code:</span><br><span class="line"> stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line"> <span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// &lt;- lock引用 （synchronized开始）</span></span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: astore_1 <span class="comment">// lock引用 -&gt; slot 1</span></span><br><span class="line"> <span class="number">5</span>: monitorenter <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line"> <span class="number">6</span>: getstatic #<span class="number">3</span> <span class="comment">// &lt;- i</span></span><br><span class="line"> <span class="number">9</span>: iconst_1 <span class="comment">// 准备常数 1</span></span><br><span class="line"> <span class="number">10</span>: iadd <span class="comment">// +1</span></span><br><span class="line"> <span class="number">11</span>: putstatic #<span class="number">3</span> <span class="comment">// -&gt; i</span></span><br><span class="line"> <span class="number">14</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line"> <span class="number">15</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line"> <span class="number">16</span>: goto <span class="number">24</span></span><br><span class="line"> <span class="number">19</span>: astore_2 <span class="comment">// e -&gt; slot 2 </span></span><br><span class="line"> <span class="number">20</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line"> <span class="number">21</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line"> <span class="number">22</span>: aload_2 <span class="comment">// &lt;- slot 2 (e)</span></span><br><span class="line"> <span class="number">23</span>: athrow <span class="comment">// throw e</span></span><br><span class="line"> <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line"> Exception table:</span><br><span class="line"> from to target type</span><br><span class="line"> <span class="number">6</span> <span class="number">16</span> <span class="number">19</span> any</span><br><span class="line"> <span class="number">19</span> <span class="number">22</span> <span class="number">19</span> any</span><br><span class="line"> LineNumberTable:</span><br><span class="line"> line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line"> line <span class="number">9</span>: <span class="number">6</span></span><br><span class="line"> line <span class="number">10</span>: <span class="number">14</span></span><br><span class="line"> line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"> Start Length Slot Name Signature</span><br><span class="line"> <span class="number">0</span> <span class="number">25</span> <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line"> StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line"> frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line"> offset_delta = <span class="number">19</span></span><br><span class="line"> locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line"> stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line"> frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line"> offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p> 注意 </p>
<p>方法级别的 synchronized 不会在字节码指令中有所体现  </p>
<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>故事角色</p>
<ul>
<li>老王 - JVM</li>
<li>小南 - 线程</li>
<li>小女 - 线程</li>
<li>房间 - 对象</li>
<li>房间门上 - 防盗锁 - Monitor</li>
<li>房间门上 - 小南书包 - 轻量级锁</li>
<li>房间门上 - 刻上小南大名 - 偏向锁</li>
<li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</li>
<li>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</li>
</ul>
<p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。</p>
<p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？</p>
<p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。</p>
<p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。</p>
<p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。</p>
<p>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字</p>
<p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p>
<h3 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h3><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p> 轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。 如果有竞争，就会从轻量级锁升级成重量级锁</p>
<p>轻量级锁对使用者是透明的，即语法仍然是 synchronized </p>
<p>假设有两个方法同步块，利用同一个对象加锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1676795954667-3dfde7fd-9fe3-4c19-b425-955b8a597815.png" alt="img"></p>
<p> 让锁记录中 Object reference 指向锁对象，并尝试用 cas <strong>替换</strong>（用线程的00交换01） Object 的 Mark Word，将 Mark Word 的值存入锁记录  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134090094-b62a187c-27b8-4d7b-9cfc-6525290d7e90.png" alt="img"></p>
<p> 如果 cas 替换成功（说明加锁成功了），对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134103280-3a0ea794-9fba-4445-9a87-0a95533e03a7.png" alt="img"></p>
<ul>
<li><p>如果 cas 失败，有两种情况 </p>
</li>
<li><ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134130857-786686d1-1c3b-4d14-89b0-1a44549ce521.png" alt="img"></p>
<p> 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134145848-7f8143db-8177-40ef-9401-b6425d83b80f.png" alt="img"></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p>
</li>
<li><ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p> 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675134617557-4266ff62-d890-4691-be46-5d8cb1b76711.png" alt="img"></p>
<ul>
<li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 </p>
</li>
<li><ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134644102-fe6ee48b-3fc2-4040-8cf1-081c86f134d8.png" alt="img"> 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程  </p>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p><strong>重量级锁竞争的时候</strong>，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。 </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134773160-5a3248b4-a6a6-4d6f-9e7f-1f825c0f2405.png" alt="img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134781343-1f4e9761-7b07-4e1a-aef3-3aae4d86c31e.png" alt="img"></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 </li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作（也就是上面写轻量级锁时候的替换用00markword替换01 ）。 </p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS <strong>将线程 ID</strong> <strong>设置到对象的 Mark Word 头</strong>，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>
<p>例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675134986080-6185951d-b933-4c54-a32b-3c469609d91e.png" alt="img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675134994390-2d91f3db-8bc2-4fc4-a80e-90cc92018d02.png" alt="img"></p>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1676796765955-50608d25-6203-4f25-93c7-1974ac04c168.png" alt="img"></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启）什么时候最好使用偏向锁：当只有一个线程执行代码时，没有冲突的时候最好使用偏向锁，如果有多个线程的话，最好把偏向锁给禁用掉，因为每个对象创建后都会自动是开启偏向锁的，那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<p> <strong>测试偏向锁</strong>  </p>
<p> 利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="type">ClassLayout</span> <span class="variable">classLayout</span> <span class="operator">=</span> ClassLayout.parseInstance(d);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 前&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;synchronized 中&quot;</span>);</span><br><span class="line">            System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;synchronized 后&quot;</span>);</span><br><span class="line">        System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:08:<span class="number">58.117</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 前</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> </span><br><span class="line"><span class="number">11</span>:08:<span class="number">58.121</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 中</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">11101011</span> <span class="number">11010000</span> <span class="number">00000101</span> </span><br><span class="line"><span class="number">11</span>:08:<span class="number">58.121</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 后</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">11101011</span> <span class="number">11010000</span> <span class="number">00000101</span> </span><br></pre></td></tr></table></figure>

<p><strong>测试禁用偏向锁</strong></p>
<p>在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁 </p>
<p>输出  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675135621117-ba3331aa-5809-407b-82d0-0c8de4dfb89e.png" alt="img"></p>
<p>需要注意的是：</p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675131114519-7248bd06-9cc6-49f6-8da2-a94d8c02d217.png" alt="img"></p>
<p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成  （但是如果这个对象调用了hashcode方法生成hashcode了。对象头里面就没有位置给threadid了，所以生成了hashcode之后就会解除偏向锁的状态）</p>
<h4 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h4><p> 刚开始对象的锁是偏向锁，偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销  </p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
<h4 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h4><p>具体来说，当只有一个线程访问对象时，Java虚拟机会将该对象的锁状态升级为偏向锁状态，此时该线程可以直接获取对象的锁，而不需要进行任何同步操作，从而提高了程序的性能。</p>
<p>当有多个线程同时访问同一个对象时，偏向锁会失效，Java虚拟机会将该对象的锁状态升级为轻量级锁状态。轻量级锁通过CAS（Compare and Swap）操作来实现锁的获取和释放，相比于重量级锁，轻量级锁的开销更小，能够更快地进行锁的升级和降级，从而提高了程序的并发性能。</p>
<p><strong>那什么时候会升级成重量级锁呢？</strong></p>
<p>一个锁对象会从偏向锁升级到轻量级锁后，如果仍然有多个线程竞争同一个锁对象，就有可能升级为重量级锁。轻量级锁的实现是基于自旋锁的，即当一个线程尝试获取轻量级锁失败后，会自旋一段时间等待锁被释放。如果自旋超过一定的次数或者等待时间超过一定的阈值，那么轻量级锁会膨胀为重量级锁，即线程会进入阻塞状态等待锁的释放。</p>
<p>重量级锁是基于操作系统的互斥量实现的，需要进行用户态和内核态之间的切换，所以在高并发情况下，重量级锁的性能会受到较大的影响。因此，JVM 在实现锁机制时，会尽量使用偏向锁和轻量级锁，只有在必要的情况下才会升级为重量级锁，以提高并发性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">            TestBiased.class.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span></span><br><span class="line">    <span class="comment">// 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span></span><br><span class="line">    <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">        System.in.read();</span></span><br><span class="line"><span class="comment">    &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">        e.printStackTrace();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">	&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">	t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TestBiased.class.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    	t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[t1] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">01000001</span> <span class="number">00010000</span> <span class="number">00000101</span> </span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">01000001</span> <span class="number">00010000</span> <span class="number">00000101</span> </span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">10110101</span> <span class="number">11110000</span> <span class="number">01000000</span> 升级为轻量级锁</span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> 变为正常状态，不是偏向锁状态了</span><br></pre></td></tr></table></figure>

<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p> 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID </p>
<p>当<strong>撤销偏向锁</strong>阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        list.add(d);</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        list.notify();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><p> 小故事 - 为什么需要 wait  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1676798122370-5a6606f9-6277-4efc-ba97-a18a01a1588e.png" alt="img"></p>
<h3 id="wait-notify-原理"><a href="#wait-notify-原理" class="headerlink" title="wait notify 原理"></a>wait notify 原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675137428722-42972ef4-faa9-4dc4-acc3-c624d94b37df.png" alt="img"></p>
<h3 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h3><ul>
<li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待 </li>
<li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li>
<li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<p> 它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        obj.notify(); <span class="comment">// 唤醒obj上一个线程</span></span><br><span class="line">        <span class="comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> notify 的一种结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">53.096</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">53.099</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">55.096</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">20</span>:<span class="number">00</span>:<span class="number">55.096</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 其它代码.... </span><br></pre></td></tr></table></figure>

<p> notifyAll 的结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">15.457</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">15.460</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 执行.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [main] c.TestWaitNotify - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [Thread-<span class="number">1</span>] c.TestWaitNotify - 其它代码.... </span><br><span class="line"><span class="number">19</span>:<span class="number">58</span>:<span class="number">17.456</span> [Thread-<span class="number">0</span>] c.TestWaitNotify - 其它代码.... </span><br></pre></td></tr></table></figure>





<p>除此之外，wait还有一个有参数的方法，作为等待的时间</p>
<p>wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止 </p>
<p>wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify  </p>
<h2 id="wait-notify-的正确姿势"><a href="#wait-notify-的正确姿势" class="headerlink" title="wait notify 的正确姿势"></a>wait notify 的正确姿势</h2><p> 开始之前先看看  </p>
<p> <strong>sleep(long n) 和 wait(long n) 的区别</strong>  </p>
<p>\1) sleep 是 Thread 方法，而 wait 是 Object 的方法 </p>
<p>\2) sleep 不需要（不需要获取锁）强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用 </p>
<p>\3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 </p>
<p>\4) 它们的状态都是 TIMED_WAITING  </p>
<p><strong>第一种情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.883</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.887</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">50.882</span> [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure>

<ul>
<li>其它干活的线程，都要一直阻塞，效率太低 </li>
<li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来 </li>
<li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加synchronized 就好像 main 线程是翻窗户进来的 </li>
<li>解决方法，使用 wait - notify 机制</li>
</ul>
<p><strong>第二种情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasCigarette = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.489</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.493</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.493</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.493</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.494</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.494</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">42.494</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">43.490</span> [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">43.490</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">51</span>:<span class="number">43.490</span> [小南] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>解决了其它干活的线程阻塞的问题 </li>
<li>但如果有其它线程也在等待条件呢？ （送烟的也可能叫错人）</li>
</ul>
<p><strong>第三种情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.173</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">12.176</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">53</span>:<span class="number">13.174</span> [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure>

<ul>
<li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线 程，称之为【虚假唤醒】 </li>
<li>解决方法，改为 notifyAll</li>
</ul>
<p><strong>第四种情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新 判断的机会了 </li>
<li>解决方法，用 while + wait，当条件不成立，再次 wait</li>
</ul>
<p><strong>第五种情况</strong></p>
<p> 将 if 改为 while  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 改动后  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.322</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">34.326</span> [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.323</span> [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">58</span>:<span class="number">35.324</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br></pre></td></tr></table></figure>

<h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p> 即 Guarded Suspension，用在一个线程等待另一个线程的执行结果  </p>
<p>要点</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675145567979-e19589a4-1302-43f9-aaf4-509b6a41b9e7.png" alt="img"></p>
<h3 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件不满足则等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 一个线程等待另一个线程的执行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 子线程执行下载</span></span><br><span class="line">            List&lt;String&gt; response = download();</span><br><span class="line">            log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">            guardedObject.complete(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程阻塞等待</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.get();</span><br><span class="line">    log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超时版"><a href="#超时版" class="headerlink" title="超时版"></a>超时版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObjectV2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, </span><br><span class="line">                          timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试，没有超时  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObjectV2</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectV2</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        v2.complete(<span class="literal">null</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        v2.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> v2.get(<span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">08:<span class="number">49</span>:<span class="number">39.917</span> [main] c.GuardedObjectV2 - waitTime: <span class="number">2500</span></span><br><span class="line">08:<span class="number">49</span>:<span class="number">40.917</span> [Thread-<span class="number">0</span>] c.GuardedObjectV2 - notify...</span><br><span class="line">08:<span class="number">49</span>:<span class="number">40.917</span> [main] c.GuardedObjectV2 - timePassed: <span class="number">1003</span>, object is <span class="literal">null</span> <span class="literal">true</span></span><br><span class="line">08:<span class="number">49</span>:<span class="number">40.917</span> [main] c.GuardedObjectV2 - waitTime: <span class="number">1497</span></span><br><span class="line">08:<span class="number">49</span>:<span class="number">41.918</span> [Thread-<span class="number">0</span>] c.GuardedObjectV2 - notify...</span><br><span class="line">08:<span class="number">49</span>:<span class="number">41.918</span> [main] c.GuardedObjectV2 - timePassed: <span class="number">2004</span>, object is <span class="literal">null</span> <span class="literal">false</span></span><br><span class="line">08:<span class="number">49</span>:<span class="number">41.918</span> [main] c.TestGuardedObjectV2 - get response: [<span class="number">3</span>] lines</span><br></pre></td></tr></table></figure>

<p> 测试，超时  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待时间不足</span></span><br><span class="line">List&lt;String&gt; lines = v2.get(<span class="number">1500</span>);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">08:<span class="number">47</span>:<span class="number">54.963</span> [main] c.GuardedObjectV2 - waitTime: <span class="number">1500</span></span><br><span class="line">08:<span class="number">47</span>:<span class="number">55.963</span> [Thread-<span class="number">0</span>] c.GuardedObjectV2 - notify...</span><br><span class="line">08:<span class="number">47</span>:<span class="number">55.963</span> [main] c.GuardedObjectV2 - timePassed: <span class="number">1002</span>, object is <span class="literal">null</span> <span class="literal">true</span></span><br><span class="line">08:<span class="number">47</span>:<span class="number">55.963</span> [main] c.GuardedObjectV2 - waitTime: <span class="number">498</span></span><br><span class="line">08:<span class="number">47</span>:<span class="number">56.461</span> [main] c.GuardedObjectV2 - timePassed: <span class="number">1500</span>, object is <span class="literal">null</span> <span class="literal">true</span></span><br><span class="line">08:<span class="number">47</span>:<span class="number">56.461</span> [main] c.GuardedObjectV2 - waitTime: <span class="number">0</span></span><br><span class="line">08:<span class="number">47</span>:<span class="number">56.461</span> [main] c.GuardedObjectV2 - <span class="keyword">break</span>...</span><br><span class="line">08:<span class="number">47</span>:<span class="number">56.461</span> [main] c.TestGuardedObjectV2 - can<span class="string">&#x27;t get response</span></span><br><span class="line"><span class="string">08:47:56.963 [Thread-0] c.GuardedObjectV2 - notify...</span></span><br></pre></td></tr></table></figure>

<h2 id="异步模式之生产者-x2F-消费者"><a href="#异步模式之生产者-x2F-消费者" class="headerlink" title="异步模式之生产者&#x2F;消费者"></a>异步模式之生产者&#x2F;消费者</h2><p>要点</p>
<ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675146272877-97b89dbf-31d5-47d9-bf62-42a25ef90ab5.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object message;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id, Object message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; queue;<span class="comment">//双向队列在Java中的实现是双向链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;没货了, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="comment">//如果不满的话就进行存储</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;库存已达上限, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(message);</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MessageQueue</span> <span class="variable">messageQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 4 个生产者线程, 下载任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;download...&quot;</span>);</span><br><span class="line">            List&lt;String&gt; response = Downloader.download();</span><br><span class="line">            log.debug(<span class="string">&quot;try put message(&#123;&#125;)&quot;</span>, id);</span><br><span class="line">            messageQueue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 个消费者线程, 处理结果</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.take();</span><br><span class="line">        List&lt;String&gt; response = (List&lt;String&gt;) message.getMessage();</span><br><span class="line">        log.debug(<span class="string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 某次运行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38.070</span> [生产者<span class="number">3</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38.070</span> [生产者<span class="number">0</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38.070</span> [消费者] c.MessageQueue - 没货了, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38.070</span> [生产者<span class="number">1</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38.070</span> [生产者<span class="number">2</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.236</span> [生产者<span class="number">1</span>] c.TestProducerConsumer - <span class="keyword">try</span> put <span class="title function_">message</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.237</span> [生产者<span class="number">2</span>] c.TestProducerConsumer - <span class="keyword">try</span> put <span class="title function_">message</span><span class="params">(<span class="number">2</span>)</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.236</span> [生产者<span class="number">0</span>] c.TestProducerConsumer - <span class="keyword">try</span> put <span class="title function_">message</span><span class="params">(<span class="number">0</span>)</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.237</span> [生产者<span class="number">3</span>] c.TestProducerConsumer - <span class="keyword">try</span> put <span class="title function_">message</span><span class="params">(<span class="number">3</span>)</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.239</span> [生产者<span class="number">2</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [生产者<span class="number">1</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="title function_">message</span><span class="params">(<span class="number">0</span>)</span>: [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [生产者<span class="number">2</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="title function_">message</span><span class="params">(<span class="number">3</span>)</span>: [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="title function_">message</span><span class="params">(<span class="number">1</span>)</span>: [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="title function_">message</span><span class="params">(<span class="number">2</span>)</span>: [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41.240</span> [消费者] c.MessageQueue - 没货了, wait</span><br></pre></td></tr></table></figure>

<h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h2><p> 它们是 LockSupport 类中的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>



<p><strong>举例：</strong></p>
<p> 先 park 再 unpark  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">52.585</span> c.TestParkUnpark [t1] - start... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">53.589</span> c.TestParkUnpark [t1] - park... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">54.583</span> c.TestParkUnpark [main] - unpark... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">54.583</span> c.TestParkUnpark [t1] - resume... </span><br></pre></td></tr></table></figure>

<p>先 unpark 再 park  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">50.765</span> c.TestParkUnpark [t1] - start... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">51.764</span> c.TestParkUnpark [main] - unpark... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">52.769</span> c.TestParkUnpark [t1] - park... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">52.769</span> c.TestParkUnpark [t1] - resume... </span><br></pre></td></tr></table></figure>

<p> <strong>特点</strong>  </p>
<p> 与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必  </li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h3 id="park-unpark-原理"><a href="#park-unpark-原理" class="headerlink" title="park unpark 原理"></a>park unpark 原理</h3><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻</p>
<ul>
<li><p>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</p>
</li>
<li><p>调用 park 就是要看需不需要停下来歇息</p>
</li>
<li><ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li><p>调用 unpark，就好比令干粮充足</p>
</li>
<li><ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是调用park方法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675147782924-72220c5e-0fc9-438a-9cac-cded69dc46cc.png" alt="img"></p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 <em>counter ，本情况为 0，这时，获得</em> mutex 互斥锁</li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter &#x3D; 0</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675147838208-62662e39-da75-426d-ac24-93c6d7d86367.png" alt="img"></p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>唤醒 _cond 条件变量中的 Thread_0</li>
<li>Thread_0 恢复运行</li>
<li>设置 _counter 为 0</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675147855314-28a3edc1-9244-4e80-b493-a581fbbd4935.png" alt="img"></p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li>
<li>设置 _counter 为 0</li>
</ol>
<h2 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h2><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675147984116-21e3e1d1-05b5-4762-bba8-d2d281b0b45f.png" alt="img"></p>
<p>假设有线程 Thread t</p>
<h3 id="情况-1-NEW-–-gt-RUNNABLE"><a href="#情况-1-NEW-–-gt-RUNNABLE" class="headerlink" title="情况 1 NEW –&gt; RUNNABLE"></a>情况 1 NEW –&gt; RUNNABLE</h3><ul>
<li>当调用 t.start() 方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<h3 id="情况-2-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 2 RUNNABLE &lt;–&gt; WAITING"></a>情况 2 RUNNABLE &lt;–&gt; WAITING</h3><p><strong>t 线程</strong>用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li><p>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</p>
</li>
<li><p>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</p>
</li>
<li><ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况-3-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 3 RUNNABLE &lt;–&gt; WAITING"></a>情况 3 RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p>
</li>
<li><ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况-4-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 4 RUNNABLE &lt;–&gt; WAITING"></a>情况 4 RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li><p>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</p>
</li>
<li><p>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</p>
</li>
<li><ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
</li>
<li><ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<h3 id="情况-9-RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况-9-RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况 9 RUNNABLE &lt;–&gt; BLOCKED"></a>情况 9 RUNNABLE &lt;–&gt; BLOCKED</h3><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ul>
<h3 id="情况-10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况-10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况 10 RUNNABLE &lt;–&gt; TERMINATED"></a>情况 10 RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线程所有代码运行完毕，进入 TERMINATED</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Runnable-&gt;waiting   </p>
<ol>
<li>t.join()</li>
<li>obj.wait()</li>
<li>LockSupport.park()</li>
</ol>
<p>Runnable-&gt;time_waiting</p>
<ol>
<li>t.join(long time)</li>
<li>obj.wait(long time)</li>
<li>LockSupport.parkNanos(long nanos) </li>
<li>Thread.sleep(long n)</li>
</ol>
<p>Runnable-&gt;blocked</p>
<ol>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ol>
<h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>使用多把不相干的锁</p>
<p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>解决方法是准备多个房间（多个对象锁）</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    bigRoom.study();</span><br><span class="line">&#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    bigRoom.sleep();</span><br><span class="line">&#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 某次结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">13</span>:<span class="number">54.471</span> [小南] c.BigRoom - study <span class="number">1</span> 小时</span><br><span class="line"><span class="number">12</span>:<span class="number">13</span>:<span class="number">55.476</span> [小女] c.BigRoom - sleeping <span class="number">2</span> 小时</span><br></pre></td></tr></table></figure>

<p>可以发现，两个动作并不能同时执行</p>
<p>所以我们可以改进为两个锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bedRoom) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 某次执行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">15</span>:<span class="number">35.069</span> [小南] c.BigRoom - study <span class="number">1</span> 小时</span><br><span class="line"><span class="number">12</span>:<span class="number">15</span>:<span class="number">35.069</span> [小女] c.BigRoom - sleeping <span class="number">2</span> 小时</span><br></pre></td></tr></table></figure>

<p>可以发现利用率变高咯</p>
<p>将锁的粒度细分 </p>
<ul>
<li>好处，是可以增强并发度 </li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p> 活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p> 很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题 </p>
<p>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675149493956-ae825e4b-2bff-45fe-8ce9-bd9ef81c746d.png" alt="img"></p>
<p> 顺序加锁的解决方案  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675149509763-10de259a-c368-4eb4-93b4-62c9ffdc9385.png" alt="img"></p>
<p>意思就是两个对象都得先从A开始加锁,再给B加锁</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>可重入锁</p>
<p>相对于 synchronized 它具备如下特点  </p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
</ul>
<p> 与 synchronized 一样，都支持可重入  </p>
<p> 基本语法  </p>
<p>注意：要保证lock和unlock成对出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 </p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11.862</span> [main] c.TestReentrant - execute method1 </span><br><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11.865</span> [main] c.TestReentrant - execute method2 </span><br><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11.865</span> [main] c.TestReentrant - execute method3 </span><br></pre></td></tr></table></figure>

<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得锁，如果没获得锁就会阻塞到这里</span></span><br><span class="line">		<span class="comment">//如果是lock方法，就不可以打断，一直会阻塞到这里</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="comment">//先在主线程加锁，t1就获取不了锁了</span></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">40.520</span> [main] c.TestInterrupt - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">40.524</span> [t1] c.TestInterrupt - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">41.530</span> [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>) </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron</span><br><span class="line">izer.java:<span class="number">1222</span>) </span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$<span class="number">0</span>(TestInterrupt.java:<span class="number">17</span>) at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br><span class="line"><span class="number">18</span>:<span class="number">02</span>:<span class="number">41.532</span> [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure>

<p> 注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">06</span>:<span class="number">56.261</span> [main] c.TestInterrupt - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">06</span>:<span class="number">56.265</span> [t1] c.TestInterrupt - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">06</span>:<span class="number">57.266</span> [main] c.TestInterrupt - 执行打断 <span class="comment">// 这时 t1 并没有被真正打断, 而是仍继续等待锁</span></span><br><span class="line"><span class="number">18</span>:<span class="number">06</span>:<span class="number">58.267</span> [main] c.TestInterrupt - 释放了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">06</span>:<span class="number">58.267</span> [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure>

<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p> <strong>立刻失败</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02.918</span> [main] c.TestTimeout - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02.921</span> [t1] c.TestTimeout - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02.921</span> [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure>

<p> <strong>超时失败</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//等待一秒，如果一秒内获得了锁，返回为真</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">40.537</span> [main] c.TestTimeout - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">40.544</span> [t1] c.TestTimeout - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">19</span>:<span class="number">41.547</span> [t1] c.TestTimeout - 获取等待 1s 后失败，返回</span><br></pre></td></tr></table></figure>





<p> 使用 tryLock 解决哲学家就餐问题  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitCigaretteQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitbreakfastQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendBreakfast();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">        hasCigrette = <span class="literal">true</span>;</span><br><span class="line">        waitCigaretteQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">        hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">        waitbreakfastQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.680</span> [main] c.TestCondition - 送早餐来了</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.682</span> [Thread-<span class="number">1</span>] c.TestCondition - 等到了它的早餐</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">28.683</span> [main] c.TestCondition - 送烟来了</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">28.683</span> [Thread-<span class="number">0</span>] c.TestCondition - 等到了它的烟</span><br></pre></td></tr></table></figure>

<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p> 线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现  </p>
<p> <strong>wait notify 版</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncWaitNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;<span class="comment">//等待标记 1输出a 2 输出b 3输出c</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;<span class="comment">//循环次数，就是循环5次什么的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SyncWaitNotify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>.flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SyncWaitNotify</span> <span class="variable">syncWaitNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncWaitNotify</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncWaitNotify.print(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncWaitNotify.print(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncWaitNotify.print(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p> <strong>Lock 条件变量版</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Condition first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">            first.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数1打印内容，参数2进入哪一间休息室，参数3.下一间休息室</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                log.debug(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AwaitSignal</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//创建休息室</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">aWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">bWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">cWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    as.print(<span class="string">&quot;a&quot;</span>, aWaitSet, bWaitSet);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    as.print(<span class="string">&quot;b&quot;</span>, bWaitSet, cWaitSet);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    as.print(<span class="string">&quot;c&quot;</span>, cWaitSet, aWaitSet);</span><br><span class="line">&#125;).start();</span><br><span class="line">as.start(aWaitSet);</span><br></pre></td></tr></table></figure>

<p> <strong>Park Unpark 版</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncPark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    <span class="keyword">private</span> Thread[] threads;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SyncPark</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setThreads</span><span class="params">(Thread... threads)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threads = threads;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Thread <span class="title function_">nextThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(threads[i] == current) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; threads.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> threads[index+<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> threads[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(threads[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SyncPark</span> <span class="variable">syncPark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncPark</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncPark.print(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncPark.print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    syncPark.print(<span class="string">&quot;c\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">syncPark.setThreads(t1, t2, t3);</span><br><span class="line">syncPark.start();</span><br></pre></td></tr></table></figure>

<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p> 上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性  </p>
<p> 这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题  </p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>JMM指的是Java内存模型（Java Memory Model），是用来描述Java虚拟机中的多线程并发访问内存时的一种规范。JMM定义了Java程序中各个变量的访问规则，以及多线程之间如何进行通信。JMM确保在多线程环境下，线程之间的内存访问是有序、可预测的，保证了Java程序的可移植性和线程安全性。</p>
<p>JMM定义了原子性、可见性和有序性这三个基本特性，用来保证多线程环境下的数据同步和内存一致性。具体来说，原子性是指操作不可被中断，可见性是指一个线程对共享变量的修改对其他线程可见，有序性是指多线程程序执行的顺序是可以预测的。</p>
<p>在Java中，使用synchronized、volatile、final等关键字可以保证线程安全和JMM规范。开发人员需要了解JMM的规范以及相关关键字的使用方法，才能编写高效、正确的多线程程序。</p>
<p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p>
<p>JMM 体现在以下几个方面</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p> 退不出的循环  </p>
<p> 先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么呢？分析一下：</p>
<ol>
<li>初始状态， t 线程刚开始从主内存（所有共享信息存储的位置）读取了 run 的值到工作内存（每个线程私有的信息）。<img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675152956452-3853b96a-a844-4658-82ad-857a2641e2d1.png" alt="img"></li>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率  <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675152972814-5ca4ecd9-ba0e-4c39-b856-bc7e01000230.png" alt="img"></li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值  <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675152988084-f0bfde01-a519-448c-b73c-b48e126029b6.png" alt="img"></li>
</ol>
<p> 解决方法 ：</p>
<p>这个也可以用synchronized关键字解决，因为它也是满足可见性的不过相比于volatile，它更重量级</p>
<p>使用 volatile（易变关键字）  </p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存  </p>
<p>但是volatile不能保证原子性，不能解决指令交错问题 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错  </p>
<p>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低 ？  </p>
<h2 id="CPU-缓存结构原理"><a href="#CPU-缓存结构原理" class="headerlink" title="CPU 缓存结构原理"></a>CPU 缓存结构原理</h2><p> 内存屏障   Memory Barrier（Memory Fence）  </p>
<ul>
<li><p>可见性</p>
</li>
<li><ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
<li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li><p>有序性</p>
</li>
<li><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<h2 id="两阶段终止模式-1"><a href="#两阶段终止模式-1" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h2><h3 id="利用-isInterrupted"><a href="#利用-isInterrupted" class="headerlink" title="利用 isInterrupted"></a>利用 isInterrupted</h3><p> interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TPTInterrupt</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTInterrupt</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">42.915</span> c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">43.919</span> c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">44.919</span> c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">45.413</span> c.TestTwoPhaseTermination [main] - stop </span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">45.413</span> c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure>

<h3 id="利用停止标记"><a href="#利用停止标记" class="headerlink" title="利用停止标记"></a>利用停止标记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span></span><br><span class="line"><span class="comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TPTVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TPTVolatile</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTVolatile</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">54</span>:<span class="number">52.003</span> c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">54</span>:<span class="number">53.006</span> c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">54</span>:<span class="number">54.007</span> c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line"><span class="number">11</span>:<span class="number">54</span>:<span class="number">54.502</span> c.TestTwoPhaseTermination [main] - stop </span><br><span class="line"><span class="number">11</span>:<span class="number">54</span>:<span class="number">54.502</span> c.TPTVolatile [监控线程] - 料理后事</span><br></pre></td></tr></table></figure>

<h2 id="同步模式之-Balking"><a href="#同步模式之-Balking" class="headerlink" title="同步模式之 Balking"></a>同步模式之 Balking</h2><p> Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> starting;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="comment">//防止并发，不能使用volatiled</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前端页面多次点击按钮调用 start 时 </p>
<p>输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="literal">false</span>)</span><br><span class="line">[http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] cn.itcast.monitor.service.MonitorService - 监控线程已启动...</span><br><span class="line">[http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="literal">true</span>)</span><br><span class="line">[http-nio-<span class="number">8080</span>-exec-<span class="number">3</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="literal">true</span>)</span><br><span class="line">[http-nio-<span class="number">8080</span>-exec-<span class="number">4</span>] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p> 它还经常用来实现线程安全的单例  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。  </p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p> JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...; </span><br><span class="line">j = ...; </span><br></pre></td></tr></table></figure>

<p> 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。</p>
<p>所以，上面代码真正执行时，既可以是  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = ...; </span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>

<p> 也可以是  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j = ...;</span><br><span class="line">i = ...; </span><br></pre></td></tr></table></figure>

<p> 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？因为它能是CPU并行执行代码，提升效率啊！</p>
<h2 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h2><p> volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障 </li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><p> 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">	ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">	<span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">   	    r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675252864856-08a0f1b0-3dfd-45ea-a075-6cab560960fb.png" alt="img"></p>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><p> 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">	ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">	<span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    	r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675252912694-4c27f174-3664-489e-9f14-be0727abc596.png" alt="img"></p>
<p> 还是那句话，不能解决指令交错： </p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去 </li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675252949505-c8f72603-bc90-492c-8b9b-0cb265be3ce1.png" alt="img"></p>
<h3 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h3><p> 以著名的 double-checked locking 单例模式为例  这个想法属实是厉害，但是下面的代码其实还是有问题的，把INSTANCE变量全部放在synchronized块里面才可以保证指令不被重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 以上的实现特点是： </p>
<ul>
<li>懒惰实例化 </li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 </li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li>
</ul>
<p> 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton</li>
<li>20 表示复制一份对象引用 &#x2F;&#x2F; 引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675254590734-9194933b-b90e-4995-b7ef-2777be8c8ea7.png" alt="img"></p>
<p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取<br>INSTANCE 变量的值<br>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例<br>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<h3 id="double-checked-locking-解决"><a href="#double-checked-locking-解决" class="headerlink" title="double-checked locking 解决"></a>double-checked locking 解决</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码上看不出来 volatile 指令的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span></span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> #<span class="number">3</span> <span class="comment">// class cn/itcast/n5/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p>
<ul>
<li><p>可见性</p>
</li>
<li><ul>
<li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li>
<li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li><p>有序性</p>
</li>
<li><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
<li><p>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</p>
</li>
</ul>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见  </p>
<ul>
<li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo2</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">                                x = <span class="number">10</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">                                System.out.println(x);<span class="comment">//10</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>

<ul>
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 </li>
<li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">    System.out.println(x); </span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 变量都是指成员变量或静态成员变量  </p>
<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p> 有如下需求，保证 account.withdraw 取款方法的线程安全  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">    * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance() + <span class="string">&quot; cost: &quot;</span> + (end-start)/<span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 原有实现并不是线程安全的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行测试代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 某次的执行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">330</span> cost: <span class="number">306</span> ms</span><br></pre></td></tr></table></figure>

<p> <strong>为什么不安全</strong>  </p>
<p> withdraw 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    balance -= amount;<span class="comment">//Integer的写操作并不是原子性的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对应的字节码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> <span class="comment">// &lt;- this</span></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// &lt;- this.balance</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="comment">// 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// &lt;- amount</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="comment">// 拆箱</span></span><br><span class="line">ISUB <span class="comment">// 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; <span class="comment">// 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// -&gt; this.balance</span></span><br></pre></td></tr></table></figure>

<p> 多线程执行流程  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> <span class="comment">// thread-0 &lt;- this </span></span><br><span class="line">ALOAD <span class="number">0</span> </span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-0 &lt;- this.balance </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-0 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// thread-0 &lt;- amount </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-0 拆箱</span></span><br><span class="line">ISUB <span class="comment">// thread-0 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf <span class="comment">// thread-0 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-0 -&gt; this.balance </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ALOAD <span class="number">0</span> <span class="comment">// thread-1 &lt;- this </span></span><br><span class="line">ALOAD <span class="number">0</span> </span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-1 &lt;- this.balance </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-1 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// thread-1 &lt;- amount </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-1 拆箱</span></span><br><span class="line">ISUB <span class="comment">// thread-1 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf <span class="comment">// thread-1 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-1 -&gt; this.balance </span></span><br></pre></td></tr></table></figure>

<ul>
<li>单核的指令交错 </li>
<li>多核的指令交错</li>
</ul>
<p> <strong>解决思路-锁</strong>  </p>
<p> 首先想到的是给 Account 对象加锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果会减为零，说明是可以的</p>
<p><strong>解决思路-无锁</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">//如果为真，就退出，如果为假，就继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当然也是可以的，这样是一种乐观锁的方式</p>
<h2 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h2><p> 前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">        - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">        比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">        那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">        - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法）</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p> 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 </p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。  </p>
<p> 注意 volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）  </p>
<p> CAS 必须借助 volatile （你可以发现AtomicInteger里面的属性value就是用volatile关键字修饰了，这也是一个实例，后面会着重写AtomicInteger等类的介绍）才能读取到共享变量的最新值来实现【比较并交换】的效果  </p>
<h3 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a><strong>为什么无锁效率高</strong></h3><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻 </p>
<ul>
<li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 </li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片（所以线程数必须少于核心数才能发挥无锁的最高效率），仍然会进入可运行状态，还是会导致上下文切换。</li>
</ul>
<p>无锁编程是一种并发编程技术，它不依赖于互斥锁来控制并发访问共享数据的方式，而是通过一些其他的方式来实现并发安全。相比于使用互斥锁的并发编程方式，无锁编程有以下优势，导致其效率较高：</p>
<ol>
<li>减少了锁竞争：在使用锁的并发编程方式中，当多个线程试图访问共享数据时，必须要等待锁的释放，这会导致锁的竞争，增加了线程的等待时间。而无锁编程可以避免锁的竞争，每个线程可以自由访问共享数据，从而减少了线程的等待时间。</li>
<li>减少了上下文切换：使用锁的并发编程方式，当一个线程占用锁时，其他等待线程必须要被挂起，直到锁被释放。这种挂起和恢复的操作称为上下文切换。而无锁编程可以避免上下文切换，每个线程可以自由访问共享数据，从而减少了上下文切换的次数。</li>
<li>提高了并发性：使用锁的并发编程方式，当多个线程同时访问共享数据时，只有一个线程能够获得锁，其他线程必须等待。而无锁编程可以充分利用多核处理器的并行计算能力，同时执行多个线程的任务，从而提高了并发性。</li>
</ol>
<p>需要注意的是，无锁编程也有一些缺点，例如实现难度较高、代码可读性较差等。因此，在实际编程中应根据具体情况选择适合的并发编程方式</p>
<p>锁是用来保护共享资源不被多个线程同时访问和修改的一种同步机制。当多个线程需要访问共享资源时，它们必须先竞争锁，只有获得锁的线程才能访问共享资源，其他线程则需要等待。这种竞争和等待会导致并发程序的性能下降，并且如果多个线程同时等待同一个锁，则可能会导致死锁。</p>
<p>相比之下，无锁编程不需要使用锁，因此可以避免锁竞争和等待。在无锁编程中，多个线程可以同时访问共享资源，但是每个线程需要通过一定的算法和数据结构来保证对共享资源的操作是安全和正确的。由于无锁编程不需要使用锁，因此可以避免锁竞争和等待带来的开销和延迟，从而提高并发程序的性能和效率。</p>
<h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>
<ul>
<li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
<li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p>
</li>
<li><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p> J.U.C 并发包提供了： </p>
<ul>
<li>AtomicBoolean </li>
<li>AtomicInteger </li>
<li>AtomicLong</li>
</ul>
<p>以 AtomicInteger 为例  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>其中updateAndGet方法可以重写为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层自己实现一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i，IntUnary0perator operator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev,next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>为什么需要原子引用类型？</p>
<p>因为程序中要保护的共享数据并不一定都是基本数据类型,也有对象类型,此时就需要通过原子引用类型进行保护;</p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">    * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 试着提供不同的 DecimalAccount 实现，实现安全的取款操作  </p>
<h3 id="不安全实现"><a href="#不安全实现" class="headerlink" title="不安全实现"></a>不安全实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountUnsafe</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">        <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全实现-使用锁"><a href="#安全实现-使用锁" class="headerlink" title="安全实现-使用锁"></a>安全实现-使用锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeLock</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeLock</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">            <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全实现-使用-CAS"><a href="#安全实现-使用-CAS" class="headerlink" title="安全实现-使用 CAS"></a>安全实现-使用 CAS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    AtomicReference&lt;BigDecimal&gt; ref;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ref.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountUnsafe</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountSafeLock</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountSafeCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p> 运行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4310</span> cost: <span class="number">425</span> ms </span><br><span class="line"><span class="number">0</span> cost: <span class="number">285</span> ms </span><br><span class="line"><span class="number">0</span> cost: <span class="number">274</span> ms </span><br></pre></td></tr></table></figure>

<h3 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h3><p>ABA问题就是:如果你在主线程想把A改成B，假如其他线程把A改成B再改回成A，主线程不知道，仍然会成功修改，没办法感知已经改动过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">52.325</span> c.Test36 [main] - main start... </span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">52.379</span> c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">52.879</span> c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">29</span>:<span class="number">53.880</span> c.Test36 [main] - change A-&gt;C <span class="literal">true</span> </span><br></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望： </p>
<p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号  </p>
<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);<span class="comment">//这个0是初始版本号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">    <span class="comment">// 获取版本号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">    log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">    <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, </span><br><span class="line">                                                      ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, </span><br><span class="line">                                                      ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出为  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">34.891</span> c.Test36 [main] - main start... </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">34.894</span> c.Test36 [main] - 版本 <span class="number">0</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">34.956</span> c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">34.956</span> c.Test36 [t1] - 更新版本为 <span class="number">1</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">35.457</span> c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">35.457</span> c.Test36 [t2] - 更新版本为 <span class="number">2</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">41</span>:<span class="number">36.457</span> c.Test36 [main] - change A-&gt;C <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p> AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt;C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。 </p>
<p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有AtomicMarkableReference  <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675259265425-ccca3ac0-43f9-4e43-82fc-1e035fda2e78.png" alt="img"></p>
<h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">            <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">            AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">            <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">            log.debug(prev.toString());</span><br><span class="line">            <span class="comment">//打扫卫生代码</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;打扫卫生的线程 start...&quot;</span>);</span><br><span class="line">                bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="literal">true</span>, <span class="literal">false</span>)) &#123;&#125;</span><br><span class="line">                log.debug(bag.toString());</span><br><span class="line">            &#125;).start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">            log.debug(ref.getReference().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">09.264</span> [main] 主线程 start... </span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">09.270</span> [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">09.293</span> [Thread-<span class="number">1</span>] 打扫卫生的线程 start... </span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">09.294</span> [Thread-<span class="number">1</span>] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">10.294</span> [main] 主线程想换一只新垃圾袋？</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">10.294</span> [main] 换了么？<span class="literal">false</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">10.294</span> [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋</span><br></pre></td></tr></table></figure>

<p> 可以注释掉打扫卫生线程代码，再观察输出  </p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray </li>
<li>AtomicLongArray </li>
<li>AtomicReferenceArray</li>
</ul>
<p>有如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment">参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line"><span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line"><span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; arraySupplier,Function&lt;T, Integer&gt; lengthFun,BiConsumer&lt;T, Integer&gt; putConsumer,Consumer&lt;T&gt; printConsumer )</span> &#123;</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程对数组作 10000 次操作</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                putConsumer.accept(array, j%length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line">    printConsumer.accept(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不安全的数组"><a href="#不安全的数组" class="headerlink" title="不安全的数组"></a>不安全的数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt;<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">    (array)-&gt;array.length,</span><br><span class="line">    (array, index) -&gt; array[index]++,</span><br><span class="line">    array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">9870</span>, <span class="number">9862</span>, <span class="number">9774</span>, <span class="number">9697</span>, <span class="number">9683</span>, <span class="number">9678</span>, <span class="number">9679</span>, <span class="number">9668</span>, <span class="number">9680</span>, <span class="number">9698</span>] </span><br></pre></td></tr></table></figure>

<h3 id="安全的数组"><a href="#安全的数组" class="headerlink" title="安全的数组"></a>安全的数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">    (array) -&gt; array.length(),</span><br><span class="line">    (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">    array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>] </span><br></pre></td></tr></table></figure>

<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><ul>
<li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span>AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">Test5</span> <span class="variable">test5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test5</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">20</span> </span><br></pre></td></tr></table></figure>

<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><p>累加器性能比较（这个比AtomicInteger等性能要高很多，毕竟是大师之作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> adderSupplier.get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                action.accept(adder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 比较 AtomicLong 与 LongAdder  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), adder -&gt; adder.increment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000</span> cost:<span class="number">43</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">9</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">7</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">7</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">7</span> </span><br><span class="line">    </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">31</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">27</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">28</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">24</span> </span><br><span class="line"><span class="number">1000000</span> cost:<span class="number">22</span> </span><br></pre></td></tr></table></figure>

<p> 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。  </p>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p> Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//返回unsafe对象</span></span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe-CAS-操作"><a href="#Unsafe-CAS-操作" class="headerlink" title="Unsafe CAS 操作"></a>Unsafe CAS 操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line"> <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeAccessor.getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值（这里只是演示方法，实际还得写到while循环中）</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student(id=<span class="number">20</span>, name=张三) </span><br></pre></td></tr></table></figure>

<p>使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> DATA_OFFSET;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span></span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span></span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Account 实现  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Account.demo(<span class="keyword">new</span> <span class="title class_">Account</span>() &#123;</span><br><span class="line">    <span class="type">AtomicData</span> <span class="variable">atomicData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicData</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicData.getData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        atomicData.decrease(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="日期转换问题"><a href="#日期转换问题" class="headerlink" title="日期转换问题"></a>日期转换问题</h2><h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p> 下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.859</span> [Thread-<span class="number">2</span>] c.TestDateParse - &#123;&#125; </span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;&quot;</span> </span><br><span class="line"> at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>) </span><br><span class="line"> at java.lang.Long.parseLong(Long.java:<span class="number">601</span>) </span><br><span class="line"> at java.lang.Long.parseLong(Long.java:<span class="number">631</span>) </span><br><span class="line"> at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>) </span><br><span class="line"> at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2084</span>) </span><br><span class="line"> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2162</span>) </span><br><span class="line"> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>) </span><br><span class="line"> at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>) </span><br><span class="line"> at cn.itcast.n7.TestDateParse.lambda$test1$<span class="number">0</span>(TestDateParse.java:<span class="number">18</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.859</span> [Thread-<span class="number">1</span>] c.TestDateParse - &#123;&#125; </span><br><span class="line">java.lang.NumberFormatException: empty String </span><br><span class="line"> at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">1842</span>) </span><br><span class="line"> at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>) </span><br><span class="line"> at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>) </span><br><span class="line"> at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>) </span><br><span class="line"> at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2089</span>) </span><br><span class="line"> at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2162</span>) </span><br><span class="line"> at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>) </span><br><span class="line"> at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>) </span><br><span class="line"> at cn.itcast.n7.TestDateParse.lambda$test1$<span class="number">0</span>(TestDateParse.java:<span class="number">18</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">8</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">9</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">6</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">4</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">5</span>] c.TestDateParse - Mon Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">178960645</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">0</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">7</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br><span class="line"><span class="number">19</span>:<span class="number">10</span>:<span class="number">40.857</span> [Thread-<span class="number">3</span>] c.TestDateParse - Sat Apr <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1951</span> </span><br></pre></td></tr></table></figure>

<h3 id="思路-同步锁"><a href="#思路-同步锁" class="headerlink" title="思路 - 同步锁"></a>思路 - 同步锁</h3><p>这样性能就会比较差，因为加锁了，但是安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-不可变"><a href="#思路-不可变" class="headerlink" title="思路 - 不可变"></a>思路 - 不可变</h3><p> 如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line"> log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看 DateTimeFormatter 的文档：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implSpec</span></span><br><span class="line">This <span class="keyword">class</span> <span class="title class_">is</span> immutable and thread-safe.</span><br></pre></td></tr></table></figure>

<p>不可变对象，实际上是另一种避免竞争的方式</p>
<h2 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h2><p>String也是不可变的，以他为例子，说明以下不可变设计的要素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line"> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"> <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"> <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final的使用"><a href="#final的使用" class="headerlink" title="final的使用"></a>final的使用</h3><p>这个类的所有属性都是final的，类也是final的</p>
<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改 </li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p> 在实际运用中，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是substring的源码</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//下面两个if都是安全性校验</span></span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部是调用String的构造方法创建了一个新的字符串，下面来看这个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避 免共享的手段称之为【保护性拷贝（defensive copy）】  </p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>举几个例子就知道了</p>
<p>线程池</p>
<p>Integer对象会缓冲-128~127之间的对象</p>
<p>下面我们自己创建一个线程池</p>
<h3 id="DIY线程池"><a href="#DIY线程池" class="headerlink" title="DIY线程池"></a>DIY线程池</h3><p> 例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));<span class="comment">//这是一个假连接，用来模拟</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//这里可以不用while包，因为如果这个连接没拿到，就可以进入本次for循环的下一次，可以继续循环</span></span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="comment">//防止浪费cpu，腾出cpu去做CRUD操作</span></span><br><span class="line">            <span class="comment">//wait方法需要配合锁进行使用</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//notify方法需要配合锁使用</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">// 实现略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用连接池：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pool.free(conn);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实现没有考虑：</p>
<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式 hash</li>
</ul>
<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等    </p>
<p>对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p>
<h2 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span></span><br><span class="line"><span class="number">7</span>: putfield #<span class="number">2</span> <span class="comment">// Field a:I</span></span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line">    这里的作用</span><br><span class="line">    <span class="number">1.</span>防止写屏障前的代码被重排到写屏障后面</span><br><span class="line">	<span class="number">2.</span>把写屏障前面的代码数据同步到内存中</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p> 发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况  </p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p> 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的  </p>
<p> 因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>
<h1 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池（ThreadPool）是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。</p>
<p>池化思想在计算机的应用也比较广泛，比如以下这些：</p>
<ul>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ul>
<p>线程池的优势主要体现在以下 4 点：</p>
<ol>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ol>
<p>同时<strong>阿里巴巴在其《Java开发手册》中也强制规定：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p>
<p>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。<br>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>线程池的创建方法总共有 7 种，但总体来说可分为 2 类：</p>
<ul>
<li>一类是通过 ThreadPoolExecutor 创建的线程池；</li>
<li>另一个类是通过 Executors 创建的线程池。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1676704715662-83421000-e324-4cef-ac3d-4be4bd631908.png" alt="img"></p>
<p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过 Executors 创建的，1 种是通过 ThreadPoolExecutor 创建的）：</p>
<ol>
<li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</li>
<li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</li>
<li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</li>
<li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；</li>
<li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；</li>
<li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li>
<li>ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置，后面会详细讲。</li>
</ol>
<p><strong>单线程池的意义</strong><br>从以上代码可以看出 newSingleThreadExecutor 和 newSingleThreadScheduledExecutor 创建的都是单线程池，那么单线程池的意义是什么呢？<br>答：虽然是单线程池，但<strong>提供了工作队列，生命周期管理，工作线程维护</strong>等功能。</p>
<h3 id="究竟选用哪种线程池？"><a href="#究竟选用哪种线程池？" class="headerlink" title="究竟选用哪种线程池？"></a>究竟选用哪种线程池？</h3><p>经过以上的学习我们对整个线程池也有了一定的认识了，那究竟该如何选择线程池呢？</p>
<p>我们来看下阿里巴巴《Java开发手册》给我们的答案：</p>
<p>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>说明：Executors 返回的线程池对象的弊端如下：</p>
<p>1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>
<p>2）CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
<p>所以综上情况所述，我们推荐使用 ThreadPoolExecutor 的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。</p>
<ul>
<li><p>在创建了线程池后，开始等待请求</p>
</li>
<li><p>当调用 execute() 方法添加一个请求任务时，线程池会做出如下判断：</p>
</li>
<li><ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务 放入队列</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会 启动饱和拒绝策略来执行</li>
</ul>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
</li>
<li><ul>
<li>如果当前运行的线程数大于 corePoolSize，那么这个线程就会被停掉</li>
<li>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小</li>
</ul>
</li>
</ul>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675314843468-e6f6c524-6ca7-49a2-b08d-3a81f04c859d.png" alt="img"></p>
<p> 步骤1：自定义拒绝策略接口  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 步骤2：自定义任务队列  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2. 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 3. 生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 4. 消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 5. 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 步骤3：自定义线程池  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapcity, </span></span><br><span class="line"><span class="params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="comment">// while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 步骤4：测试  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                    <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">                                               <span class="comment">// 1. 死等</span></span><br><span class="line">                                               <span class="comment">// queue.put(task);</span></span><br><span class="line">                                               <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                                               <span class="comment">// queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">                                               <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                                               <span class="comment">// log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">                                               <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                                               <span class="comment">// throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">                                               <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                                               task.run();</span><br><span class="line">                                           &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675314960347-13eb26e0-74ed-4b25-95cf-066793e659df.png" alt="img"></p>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p> ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675320177855-bcc875ed-47fb-4dbd-87e1-9b6cf60f86b6.png" alt="img"></p>
<p> 从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING （为什么running最小呢，因为整数int的最高为是符号位，RUNNING是111所以是负数哦）</p>
<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值  </p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params"> <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params"> TimeUnit unit,</span></span><br><span class="line"><span class="params"> BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params"> ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数)</li>
<li>maximumPoolSize 最大线程数目（核心线程数目+救急线程数&#x3D;最大线程数）</li>
<li>keepAliveTime 生存时间 - 针对救急线程（救急线程和核心线程的最大区别是救急线程有生存时间，过了这个时间就不能再使用它了）</li>
<li>unit 时间单位 - 针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂 - 可以为线程创建时起个好名字（很容易把线程池中的线程和外部的线程区分出来）</li>
<li>handler 拒绝策略</li>
</ul>
<p>工作方式</p>
<ul>
<li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p>
</li>
<li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p>
</li>
<li><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p>
</li>
<li><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现</p>
</li>
<li><ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li><p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675320692396-df859bef-73b5-4233-98ca-82595783f5e5.png" alt="img"></p>
<p> 根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池  </p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点 ：</p>
<p>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </p>
<p>阻塞队列是无界的，可以放任意数量的任务 </p>
<p>评价 ：</p>
<p>适用于任务量已知，相对耗时的任务  </p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line"> <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 特点  </p>
<ul>
<li><p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 </p>
</li>
<li><ul>
<li>全部都是救急线程（60s 后可以回收）  </li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li><p>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;putting &#123;&#125; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        integers.put(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;putting...&#123;&#125; &quot;</span>, <span class="number">2</span>);</span><br><span class="line">        integers.put(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">15.500</span> c.TestSynchronousQueue [t1] - putting <span class="number">1</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">16.500</span> c.TestSynchronousQueue [t2] - taking <span class="number">1</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">16.500</span> c.TestSynchronousQueue [t1] - <span class="number">1</span> putted... </span><br><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">16.500</span> c.TestSynchronousQueue [t1] - putting..<span class="number">.2</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">17.502</span> c.TestSynchronousQueue [t3] - taking <span class="number">2</span> </span><br><span class="line"><span class="number">11</span>:<span class="number">48</span>:<span class="number">17.503</span> c.TestSynchronousQueue [t1] - <span class="number">2</span> putted... </span><br></pre></td></tr></table></figure>

<p> 评价 </p>
<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况  </p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line"> (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line"> <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
<p>区别：</p>
<ul>
<li><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</p>
</li>
<li><ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改</p>
</li>
<li><ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>shutdown</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdownnow</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h3><p> 在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">    <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">09.444</span> c.TestTimer [main] - start... </span><br><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">10.447</span> c.TestTimer [Timer-<span class="number">0</span>] - task <span class="number">1</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">12.448</span> c.TestTimer [Timer-<span class="number">0</span>] - task <span class="number">2</span> </span><br></pre></td></tr></table></figure>

<p> 使用 ScheduledExecutorService 改写：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"> <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Thu Jan <span class="number">03</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">17</span> CST <span class="number">2019</span> </span><br><span class="line">任务<span class="number">2</span>，执行时间：Thu Jan <span class="number">03</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">17</span> CST <span class="number">2019</span> </span><br></pre></td></tr></table></figure>

<p> scheduleAtFixedRate 例子：  以固定的速率循环执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">43.167</span> c.TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">44.215</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">45.215</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">46.215</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">47.215</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br></pre></td></tr></table></figure>

<p> scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p> 输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">30.311</span> c.TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">31.360</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">33.361</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">35.362</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">44</span>:<span class="number">37.362</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br></pre></td></tr></table></figure>

<p> scheduleWithFixedDelay 例子：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p> 输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">55.078</span> c.TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">56.140</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">59.143</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">02.145</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">05.147</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br></pre></td></tr></table></figure>

<p> 评价 </p>
<p>整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务  </p>
<h3 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h3><p> 方法1：主动捉异常  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line"> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">59</span>:<span class="number">04.558</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 </span><br><span class="line"><span class="number">21</span>:<span class="number">59</span>:<span class="number">04.562</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - error: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main$<span class="number">0</span>(TestTimer.java:<span class="number">28</span>) </span><br><span class="line"> at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure>

<p> 方法2：使用 Future  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());<span class="comment">//如果有异常会返回异常信息，如果没异常会返回true</span></span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">54</span>:<span class="number">58.208</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 </span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>) </span><br><span class="line"> at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">192</span>) </span><br><span class="line"> at cn.itcast.n8.TestTimer.main(TestTimer.java:<span class="number">31</span>) </span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main$<span class="number">0</span>(TestTimer.java:<span class="number">28</span>) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure>

<h3 id="tomcat线程池"><a href="#tomcat线程池" class="headerlink" title="tomcat线程池"></a>tomcat线程池</h3><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675322942882-2b82a228-3530-4619-8137-6e7e6ed5a56d.png" alt="img"></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li><p>如果总线程数达到 maximumPoolSize</p>
</li>
<li><ul>
<li>这时不会立刻抛 RejectedExecutionException 异常</li>
<li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul>
</li>
</ul>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p> 如何让每周四 18:00:00 定时执行任务？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取本周四 18:00:00.000</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">thursday</span> <span class="operator">=</span> </span><br><span class="line">    now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span></span><br><span class="line"><span class="keyword">if</span>(now.compareTo(thursday) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    thursday = thursday.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间差，即延时执行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, thursday).toMillis();</span><br><span class="line"><span class="comment">// 计算间隔时间，即 1 周的毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">oneWeek</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h2 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h2><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p>
<p>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p> 提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">            <span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line">            t1.fork();</span><br><span class="line">            log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并(join)结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 然后提交给 ForkJoinPool 来执行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"> System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask1</span>(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - fork() <span class="number">2</span> + &#123;<span class="number">1</span>&#125; </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - fork() <span class="number">5</span> + &#123;<span class="number">4</span>&#125; </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">1</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">2</span> + &#123;<span class="number">1</span>&#125; = <span class="number">3</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - fork() <span class="number">4</span> + &#123;<span class="number">3</span>&#125; </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - fork() <span class="number">3</span> + &#123;<span class="number">2</span>&#125; </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - join() <span class="number">3</span> + &#123;<span class="number">2</span>&#125; = <span class="number">6</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - join() <span class="number">4</span> + &#123;<span class="number">3</span>&#125; = <span class="number">10</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - join() <span class="number">5</span> + &#123;<span class="number">4</span>&#125; = <span class="number">15</span> </span><br><span class="line"><span class="number">15</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>用图来表示</p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675323174088-9762ccf7-f9ca-4450-b625-64e30d9cd46f.png" alt="img"></p>
<p>可以进行改进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask3</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask3</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 5, 5</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4, 5</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(begin, mid); <span class="comment">// 1,3</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(mid + <span class="number">1</span>, end); <span class="comment">// 4,5</span></span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后提交给 ForkJoinPool 来执行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask3</span>(<span class="number">1</span>, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - join() <span class="number">4</span> + <span class="number">5</span> = <span class="number">9</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">3</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - fork() &#123;<span class="number">1</span>,<span class="number">3</span>&#125; + &#123;<span class="number">4</span>,<span class="number">5</span>&#125; = ? </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - fork() &#123;<span class="number">1</span>,<span class="number">2</span>&#125; + &#123;<span class="number">3</span>,<span class="number">3</span>&#125; = ? </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - join() &#123;<span class="number">1</span>,<span class="number">2</span>&#125; + &#123;<span class="number">3</span>,<span class="number">3</span>&#125; = <span class="number">6</span> </span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - join() &#123;<span class="number">1</span>,<span class="number">3</span>&#125; + &#123;<span class="number">4</span>,<span class="number">5</span>&#125; = <span class="number">15</span> </span><br><span class="line"><span class="number">15</span> </span><br></pre></td></tr></table></figure>

<p> 用图来表示  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675323267544-1c59e44a-f8e0-4823-94c4-8231ba9d82c2.png" alt="img"></p>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p>特点：</p>
<ul>
<li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态</p>
</li>
<li><p>锁和释放锁</p>
</li>
<li><ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li><p>提供了基于 FIFO 的等待队列，等待队列的底层是每个节点为Node节点的双向链表，类似于 Monitor 的 EntryList</p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p>
</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p> 获取锁的姿势  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 释放锁的姿势  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h4><p>自定义同步器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 自定义锁  </p>
<p> 有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">29</span>:<span class="number">28.727</span> c.TestAqs [t1] - locking... </span><br><span class="line"><span class="number">22</span>:<span class="number">29</span>:<span class="number">29.732</span> c.TestAqs [t1] - unlocking... </span><br><span class="line"><span class="number">22</span>:<span class="number">29</span>:<span class="number">29.732</span> c.TestAqs [t2] - locking... </span><br><span class="line"><span class="number">22</span>:<span class="number">29</span>:<span class="number">29.732</span> c.TestAqs [t2] - unlocking... </span><br></pre></td></tr></table></figure>

<p> 不可重入测试 如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>心得</strong></p>
<p>起源：</p>
<p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。  </p>
<p>目标：</p>
<p> AQS 要实现的功能目标 </p>
<ul>
<li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li>
<li>获取锁超时机制  </li>
<li>通过打断取消机制 </li>
<li>独占机制及共享机制 </li>
<li>条件不满足时的等待机制</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select … from … lock in share mode </p>
<p>提供一个 <strong>数据容器类</strong> 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试 读锁-读锁 可以并发  （读锁是防止读到写的中间值。这就是为什么读也要加锁。可以找点资料看一下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">14.341</span> c.DataContainer [t2] - 获取读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">14.341</span> c.DataContainer [t1] - 获取读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">14.345</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">14.345</span> c.DataContainer [t2] - 读取</span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">15.365</span> c.DataContainer [t2] - 释放读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">05</span>:<span class="number">15.386</span> c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>

<p> 测试 读锁-写锁 相互阻塞  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p> 输出结果 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t1] - 获取读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t2] - 获取写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.841</span> c.DataContainer [t2] - 写入</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t2] - 释放写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">23.843</span> c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>

<p> 写锁-写锁 也是相互阻塞的，这里就不测试了  </p>
<p><strong>注意事项</strong></p>
<p>读锁不支持条件变量</p>
<p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> w.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> w.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重入时降级支持：即持有写锁的情况下去获取读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                        cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h4><p>有一个问题：更新时，是先清缓存还是先更新数据库 </p>
<p>先清缓存  </p>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675779953229-b37af937-bc9d-4d1a-ab00-6cba8a16768e.png" alt="img"></p>
<p> 先更新数据库  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1675779971453-f99c9e08-0f29-4a20-90bc-04f6a1c2fbd3.png" alt="img"></p>
<p> <strong>读写锁实现一致性缓存</strong>  </p>
<p> 使用读写锁实现一个简单的按需加载缓存  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericCachedDao</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// HashMap 作为缓存非线程安全, 需要保护</span></span><br><span class="line">    HashMap&lt;SqlPair, T&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(); </span><br><span class="line">    <span class="type">GenericDao</span> <span class="variable">genericDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericDao</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... params)</span> &#123;</span><br><span class="line">        <span class="type">SqlPair</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlPair</span>(sql, params);</span><br><span class="line">        <span class="comment">// 加写锁, 防止其它线程对缓存读取和更改</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> genericDao.update(sql, params);</span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">return</span> rows;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">queryOne</span><span class="params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span> &#123;</span><br><span class="line">        <span class="type">SqlPair</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlPair</span>(sql, params);</span><br><span class="line">        <span class="comment">// 加读锁, 防止其它线程对缓存更改</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加写锁, 防止其它线程对缓存读取和更改</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span></span><br><span class="line">            <span class="comment">// 为防止重复查询数据库, 再次验证</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有, 查询数据库</span></span><br><span class="line">                value = genericDao.queryOne(beanClass, sql, params);</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 作为 key 保证其是不可变的</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SqlPair</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String sql;</span><br><span class="line">        <span class="keyword">private</span> Object[] params;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SqlPair</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sql = sql;</span><br><span class="line">            <span class="built_in">this</span>.params = params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SqlPair</span> <span class="variable">sqlPair</span> <span class="operator">=</span> (SqlPair) o;</span><br><span class="line">            <span class="keyword">return</span> sql.equals(sqlPair.sql) &amp;&amp;</span><br><span class="line">                Arrays.equals(params, sqlPair.params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Objects.hash(sql);</span><br><span class="line">            result = <span class="number">31</span> * result + Arrays.hashCode(params);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑</p>
</li>
<li><ul>
<li>适合读多写少，如果写操作比较频繁，以上实现性能低</li>
<li>没有考虑缓存容量</li>
<li>没有考虑缓存过期</li>
<li>只适合单机</li>
<li>并发性还是低，目前只会用一把锁</li>
<li>更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key）</li>
</ul>
</li>
<li><p>乐观锁实现：用 CAS 去更新</p>
</li>
</ul>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p> 该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 </p>
<p>加解读锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p> 加解写锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p> 乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试 读-读 可以优化  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果，可以看到实际没有加读锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">58</span>:<span class="number">50.217</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="number">.256</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">58</span>:<span class="number">50.717</span> c.DataContainerStamped [t2] - optimistic read locking..<span class="number">.256</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">58</span>:<span class="number">50.717</span> c.DataContainerStamped [t2] - read finish..<span class="number">.256</span>, data:<span class="number">1</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">58</span>:<span class="number">51.220</span> c.DataContainerStamped [t1] - read finish..<span class="number">.256</span>, data:<span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p> 测试 读-写 时优化读补加读锁  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">00.219</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="number">.256</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">00.717</span> c.DataContainerStamped [t2] - write lock <span class="number">384</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">01.225</span> c.DataContainerStamped [t1] - updating to read lock... <span class="number">256</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">02.719</span> c.DataContainerStamped [t2] - write unlock <span class="number">384</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">02.719</span> c.DataContainerStamped [t1] - read lock <span class="number">513</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">03.719</span> c.DataContainerStamped [t1] - read finish..<span class="number">.513</span>, data:<span class="number">1000</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">03.719</span> c.DataContainerStamped [t1] - read unlock <span class="number">513</span> </span><br></pre></td></tr></table></figure>

<p> 注意 </p>
<p>StampedLock 不支持条件变量 </p>
<p>StampedLock 不支持可重入  </p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p> [ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3. 获取许可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675781267908-4cec13bb-7cee-47db-8d49-f552b64f26f2.png" alt="img"></p>
<h3 id="Semaphore-应用"><a href="#Semaphore-应用" class="headerlink" title="Semaphore 应用"></a>Semaphore 应用</h3><p>信号灯</p>
<p> 限制对共享资源的使用  </p>
<ul>
<li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） </li>
<li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">       <span class="comment">// 1. 连接池大小</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">       <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">       <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">       <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">       <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">       <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">       <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">           <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">           <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(poolSize);</span><br><span class="line">           <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">           <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">               connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 5. 借连接</span></span><br><span class="line">       <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">           <span class="comment">// 获取许可</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">               <span class="comment">// 获取空闲连接</span></span><br><span class="line">               <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                       log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                       <span class="keyword">return</span> connections[i];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 不会执行到这里</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6. 归还连接</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                   states.set(i, <span class="number">0</span>);</span><br><span class="line">                   log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                   semaphore.release();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>是一个倒计时器。。</p>
<p> 用来进行线程同步协作，等待所有线程完成倒计时。 </p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await();</span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">00.778</span> c.TestCountDownLatch [main] - waiting... </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">00.778</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">00.778</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">00.778</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">01.782</span> c.TestCountDownLatch [Thread-<span class="number">0</span>] - end..<span class="number">.2</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">02.283</span> c.TestCountDownLatch [Thread-<span class="number">2</span>] - end..<span class="number">.1</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">02.782</span> c.TestCountDownLatch [Thread-<span class="number">1</span>] - end..<span class="number">.0</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">44</span>:<span class="number">02.782</span> c.TestCountDownLatch [main] - wait end... </span><br></pre></td></tr></table></figure>

<p> 可以配合线程池使用，改进如下  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - waiting... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">26.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - end..<span class="number">.2</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.335</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - end..<span class="number">.1</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - end..<span class="number">.0</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - wait end... </span><br></pre></td></tr></table></figure>

<h3 id="应用之同步等待多线程准备完毕"><a href="#应用之同步等待多线程准备完毕" class="headerlink" title="应用之同步等待多线程准备完毕"></a>应用之同步等待多线程准备完毕</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> j;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p> 中间输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[t0(<span class="number">52</span>%), t1(<span class="number">47</span>%), t2(<span class="number">51</span>%), t3(<span class="number">40</span>%), t4(<span class="number">49</span>%), t5(<span class="number">44</span>%), t6(<span class="number">49</span>%), t7(<span class="number">52</span>%), t8(<span class="number">46</span>%), t9(<span class="number">46</span>%)] </span><br></pre></td></tr></table></figure>

<p> 最后输出  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[t0(<span class="number">100</span>%), t1(<span class="number">100</span>%), t2(<span class="number">100</span>%), t3(<span class="number">100</span>%), t4(<span class="number">100</span>%), t5(<span class="number">100</span>%), t6(<span class="number">100</span>%), t7(<span class="number">100</span>%), t8(<span class="number">100</span>%), </span><br><span class="line">t9(<span class="number">100</span>%)] </span><br><span class="line">游戏开始... </span><br></pre></td></tr></table></figure>

<h3 id="应用之同步等待多个远程调用结束"><a href="#应用之同步等待多个远程调用结束" class="headerlink" title="应用之同步等待多个远程调用结束"></a>应用之同步等待多个远程调用结束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCountDownlatchController</span> &#123;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;/order/&#123;id&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">order</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">            map.put(<span class="string">&quot;total&quot;</span>, <span class="string">&quot;2300.00&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">product</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小爱音箱&quot;</span>);</span><br><span class="line">                map.put(<span class="string">&quot;price&quot;</span>, <span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">                map.put(<span class="string">&quot;price&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;/logistics/&#123;id&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">logistics</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;中通快递&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2500</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> millis)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(millis);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> rest 远程调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">4</span>);</span><br><span class="line">Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(f1.get());</span><br><span class="line">System.out.println(f2.get());</span><br><span class="line">System.out.println(f3.get());</span><br><span class="line">System.out.println(f4.get());</span><br><span class="line">log.debug(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<p> 执行结果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">39.711</span> c.TestCountDownLatch [main] - begin </span><br><span class="line">&#123;total=<span class="number">2300.00</span>, id=<span class="number">1</span>&#125; </span><br><span class="line">&#123;price=<span class="number">300</span>, name=小爱音箱, id=<span class="number">1</span>&#125; </span><br><span class="line">&#123;price=<span class="number">2000</span>, name=小米手机, id=<span class="number">2</span>&#125; </span><br><span class="line">&#123;name=中通快递, id=<span class="number">1</span>&#125; </span><br><span class="line"><span class="number">19</span>:<span class="number">51</span>:<span class="number">42.407</span> c.TestCountDownLatch [main] - 执行完毕</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>这个注意和上面的那个做对比</p>
<p> [ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数（线程数最好和任务数一样）满足『计数个数』时，继续执行  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p> 注意 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比喻为『人满发车』  </p>
<h2 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h2><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1675782115192-7b70ca68-6841-4559-b60b-f68e654e0f1d.png" alt="img"></p>
<p>线程安全集合类可以分为三大类：</p>
<ul>
<li><p>遗留的线程安全集合如 Hashtable ， Vector</p>
</li>
<li><p>使用 Collections 装饰的线程安全集合，如：</p>
</li>
<li><ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet </li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul>
</li>
<li><p>java.util.concurrent.*</p>
</li>
</ul>
<p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：Blocking、CopyOnWrite、Concurrent</p>
<ul>
<li><p>Blocking 大部分实现基于锁，并提供用来阻塞的方法</p>
</li>
<li><p>CopyOnWrite 之类容器修改开销相对较重</p>
</li>
<li><p>Concurrent 类型的容器</p>
</li>
<li><ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li>
<li>弱一致性</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p> 练习：单词计数  </p>
<p> 生成测试数据  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ALPHA</span> <span class="operator">=</span> <span class="string">&quot;abcedfghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> ALPHA.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(length * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> ALPHA.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">            list.add(String.valueOf(ch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tmp/&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> list.subList(i * count, (i + <span class="number">1</span>) * count).stream()</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">            out.print(collect);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 模版代码，模版代码中封装了多线程读取文件的代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;V&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, </span></span><br><span class="line"><span class="params">                             BiConsumer&lt;Map&lt;String,V&gt;,List&lt;String&gt;&gt; consumer)</span> &#123;</span><br><span class="line">    Map&lt;String, V&gt; counterMap = supplier.get();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; words = readFromFile(idx);</span><br><span class="line">            consumer.accept(counterMap, words);</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t-&gt;t.start());</span><br><span class="line">    ts.forEach(t-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(counterMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;tmp/&quot;</span></span><br><span class="line">                                                                                      + i +<span class="string">&quot;.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        words.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 你要做的是实现两个参数 </p>
<p>一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数 </p>
<p>二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List </p>
<p>正确结果输出应该是每个单词出现 200 次  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;a=<span class="number">200</span>, b=<span class="number">200</span>, c=<span class="number">200</span>, d=<span class="number">200</span>, e=<span class="number">200</span>, f=<span class="number">200</span>, g=<span class="number">200</span>, h=<span class="number">200</span>, i=<span class="number">200</span>, j=<span class="number">200</span>, k=<span class="number">200</span>, l=<span class="number">200</span>, m=<span class="number">200</span>, </span><br><span class="line">n=<span class="number">200</span>, o=<span class="number">200</span>, p=<span class="number">200</span>, q=<span class="number">200</span>, r=<span class="number">200</span>, s=<span class="number">200</span>, t=<span class="number">200</span>, u=<span class="number">200</span>, v=<span class="number">200</span>, w=<span class="number">200</span>, x=<span class="number">200</span>, y=<span class="number">200</span>, z=<span class="number">200</span>&#125; </span><br></pre></td></tr></table></figure>

<p> 下面的实现为：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">    <span class="comment">// 创建 map 集合</span></span><br><span class="line">    <span class="comment">// 创建 ConcurrentHashMap 对不对？</span></span><br><span class="line">    () -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;(),</span><br><span class="line">    <span class="comment">// 进行计数</span></span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//每个方法是原子的，但是组合起来就不是原子的了</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">            <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter == <span class="literal">null</span> ? <span class="number">1</span> : counter + <span class="number">1</span>;</span><br><span class="line">            map.put(word, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>故这个实现不好</p>
<p>改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">    () -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, LongAdder&gt;(),</span><br><span class="line">    (map, words) -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null</span></span><br><span class="line">            map.computeIfAbsent(word, (key) -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>()).increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>computeIfAbsent这个方法的意思：如果容器里面没有这个key（也就是这里面的word），就计算生成一个value（根据你自定义的规则），然后把key和value放入map</p>
<p>LongAdder这是一个累加器，只有在第一次进入这里才会创建累加器</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小白菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/">http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">是小白菜哦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/12/Netty/"><img class="next-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小白菜</div><div class="author-info__description">头发多多</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xiaobaicai350"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Xiaobaicai350" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1499487526@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阳光斑斓 微风含香 爱与四季 皆是向往 <img height="230" lengh="230" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1.gif"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">创建和运行线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">查看进程线程的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">原理之线程运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Thread-Context-Switch%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">线程上下文切换（Thread Context Switch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">常见方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start-%E4%B8%8E-run"><span class="toc-number">2.6.</span> <span class="toc-text">start 与 run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E4%B8%8E-yield"><span class="toc-number">2.7.</span> <span class="toc-text">sleep 与 yield</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.8.</span> <span class="toc-text">join 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-join"><span class="toc-number">2.8.1.</span> <span class="toc-text">为什么需要 join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%97%B6%E6%95%88%E7%9A%84-join"><span class="toc-number">2.8.2.</span> <span class="toc-text">有时效的 join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interrupt-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.9.</span> <span class="toc-text">interrupt 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E6%96%AD-sleep%EF%BC%8Cwait%EF%BC%8Cjoin-%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">打断 sleep，wait，join 的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E6%96%AD%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.9.2.</span> <span class="toc-text">打断正常运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.9.3.</span> <span class="toc-text">两阶段终止模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E6%96%AD-park-%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.9.4.</span> <span class="toc-text">打断 park 线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">不推荐的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.11.</span> <span class="toc-text">主线程与守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.12.</span> <span class="toc-text">五种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.13.</span> <span class="toc-text">六种状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">共享带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">synchronized 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">3.2.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%94%B9%E8%BF%9B"><span class="toc-number">3.2.2.</span> <span class="toc-text">面向对象改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84-synchronized"><span class="toc-number">3.3.</span> <span class="toc-text">方法上的 synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E8%B0%93%E7%9A%84%E2%80%9C%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81%E2%80%9D"><span class="toc-number">3.3.1.</span> <span class="toc-text">所谓的“线程八锁”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">变量的线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">成员变量和静态变量是否线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">局部变量是否线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">3.4.3.</span> <span class="toc-text">局部变量线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">普通局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">局部变量的引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">3.4.4.</span> <span class="toc-text">常见线程安全类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">3.4.5.</span> <span class="toc-text">线程安全类方法的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.4.6.</span> <span class="toc-text">不可变类线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.4.7.</span> <span class="toc-text">实例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor-%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.</span> <span class="toc-text">Monitor 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">3.5.1.</span> <span class="toc-text">Java 对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor-%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.2.</span> <span class="toc-text">Monitor 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.3.</span> <span class="toc-text">synchronized 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%85%E4%BA%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">小故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6"><span class="toc-number">3.5.5.</span> <span class="toc-text">synchronized 原理进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.5.5.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">3.5.5.2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.5.3.</span> <span class="toc-text">自旋优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.5.5.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.5.5.</span> <span class="toc-text">偏向状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80-%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-hashCode"><span class="toc-number">3.5.5.6.</span> <span class="toc-text">撤销 - 调用对象 hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80-%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.5.7.</span> <span class="toc-text">撤销 - 其它线程使用对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="toc-number">3.5.5.8.</span> <span class="toc-text">批量重偏向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify"><span class="toc-number">3.6.</span> <span class="toc-text">wait notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify-%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">wait notify 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.6.2.</span> <span class="toc-text">API 介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="toc-number">3.7.</span> <span class="toc-text">wait notify 的正确姿势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C"><span class="toc-number">3.8.</span> <span class="toc-text">同步模式之保护性暂停</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%89%88"><span class="toc-number">3.8.1.</span> <span class="toc-text">普通版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E7%89%88"><span class="toc-number">3.8.2.</span> <span class="toc-text">超时版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.9.</span> <span class="toc-text">异步模式之生产者&#x2F;消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Park-amp-Unpark"><span class="toc-number">3.10.</span> <span class="toc-text">Park &amp; Unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#park-unpark-%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.1.</span> <span class="toc-text">park unpark 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.11.</span> <span class="toc-text">重新理解线程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-1-NEW-%E2%80%93-gt-RUNNABLE"><span class="toc-number">3.11.1.</span> <span class="toc-text">情况 1 NEW –&gt; RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-2-RUNNABLE-lt-%E2%80%93-gt-WAITING"><span class="toc-number">3.11.2.</span> <span class="toc-text">情况 2 RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-3-RUNNABLE-lt-%E2%80%93-gt-WAITING"><span class="toc-number">3.11.3.</span> <span class="toc-text">情况 3 RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-4-RUNNABLE-lt-%E2%80%93-gt-WAITING"><span class="toc-number">3.11.4.</span> <span class="toc-text">情况 4 RUNNABLE &lt;–&gt; WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-5-RUNNABLE-lt-%E2%80%93-gt-TIMED-WAITING"><span class="toc-number">3.11.5.</span> <span class="toc-text">情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-6-RUNNABLE-lt-%E2%80%93-gt-TIMED-WAITING"><span class="toc-number">3.11.6.</span> <span class="toc-text">情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-7-RUNNABLE-lt-%E2%80%93-gt-TIMED-WAITING"><span class="toc-number">3.11.7.</span> <span class="toc-text">情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-8-RUNNABLE-lt-%E2%80%93-gt-TIMED-WAITING"><span class="toc-number">3.11.8.</span> <span class="toc-text">情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-9-RUNNABLE-lt-%E2%80%93-gt-BLOCKED"><span class="toc-number">3.11.9.</span> <span class="toc-text">情况 9 RUNNABLE &lt;–&gt; BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5-10-RUNNABLE-lt-%E2%80%93-gt-TERMINATED"><span class="toc-number">3.11.10.</span> <span class="toc-text">情况 10 RUNNABLE &lt;–&gt; TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.11.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-number">3.12.</span> <span class="toc-text">多把锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">3.13.</span> <span class="toc-text">活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">3.13.1.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">3.13.2.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.14.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">3.14.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">3.14.2.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">3.14.3.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.14.4.</span> <span class="toc-text">条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.15.</span> <span class="toc-text">同步模式之顺序控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number">3.15.1.</span> <span class="toc-text">交替输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">共享模型之内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Java 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">CPU 缓存结构原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">4.4.</span> <span class="toc-text">两阶段终止模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-isInterrupted"><span class="toc-number">4.4.1.</span> <span class="toc-text">利用 isInterrupted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%81%9C%E6%AD%A2%E6%A0%87%E8%AE%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">利用停止标记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B-Balking"><span class="toc-number">4.5.</span> <span class="toc-text">同步模式之 Balking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">volatile 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.7.1.</span> <span class="toc-text">如何保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.7.2.</span> <span class="toc-text">如何保证有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#double-checked-locking-%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.3.</span> <span class="toc-text">double-checked locking 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#double-checked-locking-%E8%A7%A3%E5%86%B3"><span class="toc-number">4.7.4.</span> <span class="toc-text">double-checked locking 解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before"><span class="toc-number">4.8.</span> <span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">共享模型之无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA"><span class="toc-number">5.1.</span> <span class="toc-text">问题提出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-%E4%B8%8E-volatile"><span class="toc-number">5.2.</span> <span class="toc-text">CAS 与 volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">5.2.1.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">5.2.2.</span> <span class="toc-text">为什么无锁效率高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.3.</span> <span class="toc-text">CAS 的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">原子整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">原子引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">不安全实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8%E9%94%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">安全实现-使用锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8-CAS"><span class="toc-number">5.4.3.</span> <span class="toc-text">安全实现-使用 CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">5.4.4.</span> <span class="toc-text">ABA 问题及解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicMarkableReference"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">AtomicMarkableReference</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">原子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.1.</span> <span class="toc-text">不安全的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.2.</span> <span class="toc-text">安全的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">字段更新器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">原子累加器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe"><span class="toc-number">5.8.</span> <span class="toc-text">Unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-CAS-%E6%93%8D%E4%BD%9C"><span class="toc-number">5.8.1.</span> <span class="toc-text">Unsafe CAS 操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">6.</span> <span class="toc-text">共享模型之不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">日期转换问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">问题提出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">思路 - 同步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">6.1.3.</span> <span class="toc-text">思路 - 不可变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.2.</span> <span class="toc-text">不可变设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">final的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.2.2.</span> <span class="toc-text">保护性拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DIY%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.3.1.</span> <span class="toc-text">DIY线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">final原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.5.</span> <span class="toc-text">无状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">共享模型之工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">线程池的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%B6%E7%AB%9F%E9%80%89%E7%94%A8%E5%93%AA%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">究竟选用哪种线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.3.</span> <span class="toc-text">自定义线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">7.1.4.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">7.1.5.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">7.1.6.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">7.1.7.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.1.8.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.9.</span> <span class="toc-text">关闭线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.9.1.</span> <span class="toc-text">其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.10.</span> <span class="toc-text">任务调度线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="toc-number">7.1.11.</span> <span class="toc-text">正确处理执行任务异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.12.</span> <span class="toc-text">tomcat线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.2.</span> <span class="toc-text">定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join"><span class="toc-number">7.3.</span> <span class="toc-text">Fork&#x2F;Join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-number">7.4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.1.</span> <span class="toc-text">AQS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">实现不可重入锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">7.4.2.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BC%93%E5%AD%98"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">应用之缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StampedLock"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">StampedLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">7.5.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore-%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">Semaphore 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">7.6.</span> <span class="toc-text">CountdownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%87%86%E5%A4%87%E5%AE%8C%E6%AF%95"><span class="toc-number">7.6.1.</span> <span class="toc-text">应用之同步等待多线程准备完毕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F"><span class="toc-number">7.6.2.</span> <span class="toc-text">应用之同步等待多个远程调用结束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">7.7.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">7.8.</span> <span class="toc-text">线程安全集合类概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">7.9.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/04/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/" title="彻底弄懂Redis的内存策略">彻底弄懂Redis的内存策略</a><time datetime="2024-06-04T03:05:02.000Z" title="发表于 2024-06-04 11:05:02">2024-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/04/%E4%B8%80%E6%96%87%E6%95%99%E4%BC%9A%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AFB-%E6%A0%91/" title="一文教会你为什么索引的底层数据结构是B+树">一文教会你为什么索引的底层数据结构是B+树</a><time datetime="2024-06-04T01:03:47.000Z" title="发表于 2024-06-04 09:03:47">2024-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%91%8A%E8%AF%89%E4%BD%A0/" title="什么是覆盖索引，一篇文章告诉你">什么是覆盖索引，一篇文章告诉你</a><time datetime="2024-06-03T06:17:02.000Z" title="发表于 2024-06-03 14:17:02">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/02/%E5%9B%BE%E6%96%87%E5%B9%B6%E8%8C%82%EF%BC%8C%E6%B7%B1%E5%88%BB%E4%BA%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" title="图文并茂，深刻了解索引失效">图文并茂，深刻了解索引失效</a><time datetime="2024-06-02T06:16:22.000Z" title="发表于 2024-06-02 14:16:22">2024-06-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/01/MySql%E4%B9%8B%E5%9B%9B%E7%A7%8DSQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" title="MySql之四种SQL性能分析工具">MySql之四种SQL性能分析工具</a><time datetime="2024-06-01T06:16:34.000Z" title="发表于 2024-06-01 14:16:34">2024-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 小白菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到小白菜的blog~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>