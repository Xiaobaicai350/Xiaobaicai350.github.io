<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring详解 | 是小白菜哦</title><meta name="author" content="小白菜"><meta name="copyright" content="小白菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring面试题：IoC和DI的关系是什么？  首先，先回答IoC和DI的是什么：  IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方 DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入   其次，在回答IoC和DI的关系：   第一种观点：IoC强调的是Bean创建权的反转">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring详解">
<meta property="og:url" content="http://example.com/2023/05/12/Spring%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="是小白菜哦">
<meta property="og:description" content="Spring面试题：IoC和DI的关系是什么？  首先，先回答IoC和DI的是什么：  IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方 DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入   其次，在回答IoC和DI的关系：   第一种观点：IoC强调的是Bean创建权的反转">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg">
<meta property="article:published_time" content="2023-05-11T18:20:06.000Z">
<meta property="article:modified_time" content="2023-06-29T08:50:00.565Z">
<meta property="article:author" content="小白菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/132124.png"><link rel="canonical" href="http://example.com/2023/05/12/Spring%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-29 16:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">是小白菜哦</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-11T18:20:06.000Z" title="发表于 2023-05-12 02:20:06">2023-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-29T08:50:00.565Z" title="更新于 2023-06-29 16:50:00">2023-06-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>面试题：IoC和DI的关系是什么？</p>
<blockquote>
<p>首先，先回答IoC和DI的是什么：</p>
<ul>
<li>IoC： Inversion of Control，控制反转，将Bean的创建权由<strong>原来程序</strong>反转给<strong>第三方</strong></li>
<li>DI：Dependency Injection，依赖注入，<strong>某个Bean的完整创建依赖于其他Bean</strong>（或普通参数）<strong>的注入</strong></li>
</ul>
</blockquote>
<p>其次，在回答IoC和DI的关系：</p>
<blockquote>
<ul>
<li>第一种观点：IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系</li>
<li>第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式</li>
</ul>
</blockquote>
<p>感受下下面两种创建工厂的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultListableBeanFactory是BeanFactory的一个具体实现</span></span><br><span class="line"><span class="comment">//XmlBeanFactory是DefaultListableBeanFactory的子类，添加了Xml读取的功能，也就是不用自己创建XmlBeanDefinitionReader了</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="comment">//利用Resource加载配置文件</span></span><br><span class="line"><span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//添加Reader到工厂</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">xmlBeanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"><span class="comment">//把配置文件添加到工厂中</span></span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanFactory.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">u</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;u&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>面试题：BeanFactory与ApplicationContext的关系<br>1）BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为Spring 容器；<br>2）ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682162224300-c5a16a4a-0388-4b25-b4df-1c60818d6805.png" alt="imagepng"></p>
</blockquote>
<p>3）Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且ApplicationContext<strong>内部还维护着BeanFactory的引用</strong>，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系。</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682162469216-50411ba7-a7c5-4146-8807-39808646ab34.png" alt="imagepng"></p>
</blockquote>
<p>4）Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时（懒加载，用到哪个加载哪个）才进行Bean的创建，而ApplicationContext则是在<strong>容器一创建（也就是在你启动你的项目的时候就会创建了）就将Bean都实例化并初始化好</strong>。</p>
<p>总的来说就是这个关系： <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682162578695-e3f6539a-0734-4292-9608-9a055731f4d0.png" alt="imagepng"> <strong>ApplicationContext是对BeanFactory的进一步封装，并且提供了更多的功能</strong></p>
<p>ApplicationContext文件结构： <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682163314023-cf785b9a-f526-4841-805a-55687c19496c.png" alt="imagepng"></p>
<p><strong>如果闻到bean标签的scope属性的回答：</strong> 当只是一个简单的spring项目时，只有singleton和prototype两种，一种是单例，用到的事件直接去singletonObjects（单例池）中去拿就可以了，另一种是每次创建都会创建一个新对象<br>但是当在web-MVC环境下，就会多出两个： <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682164663836-6bd27c9d-95d8-4786-a34b-d03e5c0ea066.png" alt="imagepng"> 知道这个就行了</p>
<p>bean标签配置延迟加载： <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682164734229-3fe98404-d551-4a01-b6aa-f037baea0b48.png" alt="imagepng"> 这个在使用ApplicationContext的情况下可以用。但是我们知道，如果使用BeanFactory（工厂)创建bean，都是延迟加载，也就是说如果使用BeanFactory，配置这个就没用了！！！！</p>
<h2 id="Spring的实例化"><a href="#Spring的实例化" class="headerlink" title="Spring的实例化"></a>Spring的实例化</h2><p>Spring的实例化方式主要如下两种：</p>
<ul>
<li><p>构造方式实例化：底层通过构造方法对Bean进行实例化 (一般默认我们都是进行无参创建….所以这个没啥奇怪的，也没啥细说的)</p>
</li>
<li><p>工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化</p>
<h3 id="工厂实例化"><a href="#工厂实例化" class="headerlink" title="工厂实例化"></a>工厂实例化</h3><p>工厂实例化和@Bean注解的性质一样，可以创建不是我们写的代码的bean<br>工厂方式实例化Bean，又分为如下三种：<br>⚫ 静态工厂方法实例化Bean<br>⚫ 实例工厂方法实例化Bean<br>⚫ 实现FactoryBean规范延迟实例化Bean</p>
<h4 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.haohao.factory.MyFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserByFactory&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      如果这个方法需要传入参数，这里可以用这个标签传递参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haohao.factory;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>import com.haohao.Entity.User;</p>
<p>&#x2F;&#x2F;静态工厂实例化<br>public class MyFactory {<br> &#x2F;&#x2F;注意这里的static，这里就是和实例工厂的区别<br> public static User createUserByFactory(){<br> &#x2F;&#x2F;这里还可以创建一些非我们自己写的Bean<br> return new User();<br> }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    Object u = applicationContext.getBean(&quot;myUser&quot;);</span><br><span class="line">    System.err.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例工厂实例化"><a href="#实例工厂实例化" class="headerlink" title="实例工厂实例化"></a>实例工厂实例化</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        先创建myFactory对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.haohao.factory.MyFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        在这里通过factory-bean=&quot;myFactory&quot; 进行引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.haohao.factory.MyFactory&quot;</span>  <span class="attr">factory-bean</span>=<span class="string">&quot;myFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserByFactory&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--        如果这个方法需要传入参数，这里可以用这个标签传递参数--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--        &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haohao.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.haohao.Entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态工厂实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里没有static了，这里就是和静态工厂的区别，所以我们要先创建MyFactory这个bean，才能创建User对象</span></span><br><span class="line">    <span class="keyword">public</span>  User <span class="title function_">createUserByFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里还可以创建一些非我们自己写的Bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">u</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;myUser&quot;</span>);</span><br><span class="line">    System.err.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  注意，这里配置的是类MyFactory，但是获取对象的却是user对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.haohao.factory.MyFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haohao.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.haohao.Entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FactoryBean实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactory</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line">    <span class="comment">//这里创建的对象，只有用到的时候（也就是getBean的时候才会创建），</span></span><br><span class="line">    <span class="comment">//但是在applicationContext创建之后，会默认创建MyFactory对象，所以在getBean之前，这个bean还一直是MyFactory</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">u</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;myUser&quot;</span>);</span><br><span class="line">    System.err.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="spring的标签"><a href="#spring的标签" class="headerlink" title="spring的标签"></a>spring的标签</h2><p>Spring 的 xml 标签大体上分为两类，一种是默认标签，一种是自定义标签<br>⚫ 默认标签：就是不用额外导入其他命名空间约束的标签，例如 标签<br>⚫ 自定义标签：就是需要<strong>额外引入其他命名空间约束</strong>，并通过前缀引用的标签，例如 context:property-placeholder&#x2F; 标签</p>
<h3 id="默认标签"><a href="#默认标签" class="headerlink" title="默认标签"></a>默认标签</h3><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682173595423-2809cfb1-6789-47d5-8f1e-07bcddc9191d.png" alt="imagepng"></p>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682173621294-130979a8-ef2f-4df5-9234-d2f8a30420aa.png" alt="imagepng"></p>
<h2 id="Spring的Bean实例实例化的基本流程"><a href="#Spring的Bean实例实例化的基本流程" class="headerlink" title="Spring的Bean实例实例化的基本流程"></a>Spring的Bean实例实例化的基本流程</h2><p>先来看两个关键的类 <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682180428467-b15d1ca4-a54a-4257-9ae3-58d0f1928bb3.png" alt="imagepng"> <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682180496848-871105a7-bdf0-4d74-b54c-9db294f97542.png" alt="imagepng"> <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682180519482-a4e82e35-cda8-48f3-88b1-4b2acddc5f19.png" alt="imagepng"> ** Bean 实例化的基本流程 ：**<br>Spring容器在进行初始化时，会将xml配置的的信息封装成一个个<strong>BeanDefinition（一个bean标签对应一个BeanDefinition对象）</strong>对象，所有的 BeanDefinition存储到一个名为<strong>beanDefinitionMap</strong>的Map集合中去。在容器初始化阶段，Spring框架对该Map进行遍历，使用<strong>反射</strong>创建Bean实例对象，创建好的Bean对象存储在一个名为<strong>singletonObjects</strong>的Map集合中，当调用getBean方法时则最终从<strong>singletonObjects</strong>中取出Bean实例对象返回<br>在容器的初始化阶段，Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，通过反射构造方法或调用指定的工厂方法 生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对 应的Bean的实例化操作（也就是说我们可以进行手动添加！)<br>之后：<br> beanDefinitionMap中的<strong>单例的Bean实例的</strong>BeanDefinition会被转化成对应的Bean实例对象，存储到单例池singletonObjects中去</p>
<h3 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h3><p><strong>Bean 实例化的基本流程！！！</strong> </p>
<p>⚫ 加载xml配置文件，解析获取配置中的每个（标签）的信息，封装成一个个的BeanDefinition对象;<br>⚫ 将BeanDefinition存储在一个名为beanDefinitionMap的Map&lt;String,BeanDefinition&gt;中;<br>⚫ ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象;<br>⚫ 创建好的Bean实例对象，被存储到一个名为singletonObjects的Map&lt;String,Object&gt;中;<br>⚫ 当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回。 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682181172445-14098d6e-c1e0-4259-aa31-4b3fbabaac20.png#averageHue=%23eae7e7&clientId=u157164f7-20a8-4&from=paste&height=454&id=u1bcea425&originHeight=567&originWidth=1122&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121224&status=done&style=shadow&taskId=u5c7b1a92-b6eb-43bc-ac04-f2049abafe6&title=&width=897.6" alt="imagepng"></p>
<h2 id="spring的后置处理器"><a href="#spring的后置处理器" class="headerlink" title="spring的后置处理器"></a>spring的后置处理器</h2><ul>
<li>Spring的后处理器<br>Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册（也就是把创建好的BeanDefinition放到BeanDefinitionMap中去）BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用。Spring主要有两种后处理器：<br>⚫ BeanFactoryPostProcessor：Bean工厂后处理器，在BeanDefinitionMap填充完毕（也就是说这个玩意他只会执行<strong>一次</strong>，只在BeanDefinitionMap填充完毕之后执行），Bean实例化之前执行；<br>⚫ BeanPostProcessor：Bean后处理器，一般在Bean实例化之后（也就是说这个玩意会执行<strong>多次</strong>，每一个bean进行实例化后都会执行），填充到单例池singletonObjects之前执行。</li>
</ul>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haohao.postProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.haohao.Entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.GenericBeanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在BeanDefinitionMap填充完毕&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;（也就是说这个玩意他只会执行一次，只在BeanDefinitionMap填充完毕之后执行），&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;Bean实例化之前执行,&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;也就是说我们可以在这里手动修改BeanDefinitionMap的信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个类是ConfigurableListableBeanFactory的子类，有更强大的功能</span></span><br><span class="line">        <span class="comment">//这个类可以进行注册BeanDefinition的功能</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (DefaultListableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们可以自己创建BeanDefinition</span></span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClass(User.class);</span><br><span class="line">        factory.registerBeanDefinition(<span class="string">&quot;myUser&quot;</span>,beanDefinition);</span><br><span class="line">        System.out.println(<span class="string">&quot;我们自己加入BeanDefinition成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   注册MyBeanFactoryPostProcessor--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.haohao.postProcessor.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext2.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) c.getBean(<span class="string">&quot;myUser&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外： Spring 还提供了一个BeanFactoryPostProcessor的子接口<strong>BeanDefinitionRegistryPostProcessor</strong>专门用于注册 BeanDefinition操作<br><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682218625761-554db12e-5163-408e-a06e-cb66821a8d32.png" alt="imagepng"></p>
<p>图示总结： <img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1682221162767-383e42e3-b77b-4fa1-b179-1626cb9de125.png" alt="imagepng"></p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面的 Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被 Spring自动调用。<br>BeanPostProcessor的接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始演示：<br>自定义MyBeanPostProcessor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span></span><br><span class="line"><span class="comment">    返回值：当前Bean实例对象 */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor的before方法...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span></span><br><span class="line"><span class="comment">    返回值：当前Bean实例对象 */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor的after方法...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在核心配置文件中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;com.itheima.processors.MyBeanPostProcessor&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>案例 ：对Bean方法进行执行时间日志增强<br>要求如下：<br>⚫ Bean的方法执行之前控制台打印当前时间；<br>⚫ Bean的方法执行之后控制台打印当前时间。<br>分析：<br>⚫ 对方法进行增强主要就是代理设计模式和包装设计模式；<br>⚫ 由于Bean方法不确定，所以使用动态代理在运行期间执行增强操作；<br>⚫ 在Bean实例创建完毕后，进入到单例池之前，使用Proxy代替真是的目标Bean<br>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//对Bean进行动态代理，返回的是Proxy代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxyBean</span> <span class="operator">=</span> Proxy.newProxyInstance(bean.getClass().getClassLoader(),</span><br><span class="line">                                              bean.getClass().getInterfaces(),</span><br><span class="line">                                              (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">                                                  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(start));</span><br><span class="line">                                                  <span class="comment">//执行目标方法</span></span><br><span class="line">                                                  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(bean, args);</span><br><span class="line">                                                  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                                                  System.out.println(<span class="string">&quot;结束时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(end));</span><br><span class="line">                                                  <span class="keyword">return</span> result;</span><br><span class="line">                                              &#125;);</span><br><span class="line">    <span class="comment">//返回代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后把这个类配置到核心配置类中<br>可以进行验证了，创建的每一个bean调用的每一个方法都会打印运行时间 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682227795171-c42c375e-df62-4c98-901d-4d5f8120230b.png#averageHue=%23ede8e7&clientId=u85d420bf-4e40-4&from=paste&height=382&id=u1a840cff&originHeight=477&originWidth=1155&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124291&status=done&style=shadow&taskId=u71f56fdc-3ac5-430c-8ff9-280f33ed7ca&title=&width=924" alt="imagepng"></p>
<h2 id="Spring的Bean的生命周期"><a href="#Spring的Bean的生命周期" class="headerlink" title="Spring的Bean的生命周期"></a>Spring的Bean的生命周期</h2><p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：<br>⚫ Bean的实例化阶段：Spring框架会<strong>取出BeanDefinition的信息进行判断</strong>当前Bean的范围是否是singleton的，是否不是延迟加载的，是否不是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化；<br>⚫ Bean的初始化阶段：Bean创建之后还仅仅是个”半成品”，还需要对Bean实例的<strong>属性进行填充（这里和suns讲的不一样）</strong>、执行一些Aware接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，后面要学习的Spring的注解功能等、spring高频面试题Bean的循环引用问题都是在这个阶段体现的；<br>⚫ Bean的完成阶段：经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池singletonObjects中去了，即完成了Spring Bean的整个生命周期。</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>由于Bean的初始化阶段的步骤比较复杂，所以着重研究Bean的初始化阶段<br>Spring Bean的初始化过程涉及如下几个过程：<br>⚫ Bean实例的属性填充<br>⚫ Aware接口属性注入<br>⚫ BeanPostProcessor的before()方法回调<br>⚫ InitializingBean接口的初始化方法回调<br>⚫ 自定义初始化方法init回调<br>⚫ BeanPostProcessor的after()方法回调</p>
<h4 id="Bean实例属性填充"><a href="#Bean实例属性填充" class="headerlink" title="Bean实例属性填充"></a>Bean实例属性填充</h4><p>BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，<br>例如UserService的属性信息如下:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682237988311-a5b19546-94d9-4b7f-ba96-a38821fc53f5.png#averageHue=%23e2d5c6&clientId=u85d420bf-4e40-4&from=paste&height=266&id=u002bf305&originHeight=332&originWidth=1025&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=200137&status=done&style=shadow&taskId=uef7f1913-6b25-4c1c-bea8-8a9d81a6da1&title=&width=820" alt="imagepng"> 我们可以发现，对userservice对象进行了属性填充：<br>但是我们不仅仅可以填充userDao对象<br>还可以填充其他对象，这就出现了一些问题：</p>
<p>Spring在进行属性注入时，会分为如下几种情况：<br>⚫ 注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去；<br>⚫ 注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象Bean实例（完成整个生命周期）后，在进行注入操作；<br>⚫ 注入双向对象引用属性时，就比较复杂了，涉及了循环引用（循环依赖）问题，下面会详细阐述解决方案。</p>
<h5 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h5><p>多个实体之间相互依赖并形成闭环的情况就叫做”循环依赖”，也叫做”循环引用”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao=userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userService=userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况很少出现，但是也有可能出现，有可能的话，spring这个框架就得考虑到这种情况。。。。<br>画图来描述这种情况： <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682238631425-637cf79e-fe82-481f-8337-09594536155c.png#averageHue=%23f5f2f0&clientId=u85d420bf-4e40-4&from=paste&height=433&id=uf62926a4&originHeight=541&originWidth=1284&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=235270&status=done&style=shadow&taskId=udca40fd2-20fc-4df5-a1dc-0536f094889&title=&width=1027.2" alt="imagepng"> 所以为了解决这个问题，出现了三级缓存的概念，其实就是三个map，然后存储不同时刻的beanMap集合<br>Spring提供了三级缓存存储 完整Bean实例 和 半成品Bean实例 ，用于解决循环引用问题<br>在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> ... &#123;</span><br><span class="line">    <span class="comment">//1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span></span><br><span class="line">    Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span></span><br><span class="line">    Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span></span><br><span class="line">    Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面有一个<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</code> 也就是第三级缓存，这里的value是ObjectFactory <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682239564137-ff9a3c31-6847-497a-9e2b-9867b4176a51.png#averageHue=%232e2c2b&clientId=u85d420bf-4e40-4&from=paste&height=325&id=uc8fdfefa&originHeight=406&originWidth=840&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=55856&status=done&style=shadow&taskId=u7070b223-48f5-4335-baee-9c5f83b9a4e&title=&width=672" alt="imagepng"></p>
<p>UserService和UserDao循环依赖的过程结合上述三级缓存描述一下</p>
<ul>
<li>⚫ UserService 实例化对象，但尚未初始化，将UserService存储到三级缓存；</li>
<li>⚫ UserService 属性注入，需要UserDao，从缓存中获取，没有UserDao；</li>
<li>⚫ UserDao实例化对象，但尚未初始化，将UserDao存储到到三级缓存；</li>
<li>⚫ UserDao属性注入，需要UserService，从三级缓存获取UserService，UserService从三级缓存移入二级缓存；</li>
<li>⚫ UserDao执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存；</li>
<li>⚫ UserService 注入UserDao；</li>
<li>⚫ UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/27086425/1682258666515-fe345e8f-3e20-4ef2-b01d-2eab8979a048.pdf">三级缓存源码剖析流程.pdf</a></p>
<h4 id="Aware接口属性注入"><a href="#Aware接口属性注入" class="headerlink" title="Aware接口属性注入"></a>Aware接口属性注入</h4><p>Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能API不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了 ，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象。<br>常用的Aware接口 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682258807687-ba620f59-362b-4bf5-90d2-149ddc84473e.png#averageHue=%23becce1&clientId=u66d32670-5100-4&from=paste&height=300&id=ue9dc9fff&originHeight=375&originWidth=1690&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=146630&status=done&style=shadow&taskId=u0a1cafa7-5f7b-46cf-be83-36980e2b970&title=&width=1352" alt="imagepng"></p>
<h2 id="Spring-IoC容器生命周期过程总结"><a href="#Spring-IoC容器生命周期过程总结" class="headerlink" title="Spring IoC容器生命周期过程总结"></a>Spring IoC容器生命周期过程总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682259680635-0183d46f-23a6-4921-8502-b3839a31ca38.png#averageHue=%23efeeee&clientId=u66d32670-5100-4&from=paste&height=505&id=ubf381083&originHeight=631&originWidth=1325&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=360621&status=done&style=shadow&taskId=ub4325004-dd56-4693-8270-7e0af0c912d&title=&width=1060" alt="imagepng"></p>
<h2 id="Spring整合其他框架的方式"><a href="#Spring整合其他框架的方式" class="headerlink" title="Spring整合其他框架的方式"></a>Spring整合其他框架的方式</h2><p>Spring xml方式整合第三方框架<br>xml整合第三方框架有两种整合方案：<br>⚫ 不需要自定义名空间，不需要使用Spring的配置文件配置第三方框架本身内容，例如：MyBatis；<br>⚫ 需要引入第三方框架命名空间，需要使用Spring的配置文件配置第三方框架本身内容，例如：Dubbo。</p>
<h3 id="不需要自定义命名空间"><a href="#不需要自定义命名空间" class="headerlink" title="不需要自定义命名空间"></a>不需要自定义命名空间</h3><h4 id="MyBatis整合Spring"><a href="#MyBatis整合Spring" class="headerlink" title="MyBatis整合Spring"></a>MyBatis整合Spring</h4><p>Spring整合MyBatis的步骤如下：<br>⚫ 导入MyBatis整合Spring的相关坐标；<br>⚫ 编写Mapper和Mapper.xml；<br>⚫ 配置SqlSessionFactoryBean和MapperScannerConfigurer；<br>⚫ 编写测试代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置SqlSessionFactoryBean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Mapper包扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from tb_user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathxmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ClassPathxmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> applicationContext.getBean(UserMapper.class);</span><br><span class="line">List&lt;User&gt; all = userMapper.findAll();</span><br><span class="line">System.out.println(all);</span><br></pre></td></tr></table></figure>

<h5 id="Spring整合MyBatis的原理剖析"><a href="#Spring整合MyBatis的原理剖析" class="headerlink" title="Spring整合MyBatis的原理剖析"></a>Spring整合MyBatis的原理剖析</h5><p>整合包里提供了一个SqlSessionFactoryBean和一个扫描Mapper的配置对象，SqlSessionFactoryBean一旦被实例化，就开始扫描Mapper并通过动态代理产生Mapper的实现类存储到Spring容器中。相关的有如下四个类：<br>⚫ SqlSessionFactoryBean：需要进行配置，用于提供SqlSessionFactory；<br>⚫ MapperScannerConfigurer：需要进行配置，用于扫描指定mapper注册BeanDefinition；<br>⚫ MapperFactoryBean：Mapper的FactoryBean，获得指定Mapper时调用getObject方法；<br>⚫ ClassPathMapperScanner：definition.setAutowireMode(2) 修改了自动注入状态，所以MapperFactoryBean中的setSqlSessionFactory会自动注入进去。</p>
<h6 id="SqlSessionFactoryBean"><a href="#SqlSessionFactoryBean" class="headerlink" title="SqlSessionFactoryBean"></a>SqlSessionFactoryBean</h6><p>配置SqlSessionFactoryBean作用是向容器中提供SqlSessionFactory，SqlSessionFactoryBean实现了 FactoryBean和InitializingBean两个接口，所以会自动执行getObject() 和afterPropertiesSet()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactoryBean <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = <span class="built_in">this</span>.buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h6><p>配置MapperScannerConfigurer作用是扫描Mapper，向容器中注册Mapper对应的MapperFactoryBean， MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor和InitializingBean两个接口，会在 postProcessBeanDefinitionRegistry方法中向容器中注册MapperFactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, <span class="string">&quot;,; \t\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ClassPathMapperScanner"><a href="#ClassPathMapperScanner" class="headerlink" title="ClassPathMapperScanner"></a>ClassPathMapperScanner</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.processBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        <span class="comment">//设置Mapper的beanClass是org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line">        definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">        <span class="comment">//PS：autowireMode取值：1是根据名称自动装配，2是根据类型自动装配</span></span><br><span class="line">        definition.setAutowireMode(<span class="number">2</span>); <span class="comment">//设置MapperBeanFactory 进行自动注入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.doScan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="comment">//将扫描到的类注册到beanDefinitionMap中，此时beanClass是当前类全限定名</span></span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> applicationContext.getBean(UserMapper.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionTemplate = <span class="built_in">this</span>.createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要引入第三方框架命名空间"><a href="#需要引入第三方框架命名空间" class="headerlink" title="需要引入第三方框架命名空间"></a>需要引入第三方框架命名空间</h3><p>需求：加载外部properties文件，将键值对存储在Spring容器中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682307069820-4a6e9b3b-89f1-4cef-b59a-a95be309d976.png#averageHue=%23f0eacc&clientId=u9fc06465-ad3c-4&from=paste&height=414&id=uc81fe3a1&originHeight=518&originWidth=1183&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=507254&status=done&style=shadow&taskId=u8a50bbd3-1bf8-4c25-a337-c60f77350bc&title=&width=946.4" alt="imagepng"> 其实，加载的properties文件中的属性最终通过Spring解析后会被存储到了Spring容器的environment中去，不仅自己定义的属性会进行存储，Spring也会把环境相关的一些属性进行存储<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682314348228-cfc1c4ad-52fd-4e1d-9073-50e3b9da2b1e.png#averageHue=%23e1d8cb&clientId=ub898e76a-eb6b-4&from=paste&height=355&id=u7b4d83b3&originHeight=444&originWidth=1375&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=536856&status=done&style=shadow&taskId=ue2a4763b-ec8e-460c-8706-2db97f968f5&title=&width=1100" alt="imagepng"></p>
<h4 id="自定义命名空间标签"><a href="#自定义命名空间标签" class="headerlink" title="自定义命名空间标签"></a>自定义命名空间标签</h4><p>下面这个部分是讲的是自定义标签（也就是有命名空间头信息的标签！虽然也没咋用过）<br>首先了解这个：<br>spring.schemas <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680925844793-30782bd1-a20c-49bf-96b9-f00c361bd1cf.png#averageHue=%238a683a&clientId=u51daac5d-73c9-4&from=paste&height=542&id=u5124f944&originHeight=677&originWidth=1875&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=278217&status=done&style=shadow&taskId=u41ce2e52-9817-4d31-81b7-9ff3aefc8c2&title=&width=1500" alt="imagepng"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;mvc:annotation-driven&gt;</span></span><br><span class="line"><span class="comment">Spring MVC用来提供Controller请求转发，</span></span><br><span class="line"><span class="comment">json自动转换等功能。，默认会帮我们注册默认处理请求，参数和返回值的类</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">例如：写一个最简单的返回ModelAndView的Controller，不加annotation-driven，你会发现它是可以运行的，</span></span><br><span class="line"><span class="comment">但如果改成返回Json对象加上ResponseBody就会报错，这正好映证了文档中的说法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680924459562-5572e2fe-b0e5-49a0-b032-d7f9c9fefde0.png#averageHue=%232e2d2c&clientId=u51daac5d-73c9-4&from=paste&height=375&id=u94cdd570&originHeight=469&originWidth=1235&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90247&status=done&style=shadow&taskId=u7debed27-eb5c-4746-86d2-b63989a87a7&title=&width=988" alt="imagepng"> 下面这个handler的意思是如果你写了mvc这个命名空间，就会被这个handler给处理 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680923891721-e4795a85-910f-495b-92b8-b47a8c5d2b55.png#averageHue=%23727c50&clientId=u51daac5d-73c9-4&from=paste&height=138&id=u451bd45d&originHeight=172&originWidth=1448&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29502&status=done&style=shadow&taskId=udec73a0d-a3c8-4d51-b781-dfaea2c351d&title=&width=1158.4" alt="imagepng"> 看一下这个handler，这个handler的功能就是：根据你使用的不同标签，创建不同的解析器，我们上面就用到的是annotation-driven标签 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680924759865-bf10c178-1d61-4e82-a4e0-1328e66793f8.png#averageHue=%232f2e2d&clientId=u51daac5d-73c9-4&from=paste&height=515&id=u0b9249c5&originHeight=644&originWidth=1487&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=184405&status=done&style=shadow&taskId=u4abae417-fdb9-4b31-a2b3-362616b33ab&title=&width=1189.6" alt="imagepng"> 看一下这个解析器具体干啥了 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680926030828-f3e7e84e-4eb3-4f53-a578-45abaff40c01.png#averageHue=%232e2c2b&clientId=u51daac5d-73c9-4&from=paste&height=578&id=u602d98be&originHeight=723&originWidth=1343&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=129385&status=done&style=shadow&taskId=u7fa0d060-1291-4f3f-8fe7-dc90a7dafbf&title=&width=1074.4" alt="imagepng"> 总结来说就是通过handler-&gt;parser-&gt;beanDefination</p>
<p>ok,下面我们来<strong>自己实现一个自定义标签</strong>。 <code>&lt;haohao:user id=&quot;&quot; name=&quot;&quot; password=&quot;&quot;/&gt;</code> 文件结构： <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1680933833660-a89ea77f-a5e6-493e-8d62-f62930746ee2.png#averageHue=%2349544a&clientId=u51daac5d-73c9-4&from=paste&height=574&id=udbb0cdbc&originHeight=717&originWidth=346&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=31095&status=done&style=shadow&taskId=u7b3e81c2-2d5a-44fd-b9c7-523ec604ec0&title=&width=276.8" alt="imagepng"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://www.haohao.com/schema/user=com.haohao.handler.UserHandler</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://www.haohao.com/schema/user.xsd=META-INF/user.xsd</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> <span class="title class_">MyUserParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserParser</span> <span class="keyword">extends</span> <span class="title class_">AbstractSingleBeanDefinitionParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:haohao</span>=<span class="string">&quot;http://www.haohao.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.haohao.com/schema/user</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.haohao.com/schema/user.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">haohao:user</span> <span class="attr">id</span>=<span class="string">&quot;u&quot;</span> <span class="attr">name</span>=<span class="string">&quot;haohao&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.haohao.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:tns</span>=<span class="string">&quot;http://www.haohao.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">u</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;u&quot;</span>);</span><br><span class="line">    System.err.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有很多对应关系，我真的弄了好久好久</p>
<p>总结一下步骤：Spring xml方式整合第三方框架<br>步骤分析：</p>
<ol>
<li>确定命名空间名称、schema虚拟路径、标签名称；</li>
<li>编写schema约束文件haohao-annotation.xsd</li>
<li>在类加载路径下创建META目录，编写约束映射文件spring.schemas和处理器映射文件spring.handlers</li>
<li>编写命名空间处理器 HaohaoNamespaceHandler，在init方法中注册HaohaoBeanDefinitionParser</li>
<li>编写标签的解析器 HaohaoBeanDefinitionParser，在parse方法中注册HaohaoBeanPostProcessor</li>
<li>编写HaohaoBeanPostProcessor<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以上五步是框架开发者写的，以下是框架使用者写的&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</li>
<li>在applicationContext.xml配置文件中引入命名空间</li>
<li>在applicationContext.xml配置文件中使用自定义的标签</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上述分析，我们清楚的了解了外部命名空间标签的执行流程，如下：<br>⚫ 将自定义标签的约束 与 物理约束文件与网络约束名称的约束 以键值对形式存储到一个spring.schemas文件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;<br>⚫ 将自定义命名空间的名称 与 自定义命名空间的处理器映射关系 以键值对形式存在到一个叫spring.handlers文件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;<br>⚫ 准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时在分流给不同的BeanDefinitionParser进行解析(重写doParse方法即可)</p>
<h2 id="基于注解的Spring应用"><a href="#基于注解的Spring应用" class="headerlink" title="基于注解的Spring应用"></a>基于注解的Spring应用</h2><h3 id="bean标签属性的注解"><a href="#bean标签属性的注解" class="headerlink" title="bean标签属性的注解"></a>bean标签属性的注解</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682315753089-cce25889-92e6-44af-8949-3f042d73fb72.png#averageHue=%23e9efdb&clientId=ub898e76a-eb6b-4&from=paste&height=199&id=ua69e59f4&originHeight=249&originWidth=1023&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=107391&status=done&style=shadow&taskId=ue8dcd594-9f23-4692-be7e-778bb5a8ded&title=&width=818.4" alt="imagepng"> <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682315828602-5e7f4019-8ca1-4c97-9c8e-1a65dee7c83b.png#averageHue=%23e9efdc&clientId=ub898e76a-eb6b-4&from=paste&height=351&id=u321944fb&originHeight=439&originWidth=1027&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=169916&status=done&style=shadow&taskId=u053e5c11-3645-4bdf-b29b-ba04282f75b&title=&width=821.6" alt="imagepng"> 具体使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="meta">@Lazy(true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Primary注解"><a href="#Primary注解" class="headerlink" title="@Primary注解"></a>@Primary注解</h3><p>@Primary注解用于标注相同类型的Bean优先被使用权，@Primary 是Spring3.0引入的，与@Component 和@Bean一起使用，标注该Bean的优先级更高，则在通过类型获取Bean或通过@Autowired根据类型进行注入时， 会选用优先级更高的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Component(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao01</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao02</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl2</span>();&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h3><p>@Profile 注解的作用同于xml配置时学习profile属性，是进行环境切换使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans profile=<span class="string">&quot;test&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>注解 @Profile 标注在类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才 能被注册到Spring容器里，不指定环境的Bean，任何环境下都能注册到Spring容器里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以下两种方式指定被激活的环境：<br>⚫ 使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test<br>⚫ 使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”);</p>
<h3 id="Spring注解的解析原理"><a href="#Spring注解的解析原理" class="headerlink" title="Spring注解的解析原理"></a>Spring注解的解析原理</h3><p>使用@Component等注解配置完毕后，要配置组件扫描才能使注解生效<br>⚫ xml配置组件扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>⚫ 配置类配置组件扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xml配置组件扫描"><a href="#xml配置组件扫描" class="headerlink" title="xml配置组件扫描"></a>xml配置组件扫描</h4><p>使用xml方式配置组件扫描，而component-scan是一个context命名空间下的自定义标签，所以要找到对应的<strong>命名空间处理器NamespaceHandler</strong> 和 <strong>解析器</strong>，查看spring-context包下的spring.handlers文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http\://www.springframework.org/schema/context</span>=<span class="string">org.springframework.context.config.ContextNamespaceHandler</span></span><br></pre></td></tr></table></figure>

<p>可以看见，这个处理器为ContextNamespaceHandler ，所以我们查看 ContextNamespaceHandler 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将ComponentScanBeanDefinitionParser进行了注册，对其源码进行跟踪，最终将标注的@Component的类，生成对应的BeanDefiition进行了注册</p>
<h4 id="使用配置类配置组件扫描"><a href="#使用配置类配置组件扫描" class="headerlink" title="使用配置类配置组件扫描"></a>使用配置类配置组件扫描</h4><p>使用配置类配置组件扫描，使用AnnotationConfigApplicationContext容器在进行创建时，内部调用了如下代码， 该工具注册了几个Bean后处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682325584767-5ce696ba-076a-4450-bbed-badf0f11218c.png#averageHue=%23f8f6f4&clientId=ub898e76a-eb6b-4&from=paste&height=389&id=u75669ae6&originHeight=486&originWidth=1110&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=410005&status=done&style=shadow&taskId=u990a54f7-c8aa-4c6f-b81a-7941b1abfe1&title=&width=888" alt="imagepng"> 其中，ConfigurationClassPostProcessor 是 一个 BeanDefinitionRegistryPostProcessor(这个就是之前我们见过的可以往beanDefinitionMap中注册bean的类。。，这个ConfigurationClassPostProcessor是BeanDefinitionRegistryPostProcessor的子类) ，经过一系列源码调用，最终也别指定到了 ClassPathBeanDefinitionScanner 的 doScan 方法（与xml方式最终终点一致）</p>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682325721808-3beca5ad-cbb8-43e0-a173-444d79a21d2e.png#averageHue=%23f9f4f4&clientId=ub898e76a-eb6b-4&from=paste&height=407&id=ubaa40071&originHeight=509&originWidth=822&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=70181&status=done&style=shadow&taskId=u3b775d18-e3e4-4cc2-8a6b-6095be6d986&title=&width=657.6" alt="imagepng"></p>
<h2 id="Spring注解方式整合第三方框架"><a href="#Spring注解方式整合第三方框架" class="headerlink" title="Spring注解方式整合第三方框架"></a>Spring注解方式整合第三方框架</h2><p>第三方框架整合，依然使用MyBatis作为整合对象，之前我们已经使用xml方式整合了MyBatis，现在使用注解方式无非就是将xml标签替换为注解，将xml配置文件替换为配置类而已，原有xml方式整合配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置SqlSessionFactoryBean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Mapper包扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用@Bean将DataSource和SqlSessionFactoryBean存储到Spring容器中，而MapperScannerConfigurer使用注 解@MapperScan进行指明需要扫描的Mapper在哪个包下，使用注解整合MyBatis配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.itheima.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;&#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解方式，Spring整合MyBatis的原理，关键在于@MapperScan，@MapperScan不是Spring提供的注解，是 MyBatis为了整合Spring，在整合包org.mybatis.spring.annotation中提供的注解，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;MapperScannerRegistrar.class&#125;)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注一下@Import({MapperScannerRegistrar.class})，当@MapperScan被扫描加载时，会解析@Import注 解，从而加载指定的类，此处就是加载了MapperScannerRegistrar<br>MapperScannerRegistrar实现了ImportBeanDefinitionRegistrar接口，Spring会自动调用 registerBeanDefinitions方法，该方法中又注册MapperScannerConfigurer类，而MapperScannerConfigurer类 作用是扫描Mapper，向容器中注册Mapper对应的MapperFactoryBean，前面讲过，此处不在赘述了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, </span><br><span class="line">    ResourceLoaderAware &#123;</span><br><span class="line">    <span class="comment">//默认执行registerBeanDefinitions方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, </span></span><br><span class="line"><span class="params">                                 BeanDefinitionRegistry registry, String beanName)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">        <span class="comment">//... 省略其他代码 ...</span></span><br><span class="line">        <span class="comment">//注册BeanDefinition</span></span><br><span class="line">        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring与MyBatis注解方式整合有个重要的技术点就是@Import，第三方框架与Spring整合xml方式很多是凭借自定义标签完成的，而第三方框架与Spring整合注解方式很多是靠@Import注解完成的。<br>@Import可以导入如下三种类：<br>⚫ 普通的配置类<br>⚫ 实现ImportSelector接口的类<br>⚫ 实现ImportBeanDefinitionRegistrar接口的类</p>
<p>@Import导入实现了ImportSelector接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">//返回要进行注册的Bean的全限定名数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;User2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImportSelector接口selectImports方法的参数AnnotationMetadata代表注解的媒体数据，可以获得当前注解修饰 的类的元信息，例如：获得组件扫描的包名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">//获得指定类型注解的全部信息</span></span><br><span class="line">        Map&lt;String, Object&gt; annotationAttributes = </span><br><span class="line">            annotationMetadata.getAnnotationAttributes(ComponentScan.class.getName());</span><br><span class="line">        <span class="comment">//获得全部信息中basePackages信息</span></span><br><span class="line">        String[] basePackages = (String[]) annotationAttributes.get(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">        <span class="comment">//打印结果是com.itheima</span></span><br><span class="line">        System.out.println(basePackages[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;User2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import导入实现ImportBeanDefinitionRegistrar接口的类，实现了该接口的类的registerBeanDefinitions方法 会被自动调用，在该方法内可以注册BeanDefinition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, </span></span><br><span class="line"><span class="params">                                        BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//使用给定的BeanDefinitionRegistry参数，手动注册BeanDefinition</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">&quot;com.itheima.pojo.User2&quot;</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;user2&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p>其实在之前学习BeanPostProcessor时，在BeanPostProcessor的after方法中使用动态代理对Bean进行了增强，实际存储到单例池singleObjects中的不是当前目标对象本身，而是当前目标对象的代理对象Proxy，这样在调用目标对象方法时，实际调用的是代理对象Proxy的同名方法，起到了目标方法前后都进行增强的功能。</p>
<ul>
<li>aspectj静态代理<ul>
<li>原理：在编译期织入代码，编译成class文件</li>
<li>优点:可以增强任何类，任何方法，包括（final,static修饰）</li>
<li>缺点:需要使用aspecj提供的Ajc编译器来编译Aj文件</li>
</ul>
</li>
<li>jdk动态代理<ul>
<li>使用jdk的动态代理来增强接口实现类</li>
<li>原理：使用Proxy类的newProxyInstance方法运行期通过反射动态的生成代理对象</li>
<li>优点：不需要修改具体的业务代码，动态的增强方法，降低耦合性。</li>
<li>缺点：代理的对象必须有接口实现。</li>
</ul>
</li>
<li>cglib的动态代理<ul>
<li>可以对jdk的动态代理作为补充</li>
<li>原理：以创建目标类的子类来生成动态代理对象。</li>
<li>优点：不需要修改具体的业务代码，动态的增强方法，降低耦合性。</li>
<li>缺点：不能对final修饰的类，final修饰的方法或static的方法进行代理</li>
</ul>
</li>
</ul>
<p>AOP（面向切面编程）是一种编程范式，它可以让开发者在不修改原有代码的情况下，通过定义切面和切点来增强程序的功能。例如，可以在方法执行前、执行后或异常时插入切面逻辑，实现日志记录、性能监控、事务管理等功能。<br>在Java中，AOP框架可以分为基于<strong>代理的AOP</strong>和<strong>基于字节码生成的AOP</strong>两种实现方式。<br>Spring AOP是基于代理的AOP框架，它可以通过<strong>Java动态代理</strong>或<strong>CGLIB代理</strong>来实现对目标类方法的代理。<strong>Java动态代理只能代理实现接口的类，而CGLIB代理可以代理任意的类。</strong>Spring AOP默认使用Java动态代理来实现AOP，但当目标类没有实现接口时，它会自动切换到使用CGLIB代理。Spring AOP的切面和切点可以通过注解或XML配置文件来定义。例如，可以使用@Aspect注解来定义一个切面类，并使用@Pointcut注解来定义一个切点。在定义完切面和切点后，可以使用@Before、@After、@Around等注解来定义切面逻辑，并将切面类注册到Spring容器中。<br>AspectJ是一个独立的AOP框架，它提供了比Spring AOP更强大和灵活的AOP能力。AspectJ支持基于编译器、类加载器和运行时三种不同的AOP实现方式。其中，基于编译器和类加载器的实现方式需要在<strong>编译时</strong>或加载时对Java字节码进行增强，而基于<strong>运行时</strong>的实现方式则可以动态地对Java类进行增强。与Spring AOP不同，AspectJ使用<strong>注解</strong>或<strong>AspectJ语言（AJ）</strong>来定义切面和切点。例如，可以使用@Aspect注解来定义一个切面类，并使用@Pointcut注解来定义一个切点。在定义完切面和切点后，可以使用@Before、@After、@Around等注解或AJ语言来定义切面逻辑。<br>CGLIB是一个Java字节码生成库，它可以在<strong>运行时</strong>动态生成Java类，并在<strong>内存</strong>中加载。CGLIB动态代理是基于<strong>字节码生成</strong>的动态代理技术，它可以<strong>代理任意的类</strong>，包括<strong>没有实现接口的类</strong>。CGLIB动态代理<strong>通过生成目标类的子类</strong>来创建代理对象，代理类中的方法会调用MethodInterceptor接口的intercept方法，并在其中实现切面逻辑。<br>JDK动态代理是Java原生支持的动态代理技术，它是通过反射和接口实现的。JDK动态代理要求目标类必须是<strong>实现了接口的类</strong>，它会在<strong>运行时</strong>创建一个实现了代理接口的代理类，代理类中的方法会调用InvocationHandler接口的invoke方法，并在其中实现切面逻辑。</p>
<p>需要注意的是，由于<strong>CGLIB动态代理</strong>是基于字节码生成的技术，它需要在<strong>运行时</strong>生成<strong>代理类的字节码</strong>，并在<strong>内存</strong>中加载。因此，CGLIB动态代理可能会比JDK动态代理更耗时和占用更多的内存。同时，CGLIB动态代理也无法代理final方法和final类。<br>总之，Spring AOP、AspectJ和CGLIB都是Java中的AOP框架，它们可以用来实现切面编程。Spring AOP是Spring框架内置的AOP框架，基于代理实现；AspectJ是一个独立的AOP框架，提供更强大和灵活的AOP能力；CGLIB是一个Java字节码生成库，用于生成代理类。</p>
<h3 id="基于JDK动态代理实现AOP的原始案例"><a href="#基于JDK动态代理实现AOP的原始案例" class="headerlink" title="基于JDK动态代理实现AOP的原始案例"></a>基于JDK动态代理实现AOP的原始案例</h3><p>现在给一个需求：用JDK动态代理的方式，使用BeanPostProcessor实现对<strong>com.itheima.service.impl包下的所有类的所有方法</strong>实现AOP代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置的增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show1....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockAopBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//目的：对UserServiceImpl中的show1和show2方法进行增强，增强方法存在与MyAdvice中</span></span><br><span class="line">        <span class="comment">//问题1：筛选service.impl包下的所有的类的所有方法都可以进行增强，解决方案if-else</span></span><br><span class="line">        <span class="comment">//问题2：MyAdvice怎么获取到？解决方案：从Spring容器中获得MyAdvice</span></span><br><span class="line">        <span class="keyword">if</span>(bean.getClass().getPackage().getName().equals(<span class="string">&quot;com.itheima.service.impl&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//生成当前Bean的Proxy对象,这里使用JDK的动态代理</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">beanProxy</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">                    bean.getClass().getClassLoader(),</span><br><span class="line">                    bean.getClass().getInterfaces(),</span><br><span class="line">                    (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">                        <span class="type">MyAdvice</span> <span class="variable">myAdvice</span> <span class="operator">=</span> applicationContext.getBean(MyAdvice.class);</span><br><span class="line">                        <span class="comment">//执行增强对象的before方法</span></span><br><span class="line">                        myAdvice.beforeAdvice();</span><br><span class="line">                        <span class="comment">//执行目标对象的目标方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(bean, args);</span><br><span class="line">                        <span class="comment">//执行增强对象的after方法</span></span><br><span class="line">                        myAdvice.afterAdvice();</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> beanProxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是这个包下面的类，就不会创建代理对象，还返回原来的对象</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Aware的接口就是干这个的，全局都可以获取这些对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这三个类都需要注册到spring容器中才能完成这些操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">bean</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br><span class="line">bean.show1();</span><br></pre></td></tr></table></figure>

<h3 id="基于xml配置的AOP"><a href="#基于xml配置的AOP" class="headerlink" title="基于xml配置的AOP"></a>基于xml配置的AOP</h3><h4 id="第一种方式：aspect"><a href="#第一种方式：aspect" class="headerlink" title="第一种方式：aspect"></a>第一种方式：aspect</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类,内部的方法是连接点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置通知类,内部的方法是增强方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“myAdvice</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.itheima.advice.MyAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置切点表达式,对哪些方法进行增强--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(void com.itheima.service.impl.UserServiceImpl.show1())&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--切面=切点+通知--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定前置通知方法是beforeAdvice--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定后置通知方法是afterAdvice--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通知方法的参数"><a href="#通知方法的参数" class="headerlink" title="通知方法的参数"></a>通知方法的参数</h5><p>通知方法（也就是上面的beforeAdvice、afterAdvice…等方法）在被调用时，Spring可以为其传递一些必要的参数<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682510852651-7afa750c-2f1d-4636-9195-3a79c6a3f839.png#averageHue=%23acbfd9&clientId=udd5b1be1-beac-4&from=paste&height=210&id=ud5c31847&originHeight=210&originWidth=1291&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=92496&status=done&style=shadow&taskId=ub3531813-4823-4ff7-987d-77ff712d0ff&title=&width=1291" alt="imagepng"></p>
<h6 id="JoinPoint-对象"><a href="#JoinPoint-对象" class="headerlink" title="JoinPoint 对象"></a>JoinPoint 对象</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 通知方法名称(JoinPoint joinPoint)&#123;</span><br><span class="line">    <span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getArgs());</span><br><span class="line">    <span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());</span><br><span class="line">    <span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ProceedingJoinPoint对象"><a href="#ProceedingJoinPoint对象" class="headerlink" title="ProceedingJoinPoint对象"></a>ProceedingJoinPoint对象</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(joinPoint.getArgs());<span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());<span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());<span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();<span class="comment">//执行目标方法</span></span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//返回目标方法返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Throwable对象"><a href="#Throwable对象" class="headerlink" title="Throwable对象"></a>Throwable对象</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable th)</span>&#123;</span><br><span class="line">    <span class="comment">//获得异常信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;异常对象是：&quot;</span>+th+<span class="string">&quot;异常信息是：&quot;</span>+th.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须配置<strong>异常通知</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;aop:after-throwing method=<span class="string">&quot;afterThrowing&quot;</span> pointcut-ref=<span class="string">&quot;myPointcut&quot;</span> throwing=<span class="string">&quot;th&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式：advice"><a href="#第二种方式：advice" class="headerlink" title="第二种方式：advice"></a>第二种方式：advice</h4><p>先看一下目录结构 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682512589132-4d4e11af-eb50-48d7-b8c8-a3b7fec97920.png#averageHue=%23514e42&clientId=udd5b1be1-beac-4&from=paste&height=538&id=u00a73774&originHeight=538&originWidth=618&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=75475&status=done&style=shadow&taskId=ua26b4e9d-3b8e-40bb-9fae-954a8a431b8&title=&width=618" alt="imagepng"></p>
<h5 id="MethodBeforeAdvice和AfterReturningAdvice"><a href="#MethodBeforeAdvice和AfterReturningAdvice" class="headerlink" title="MethodBeforeAdvice和AfterReturningAdvice"></a>MethodBeforeAdvice和AfterReturningAdvice</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice2</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span>, AfterReturningAdvice &#123;</span><br><span class="line">    <span class="comment">//注意这里实现了两个接口，一个接口是前置通知，一个接口是后置通知，然后这两个接口里面有两个需要重写的方法</span></span><br><span class="line">    <span class="comment">//这里和上一种的区别是上一种是只写了方法，然后指定哪个方法是前置通知或者后置通知，这个直接给规定好了前置通知和后置通知写到哪个地方</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置的通知类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.advice.MyAdvice2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   这里就不需要指定哪个是前置方法哪个是后置方法了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice2&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h5><p>这个就相当于<strong>around</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice3</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前******&quot;</span>);</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> methodInvocation.getMethod().invoke(methodInvocation.getThis(), methodInvocation.getArguments());</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后******&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置的通知类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.advice.MyAdvice3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice3&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><h5 id="1）配置语法不同："><a href="#1）配置语法不同：" class="headerlink" title="1）配置语法不同："></a>1）配置语法不同：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用advisor配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- advice-ref:通知Bean的id --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用aspect配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ref:通知Bean的id --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;advices&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）通知类的定义要求不同："><a href="#2）通知类的定义要求不同：" class="headerlink" title="2）通知类的定义要求不同："></a>2）通知类的定义要求不同：</h5><p>advisor 需要的通知类需要实现Advice的子功能接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advices</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is before Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is afterReturn Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aspect 不需要通知类实现任何接口，在配置的时候指定哪些方法属于哪种通知类型即可，更加灵活方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advices</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is before Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is afterReturn Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）可配置的切面数量不同："><a href="#3）可配置的切面数量不同：" class="headerlink" title="3）可配置的切面数量不同："></a>3）可配置的切面数量不同：</h5><p>⚫ 一个advisor只能配置一个固定通知和一个切点表达式；<br>⚫ 一个aspect可以配置多个通知和多个切点表达式任意组合，粒度更细。<br>也就是说advisor只能添加一个增强方法，aspect可以配置多个增强方法</p>
<h5 id="4）使用场景不同："><a href="#4）使用场景不同：" class="headerlink" title="4）使用场景不同："></a>4）使用场景不同：</h5><p>⚫ 如果通知类型多、允许随意搭配情况下可以使用aspect进行配置；<br>⚫ 如果通知类型单一、且通知类中通知方法一次性都会使用到的情况下可以使用advisor进行配置；<br>⚫ 在通知类型已经固定，不用人为指定通知类型时，可以使用advisor进行配置，例如后面要学习的Spring事务控制的配置；<br>由于实际开发中，<strong>自定义aop功能的配置大多使用aspect的配置方式</strong></p>
<h4 id="xml方式AOP原理剖析"><a href="#xml方式AOP原理剖析" class="headerlink" title="xml方式AOP原理剖析"></a>xml方式AOP原理剖析</h4><p>通过xml方式配置AOP时，我们引入了AOP的命名空间，根据讲解的，要去找spring-aop包下的META-INF，在去 找spring.handlers文件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682571566966-27c631e5-148e-412e-a8c2-bea480b190a4.png#averageHue=%23fcfbe0&clientId=u23d3dfb3-1e24-4&from=paste&height=244&id=ue8ddba73&originHeight=305&originWidth=1100&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=72121&status=done&style=shadow&taskId=u1da60d35-5064-415b-8a74-2cbacb2cbf9&title=&width=880" alt="imagepng"> 文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>最终加载的是 <strong>AopNamespaceHandler</strong>，该Handler的<strong>init</strong>方法中注册了config标签对应的<strong>解析器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());</span><br></pre></td></tr></table></figure>

<p>以<strong>ConfigBeanDefinitionParser</strong>作为入口进行源码剖析，最终会注册一个<strong>AspectJAwareAdvisorAutoProxyCreator</strong> 进入到Spring容器中<br>看一下集成体系图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682571866186-3b055410-aac2-476e-a479-caeee1d29ff2.png#averageHue=%23fcfcf6&clientId=u23d3dfb3-1e24-4&from=paste&height=314&id=ue02c7582&originHeight=393&originWidth=1017&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=90694&status=done&style=shadow&taskId=ub596207f-2c33-4f08-affe-68707f1edbf&title=&width=813.6" alt="imagepng"> AspectJAwareAdvisorAutoProxyCreator 的上上级父类AbstractAutoProxyCreator中的 <strong>postProcessAfterInitialization（after后置bean处理器）</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数bean：为目标对象</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="built_in">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">//如果需要被增强，则wrapIfNecessary方法最终返回的就是一个Proxy对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过断点方式观察，当bean是匹配切点表达式时，this.<strong>wrapIfNecessary</strong>(bean, beanName, cacheKey)返回的是 一个**JDKDynamicAopProxy ** <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682572166614-a991cefc-470b-44e8-a4c3-9ffb3920cacb.png#averageHue=%23ebdcd4&clientId=u23d3dfb3-1e24-4&from=paste&height=377&id=uc6730b09&originHeight=471&originWidth=1198&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=226279&status=done&style=shadow&taskId=u762bbd13-a7de-4294-ae25-5ee0cc3886f&title=&width=958.4" alt="imagepng"> 对wrapIfNecessary在剖析一下，看看是不是我们熟知的通过JDK的 Proxy.newProxyInstance(ClassLoader loader, Class[]interfaces,InvocationHandler h) 的方式创建的代理对象呢？经过如下一系列源码跟踪</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt; <span class="built_in">this</span>.wrapIfNecessary(bean, beanName, cacheKey)</span><br><span class="line">    ==&gt; <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="built_in">this</span>.createProxy(参数省略)</span><br><span class="line">        ==&gt; proxyFactory.getProxy(classLoader)</span><br><span class="line">            ==&gt; <span class="built_in">this</span>.createAopProxy().getProxy(classLoader)</span><br><span class="line">                 <span class="comment">//getProxy()是一个接口方法，实现类有两个，如下截图</span></span><br><span class="line">                ==&gt; Proxy.newProxyInstance(classLoader, <span class="built_in">this</span>.proxiedInterfaces, <span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682572355788-e63a7cd0-1423-427e-8517-6078c2276d43.png#averageHue=%23f5f1d9&clientId=u23d3dfb3-1e24-4&from=paste&height=166&id=u3b8f991d&originHeight=208&originWidth=671&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=57738&status=done&style=shadow&taskId=u98b5eb86-d568-4653-a6fd-70de2028f7f&title=&width=536.8" alt="imagepng"> 动态代理的实现的选择，在调用getProxy() 方法时，我们可选用的 AopProxy接口有两个实现类，如上图，这两种 都是动态生成代理对象的方式，一种就是基于JDK的，一种是基于Cglib的<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682572509789-cbc0334f-4efa-4ad1-993f-fa8cdaca74c2.png#averageHue=%23b3c5dc&clientId=u23d3dfb3-1e24-4&from=paste&height=165&id=u059b268a&originHeight=206&originWidth=1321&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=149624&status=done&style=shadow&taskId=u2b036948-483e-4d19-a5a0-b4c1a4950b1&title=&width=1056.8" alt="imagepng"> 用图来表示这种关系： <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682572560353-6c2741d0-0743-43a9-b8b5-bc7efebaa071.png#averageHue=%23faf8f8&clientId=u23d3dfb3-1e24-4&from=paste&height=444&id=u2195e0b7&originHeight=555&originWidth=1117&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=108335&status=done&style=shadow&taskId=uc2cad1d4-b3b7-4cb4-9588-7ca144413c6&title=&width=893.6" alt="imagepng"></p>
<h3 id="Cglib基于超类的动态代理"><a href="#Cglib基于超类的动态代理" class="headerlink" title="Cglib基于超类的动态代理"></a>Cglib基于超类的动态代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();<span class="comment">//目标对象</span></span><br><span class="line"><span class="type">Advices</span> <span class="variable">advices</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advices</span>();<span class="comment">//通知对象</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();<span class="comment">//增强器对象</span></span><br><span class="line">enhancer.setSuperclass(Target.class);<span class="comment">//增强器设置父类</span></span><br><span class="line"><span class="comment">//增强器设置回调</span></span><br><span class="line">enhancer.setCallback((MethodInterceptor )(o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">    advices.before();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">    advices.afterReturning();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">targetProxy</span> <span class="operator">=</span> (Target) enhancer.create();</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> targetProxy.show(<span class="string">&quot;haohao&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="基于注解配置的AOP"><a href="#基于注解配置的AOP" class="headerlink" title="基于注解配置的AOP"></a>基于注解配置的AOP</h3><p>Spring的AOP也提供了注解方式配置，使用相应的注解替代之前的xml配置，xml配置AOP时，我们主要配置了三 部分：<strong>目标类被Spring容器管理</strong>、<strong>通知类被Spring管理</strong>、<strong>通知与切点的织入（切面）</strong>，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.TargetImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Advices&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;advices&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用注解表示</p>
<ol>
<li><p>目标类被Spring容器管理、通知类被Spring管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetImpl</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;show Target running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoAdvice</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕前通知...&quot;</span>);</span><br><span class="line">       joinPoint.proceed();</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕后通知...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 配置切面（织入）</span><br><span class="line"></span><br><span class="line">![image.png](https://cdn.nlark.com/yuque/0/2023/png/27086425/1682579551732-8da9a7ff-6171-4552-a469-265202f2aecd.png#averageHue=%23e9eeda&amp;clientId=u23d3dfb3-1e24-4&amp;from=paste&amp;height=271&amp;id=u044a36e5&amp;originHeight=339&amp;originWidth=1327&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=115997&amp;status=done&amp;style=shadow&amp;taskId=uffd5e657-a675-4da5-9003-4a5b32e6c82&amp;title=&amp;width=1061.6)</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置文件方式：</span><br><span class="line">注解@Aspect、@Around需要被Spring解析，所以在Spring核心配置文件中需要配置aspectj的自动代理  </span><br><span class="line">```xml</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.aop&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//第三步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解方式AOP原理剖析"><a href="#注解方式AOP原理剖析" class="headerlink" title="注解方式AOP原理剖析"></a>注解方式AOP原理剖析</h4><p>之前在使用xml配置AOP时，是借助的Spring的外部命名空间的加载方式完成的，使用注解配置后，就抛弃了 标签，而该标签最终加载了名为AspectJAwareAdvisorAutoProxyCreator的BeanPostProcessor ， 最终，在该BeanPostProcessor中完成了代理对象的生成。<br>同样，在注解配置AOP时，从aspectj-autoproxy标签的解析器入手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());</span><br></pre></td></tr></table></figure>

<p>而AspectJAutoProxyBeanDefinitionParser代码内部，最终也是执行了和xml方式AOP一样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source)</span><br></pre></td></tr></table></figure>

<p>如果使用的是核心配置类的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.aop&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看@EnableAspectJAutoProxy源码，使用的也是@Import导入相关解析类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Import导入的AspectJAutoProxyRegistrar源码，一路追踪下去，最终还是注册了 AnnotationAwareAspectJAutoProxyCreator 这个类 ,其实还是那个beanPostProcessor,完成创建代理对象的环节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682580585527-e7fa688d-60bc-4d24-a59a-f6de2003cf86.png#averageHue=%23f7f0f0&clientId=u23d3dfb3-1e24-4&from=paste&height=451&id=uca24fe9f&originHeight=564&originWidth=1250&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102277&status=done&style=shadow&taskId=ub1b9e57d-a4ca-4e6d-a06d-bb58ba71e01&title=&width=1000" alt="imagepng"></p>
<h2 id="Spring的基于AOP的声明式事务控制"><a href="#Spring的基于AOP的声明式事务控制" class="headerlink" title="Spring的基于AOP的声明式事务控制"></a>Spring的基于AOP的声明式事务控制</h2><p>事务是开发中必不可少的东西，<br>使用JDBC开发时，我们使用connnection对事务进行控制;<br>使用MyBatis时，我们使用SqlSession对事务进行控制;<br>缺点显而易见，当我们切换数据库访问技术时，事务控制的方式总会变化， Spring 就将这些技术基础上，<strong>提供了统一的控制事务的接口</strong>。<br>Spring的事务分为：<strong>编程式事务控制</strong> 和 <strong>声明式事务控制</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682593187549-22521cf9-2c64-4b63-aa26-6bfda7e1fab5.png#averageHue=%23b5c5dc&clientId=ua3c88113-13e5-4&from=paste&height=134&id=uf553392d&originHeight=167&originWidth=988&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=79572&status=done&style=shadow&taskId=u8490a377-f91b-44cb-a909-8cfed097c29&title=&width=790.4" alt="imagepng"></p>
<p>Spring事务编程相关的类主要有如下三个<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682593233198-792021f3-946e-45a3-93bc-6b4772f170ef.png#averageHue=%23acbed8&clientId=ua3c88113-13e5-4&from=paste&height=121&id=u77902615&originHeight=151&originWidth=972&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=78951&status=done&style=shadow&taskId=udab5cad2-0582-41d8-99a7-4e9ad4a37e0&title=&width=777.6" alt="imagepng"> <strong>编程式事务控制</strong>对应的这些类我们需要了解一下，因为我们在通过配置的方式进行<strong>声明式事务控制</strong>时也会看到这些类的影子</p>
<h3 id="基于xml声明式事务控制"><a href="#基于xml声明式事务控制" class="headerlink" title="基于xml声明式事务控制"></a>基于xml声明式事务控制</h3><p>可以使用<strong>AOP</strong>对Service的方法进行事务的增强。<br>⚫ 目标类：AccountServiceImpl<br>⚫ 切点：service业务类中的所有业务方法<br>⚫ 通知类：<strong>Spring提供的</strong>，通知方法已经定义好，<strong>只需要配置即可</strong></p>
<ol>
<li><p>配置目标类AccountServiceImpl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccoutServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用advisor标签配置切面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;Spring提供的通知类&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这里还没配置spring提供的通知类！！！下面会配置，这里我们倒着配置</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring提供的事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--     配置transferMoney()方法 触发事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transferMoney&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   这里才配置了Spring提供的事务通知 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里对上面的配置详解：</strong> 首先，平台事务管理器PlatformTransactionManager是Spring提供的封装事务具体操作的规范接口，封装了事务的提交和回滚方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的持久层框架事务操作的方式有可能不同，所以不同的持久层框架有可能会有不同的平台事务管理器实现， 例如，MyBatis作为持久层框架时，使用的平台事务管理器实现是DataSourceTransactionManager（也是我们上面示例的管理器）。 Hibernate作为持久层框架时，使用的平台事务管理器HibernateTransactionManager。<br>其次，事务定义信息配置，每个事务有很多特性，例如：隔离级别、只读状态、超时时间等，这些信息在开发时可以通过connection进行指定，而此处要通过配置文件进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   </span></span><br><span class="line"><span class="comment">      其中，name属性名称指定哪个方法要进行哪些事务的属性配置，此处需要区分的是切点表达式指定的方法与此处指定的方法的区别：</span></span><br><span class="line"><span class="comment">                      切点表达式，是过滤哪些方法可以进行事务增强；</span></span><br><span class="line"><span class="comment">                      事务属性信息的name，是指定哪个方法要进行哪些事务属性的配置</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:method</span>  <span class="attr">name</span>=<span class="string">&quot;方法名称&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">isolation</span>=<span class="string">&quot;隔离级别&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">propagation</span>=<span class="string">&quot;传播行为&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">read-only</span>=<span class="string">&quot;只读状态&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">timeout</span>=<span class="string">&quot;超时时间&quot;</span>/&gt;</span></span><br><span class="line">&lt;/tx:attributes</span><br></pre></td></tr></table></figure>

<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682596980950-f6098815-7180-499d-85d3-55fbb979c946.png#averageHue=%23f5f4f4&clientId=ua3c88113-13e5-4&from=paste&height=325&id=u9e0ba2dc&originHeight=406&originWidth=900&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124208&status=done&style=shadow&taskId=ucdf979b2-2732-48d9-b29f-bf0bce4ac56&title=&width=720" alt="imagepng"><br>方法名在配置时，也可以使用 * 进行模糊匹配，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--精确匹配transferMoney方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transferMoney&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模糊匹配以Service结尾的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*Service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模糊匹配以insert开头的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模糊匹配以update开头的方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模糊匹配任意方法，一般放到最后作为保底匹配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h4><p>isolation属性：指定事务的隔离级别，事务并发存在三大问题：脏读、不可重复读、幻读&#x2F;虚读。<strong>可以通过设置事务的隔离级别来保证并发问题的出现</strong>，常用的是READ_COMMITTED 和 REPEATABLE_READ<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682597087811-e7c153c3-1e64-47b3-aba9-e7cfc5c4527d.png#averageHue=%23b6c5db&clientId=ua3c88113-13e5-4&from=paste&height=230&id=u2bf83b5f&originHeight=287&originWidth=1238&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=154396&status=done&style=shadow&taskId=uc62e1d69-0239-4010-a374-d4785735d80&title=&width=990.4" alt="imagepng"></p>
<h4 id="read-only"><a href="#read-only" class="headerlink" title="read-only"></a>read-only</h4><p>read-only属性：设置当前的只读状态，如果是查询则设置为true，可以提高查询性能，如果是更新（增删改）操作则设置为false</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一般查询相关的业务操作都会设置为只读模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>timeout属性：设置事务执行的超时时间，单位是秒，如果超过该时间限制但事务还没有完成，则自动回滚事务 ，不在继续执行。默认值是-1，即没有超时时间限制</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置查询操作的超时时间是3秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h4><p>propagation属性：设置事务的传播行为，主要解决是A方法调用B方法时，事务的传播方式问题的，例如：使用 单方的事务，还是A和B都使用自己的事务等。事务的传播行为有如下七种属性值可配置<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1682597231826-4f601fa5-f50e-4600-ba35-c601badd304f.png#averageHue=%23becbde&clientId=ua3c88113-13e5-4&from=paste&height=281&id=u1cd6b741&originHeight=351&originWidth=1218&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=156110&status=done&style=shadow&taskId=u97b4f2a1-abca-48c9-9907-f8158e6b088&title=&width=974.4" alt="imagepng"></p>
<h3 id="xml方式声明式事务控制的原理浅析"><a href="#xml方式声明式事务控制的原理浅析" class="headerlink" title="xml方式声明式事务控制的原理浅析"></a>xml方式声明式事务控制的原理浅析</h3><p>tx:advice标签使用的命名空间处理器是<strong>TxNamespaceHandler</strong>，内部注册的是解析器是<strong>TxAdviceBeanDefinitionParser</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br></pre></td></tr></table></figure>

<p><strong>TxAdviceBeanDefinitionParser</strong>中指定了要注册的**BeanDefinition **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">    <span class="keyword">return</span> TransactionInterceptor.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TxAdviceBeanDefinitionParser二级父类<strong>AbstractBeanDefinitionParser</strong>的parse方法将<strong>TransactionInterceptor</strong> 以配置的名称注册到了Spring容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parserContext.registerComponent(componentDefinition);</span><br></pre></td></tr></table></figure>

<p>TransactionInterceptor(<strong>这个玩意就是我们当时学advice里面的环绕通知！！！</strong>)中的invoke方法会被执行，跟踪invoke方法，最终会看到事务的开启和提交<br>⚫ 在AbstractPlatformTransactionManager的132行中开启的事务；<br>⚫ 在TransactionAspectSupport的242行提交了事务</p>
<h3 id="基于注解声明式事务控制"><a href="#基于注解声明式事务控制" class="headerlink" title="基于注解声明式事务控制"></a>基于注解声明式事务控制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="comment">//替代的是这一行，第一个name就不用配置了，因为就写在这个方法头上</span></span><br><span class="line">    <span class="comment">//&lt;tx:method name=&quot;*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED“/&gt;</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false,timeout = 5)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(String decrAccountName, String incrAccountName, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        accountMapper.decrMoney(decrAccountName,money); <span class="comment">//转出钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//模拟某些逻辑产生的异常</span></span><br><span class="line">        accountMapper.incrMoney(incrAccountName,money); <span class="comment">//转入钱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.service&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.itheima.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">tansactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他配置 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转化、文件上传等操作。<br>附：开发需要注意的点：<br>最好在开发的时候封装参数用包装类，也就是不要用int用integer，要不然可能会出错<br>用集合接收参数的时候必须加上@RequestParam注解，要不然也会报错的</p>
<h2 id="三个核心组件"><a href="#三个核心组件" class="headerlink" title="三个核心组件"></a>三个核心组件</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683103938344-20bb89b6-5eff-4c62-8e27-d555dc19f433.png#averageHue=%23b3c4dc&clientId=u9f0bcf28-5dac-4&from=paste&height=272&id=uda4accf2&originHeight=272&originWidth=1567&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=133122&status=done&style=shadow&taskId=ub413dca2-8af4-4196-8c68-17724efcb3f&title=&width=1567" alt="imagepng"> 用图片来表示 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683104247465-7a368293-f886-4cb4-b08e-5cc97b57fdd3.png#averageHue=%23f3eded&clientId=u9f0bcf28-5dac-4&from=paste&height=642&id=u8992aa32&originHeight=642&originWidth=1148&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=170077&status=done&style=shadow&taskId=u3b2369aa-89fd-4e67-8c66-c19fce2b99e&title=&width=1148" alt="imagepng"></p>
<h2 id="SpringMVC关键组件浅析"><a href="#SpringMVC关键组件浅析" class="headerlink" title="SpringMVC关键组件浅析"></a>SpringMVC关键组件浅析</h2><p>SpringMVC的默认组件，SpringMVC 在前端控制器 DispatcherServlet加载时，就会进行初始化操作，在进行初始化时，就会加载SpringMVC默认指定的一些组件，这些默认组件配置在 DispatcherServlet.properties 文件中，该文 件存在与spring-webmvc-5.3.7.jar包下的org\springframework\web\servlet\DispatcherServlet.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br></pre></td></tr></table></figure>

<p>这些默认的组件是在DispatcherServlet中进行初始化加载的，在DispatcherServlet中存在集合存储着这些组件， SpringMVC的默认组件会在 DispatcherServlet 中进行维护，但是并没有存储在与SpringMVC的容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">    <span class="comment">//存储处理器映射器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    <span class="comment">//存储处理器适配器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    <span class="comment">//存储视图解析器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置组件代替默认组件，如果不想使用默认组件，可以将替代方案使用Spring Bean的方式进行配置，例如，在 spring-mvc.xml中配置RequestMappingHandlerMapping （只是有这个功能！！这个后面会用到！！！理解这个就行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>当我们在Spring容器中配置了HandlerMapping，则就不会在加载默认的HandlerMapping策略了，原理比较简单， DispatcherServlet 在进行HandlerMapping初始化时，先从SpringMVC容器中找是否存在HandlerMapping，如果存在直接取出容器中的HandlerMapping，在存储到 DispatcherServlet 中的handlerMappings集合中去。</p>
<h2 id="请求静态资源"><a href="#请求静态资源" class="headerlink" title="请求静态资源"></a>请求静态资源</h2><p>静态资源请求失效的原因，当DispatcherServlet的映射路径配置为 &#x2F; 的时候，那么就覆盖的Tomcat容器默认的缺省 Servlet，在Tomcat的config目录下有一个web.xml 是对所有的web项目的全局配置，其中有如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>url-pattern配置为 &#x2F; 的Servlet我们称其为缺省的Servlet，作用是当其他Servlet都匹配不成功时，就找缺省的Servlet ，静态资源由于没有匹配成功的Servlet，所以会找缺省的DefaultServlet，该DefaultServlet具备二次去匹配静态资 源的功能。但是我们配置DispatcherServlet后就将其覆盖掉了，而DispatcherServlet会将请求的静态资源的名称当 成Controller的映射路径去匹配，即静态资源访问不成功了！</p>
<h3 id="静态资源请求的三种解决方案："><a href="#静态资源请求的三种解决方案：" class="headerlink" title="静态资源请求的三种解决方案："></a>静态资源请求的三种解决方案：</h3><p>第一种方案，可以再次激活Tomcat的DefaultServlet，Servlet的url-pattern的匹配优先级是：精确匹配&gt;目录匹配&gt;扩展名匹配&gt;缺省匹配，所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种方式，在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapping是映射资源路径，location是对应资源所在的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三种方式，在spring-mvc.xml中去配置&lt; mvc:default-servlet-handler &gt;，该方式是注册了一个 DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>静态资源配置的第二第三种方式我们可以正常访问静态资源了，但是Controller又无法访问了，报错404，即找不到对应的资源<br>第二种方式是通过SpringMVC去解析mvc命名空间下的resources标签完成的静态资源解析，第三种方式式通过 SpringMVC去解析mvc命名空间下的default-servlet-handler标签完成的静态资源解析，根据前面所学习的自定义命名空间的解析的知识，可以发现不管是以上哪种方式，最终都会注册SimpleUrlHandlerMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//创建SimpleUrlHandlerMapping类型的BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">handlerMappingDef</span> <span class="operator">=</span></span><br><span class="line">        <span class="comment">//可以看到这里创建了SimpleUrlHandlerMapping，在这里和前面相呼应</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(SimpleUrlHandlerMapping.class);</span><br><span class="line">    <span class="comment">//注册SimpleUrlHandlerMapping的BeanDefinition</span></span><br><span class="line">    context.getRegistry().registerBeanDefinition(beanName, handlerMappingDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又结合组件浅析知识点，<strong>一旦SpringMVC容器中存在 HandlerMapping 类型的组件时，前端控制器 DispatcherServlet在进行初始化时，就会从容器中获得HandlerMapping(<strong>SimpleUrlHandlerMapping就是</strong>HandlerMapping)</strong> ，不在加载 dispatcherServlet.properties 中默认处理器映射器策略，那也就意味着RequestMappingHandlerMapping（这个是处理Controller请求的，SimpleUrlHandlerMapping不可以处理Controller请求）不会被加载到了。<br>所以我们手动将RequestMappingHandlerMapping也注册到SpringMVC容器中就可以了</p>
<h3 id="注解驱动mvc-annotation-driven标签"><a href="#注解驱动mvc-annotation-driven标签" class="headerlink" title="注解驱动mvc:annotation-driven标签"></a>注解驱动mvc:annotation-driven标签</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以简化成如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该标签内部会帮我们注册RequestMappingHandlerMapping、注册RequestMappingHandlerAdapter并注入Json消息转换器等--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683107460560-a4e020ee-d9d0-4210-9f54-ab12b12c87fb.png#averageHue=%23f4e6dc&clientId=u9f0bcf28-5dac-4&from=paste&height=591&id=u980232ab&originHeight=591&originWidth=1297&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=106910&status=done&style=shadow&taskId=u1adcf393-4336-472a-b6cf-42ca906754b&title=&width=1297" alt="imagepng"> <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683107521965-d7dac7b3-cb6a-41a3-bb4d-10717a9f1589.png#averageHue=%23c5dbdf&clientId=u9f0bcf28-5dac-4&from=paste&height=356&id=u434b6a69&originHeight=356&originWidth=1602&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114478&status=done&style=shadow&taskId=u449196c5-bbc9-4cea-9e40-e5547e82963&title=&width=1602" alt="imagepng"></p>
<h3 id="拦截器-Interceptor-简介"><a href="#拦截器-Interceptor-简介" class="headerlink" title="拦截器 Interceptor 简介"></a>拦截器 Interceptor 简介</h3><p>实现了HandlerInterceptor接口，且被Spring管理的Bean都是拦截器，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//为真说明可以往下个过滤器中传递，为假就在这个过滤器停止了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683107680057-fa04cd80-d734-4354-84c1-f1d0a0077fd6.png#averageHue=%23afd0df&clientId=u9f0bcf28-5dac-4&from=paste&height=515&id=u43b57fbe&originHeight=515&originWidth=1613&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=255948&status=done&style=shadow&taskId=u0812ffd9-44dc-44e5-80ef-50ca5ad017f&title=&width=1613" alt="imagepng"></p>
<h3 id="拦截器的执行顺序"><a href="#拦截器的执行顺序" class="headerlink" title="拦截器的执行顺序"></a>拦截器的执行顺序</h3><p>** 拦截器执行顺序取决于 interceptor 的配置顺序 **<br>比如我们先配置1，再配置2，再配置3： <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683107817746-26cbb283-9dad-46ea-9967-e9187c7b8285.png#averageHue=%23f6eeea&clientId=u9f0bcf28-5dac-4&from=paste&height=382&id=u373ce289&originHeight=382&originWidth=1634&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=121144&status=done&style=shadow&taskId=uaff70e6b-025c-4abf-a51c-ff528635904&title=&width=1634" alt="imagepng"> <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683107892637-944f4b9d-2a3b-4e59-96e2-96d757e23bce.png#averageHue=%23f9f3f0&clientId=u9f0bcf28-5dac-4&from=paste&height=477&id=u640c23f7&originHeight=477&originWidth=1650&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125701&status=done&style=shadow&taskId=u4520a9b9-a60f-4477-bf8d-39211ce285b&title=&width=1650" alt="imagepng"></p>
<h3 id="拦截器执行原理"><a href="#拦截器执行原理" class="headerlink" title="拦截器执行原理"></a>拦截器执行原理</h3><p>请求到来时先会使用组件<strong>HandlerMapping</strong>去匹配Controller的方法（Handler）和符合拦截路径的Interceptor，** Handler和多个Interceptor**被封装成一个HandlerExecutionChain的对象<br>HandlerExecutionChain 定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line">    <span class="comment">//映射的Controller的方法！！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="comment">//当前Handler匹配的拦截器集合！！</span></span><br><span class="line">    <span class="comment">//可能不是一个，所以是一个集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683104247465-7a368293-f886-4cb4-b08e-5cc97b57fdd3.png?x-oss-process=image/resize,w_1148,limit_0#averageHue=%23f3eded&from=url&id=MdzFW&originHeight=642&originWidth=1148&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=shadow&title="> 在DispatcherServlet的doDispatch方法中执行拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//根据请求信息获得HandlerExecutionChain</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandler(request);</span><br><span class="line">    <span class="comment">//获得处理器适配器</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的前置方法，前置方法如果返回false，则该流程结束,</span></span><br><span class="line">    <span class="comment">//这里是正向遍历！！！</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(request, response)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行handler，一般是HandlerMethod</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行后置方法    </span></span><br><span class="line">    <span class="comment">//这里是反向遍历！！！</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    <span class="comment">//执行最终方法</span></span><br><span class="line">    <span class="comment">//这里是反向遍历！！！</span></span><br><span class="line">    <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前端控制器原理剖析"><a href="#前端控制器原理剖析" class="headerlink" title="前端控制器原理剖析"></a>前端控制器原理剖析</h2><h3 id="前端控制器初始化"><a href="#前端控制器初始化" class="headerlink" title="前端控制器初始化"></a>前端控制器初始化</h3><p>前端控制器DispatcherServlet是SpringMVC的入口，也是SpringMVC的大脑，主流程的工作都是在此完成的，梳理一下DispatcherServlet 代码。DispatcherServlet 本质是个Servlet，当配置了 load-on-startup 时，会在服务器启动时就执行创建和执行初始化init方法，每次请求都会执行service方法<br>DispatcherServlet 的初始化主要做了两件事：<br>⚫ 获得了一个 SpringMVC 的 ApplicationContext容器；<br>⚫ 注册了 SpringMVC 的九大组件 <img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683114053224-c097d8f2-8a00-4644-b584-8b97e3e8ceef.png#averageHue=%23fdfbfb&clientId=u9f0bcf28-5dac-4&from=paste&height=677&id=uac901d4e&originHeight=677&originWidth=1316&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=119095&status=done&style=shadow&taskId=ued4e940a-a438-4d4e-8b2a-1e302b86f7f&title=&width=1316" alt="imagepng"> SpringMVC 的ApplicationContext容器创建时机，Servlet 规范的 init(ServletConfig config) 方法经过子类重写 ，最终会调用 FrameworkServlet 抽象类的initWebApplicationContext() 方法，该方法中最终获得 一个根 Spring容器（Spring产生的），一个子Spring容器（SpringMVC产生的）<br>HttpServletBean 的初始化方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameworkServlet的initServletBean方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.webApplicationContext = <span class="built_in">this</span>.initWebApplicationContext();<span class="comment">//初始化ApplicationContext，这个代码再下面有！</span></span><br><span class="line">    <span class="built_in">this</span>.initFrameworkServlet();<span class="comment">//模板设计模式，供子类覆盖实现，但是子类DispatcherServlet没做使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在initWebApplicationContext方法中体现的父子容器的逻辑关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化ApplicationContext是一个及其关键的代码</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获得根容器，其实就是通过ContextLoaderListener创建的ApplicationContext</span></span><br><span class="line">    <span class="comment">//如果配置了ContextLoaderListener则获得根容器，没配置获得的是null</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(<span class="built_in">this</span>.getServletContext());</span><br><span class="line">    <span class="comment">//定义SpringMVC产生的ApplicationContext子容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//==&gt;创建SpringMVC的子容器，创建同时将Spring的创建的rootContext传递了过去</span></span><br><span class="line">        <span class="comment">//这个方法往里面跟进！</span></span><br><span class="line">        wac = <span class="built_in">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将SpringMVC产生的ApplicationContext子容器存储到ServletContext域中</span></span><br><span class="line">    <span class="comment">//key名是：org.springframework.web.servlet.FrameworkServlet.CONTEXT.DispatcherServlet</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContextAttributeName();</span><br><span class="line">        <span class="built_in">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进创建子容器的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="comment">//实例化子容器ApplicationContext</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);</span><br><span class="line">    <span class="comment">//设置传递过来的ContextLoaderListener的rootContext为父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">//获得web.xml配置的classpath:spring-mvc.xml</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//为子容器设置配置加载路径</span></span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化子容器(就是加载spring-mvc.xml配置的Bean)</span></span><br><span class="line">    <span class="built_in">this</span>.configureAndRefreshWebApplicationContext(wac);</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子容器中的parent维护着父容器的引用<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683116654011-11e5ba73-33bc-4e04-af6b-1c8eb1712144.png#averageHue=%23fbf8f6&clientId=u9f0bcf28-5dac-4&from=paste&height=620&id=uaa757494&originHeight=620&originWidth=1283&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=365549&status=done&style=shadow&taskId=u1d7d2517-1360-4ec4-ac39-6b141f1fac5&title=&width=1283" alt="imagepng"> 父容器和子容器概念和关系：<br>⚫ 父容器：Spring 通过ContextLoaderListener为入口产生的applicationContext容器，内部主要维护的是applicationContext.xml（或相应配置类）配置的Bean信息；<br>⚫ 子容器：SpringMVC通过DispatcherServlet的init() 方法产生的applicationContext容器，内部主要维护的是spring-mvc.xml（或相应配置类）配置的Bean信息，且内部还通过parent属性维护这父容器的引用。<br>⚫ Bean的检索顺序：根据上面子父容器的概念，可以知道Controller存在与子容器中，而Controller中要注入Service时，会先从子容器本身去匹配，匹配不成功时在去父容器中去匹配，于是最终从父容器中匹配到的UserService，这样子父容器就可以进行联通了。但是父容器只能从自己容器中进行匹配，不能从子容器中进行匹配</p>
<p>注册 SpringMVC的九大组件，在初始化容器initWebApplicationContext方法中执行了onRefresh方法，进而执行了初始化策略initStrategies方法，注册了九个解析器组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DispatcherServlet初始化SpringMVC九大组件</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initMultipartResolver(context);<span class="comment">//1、初始化文件上传解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initLocaleResolver(context);<span class="comment">//2、初始化国际化解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initThemeResolver(context);<span class="comment">//3、初始化模板解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerMappings(context);<span class="comment">//4、初始化处理器映射器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerAdapters(context);<span class="comment">//5、初始化处理器适配器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerExceptionResolvers(context);<span class="comment">//6、初始化处理器异常解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initRequestToViewNameTranslator(context);<span class="comment">//7、初始化请求视图转换器</span></span><br><span class="line">    <span class="built_in">this</span>.initViewResolvers(context);<span class="comment">//8、初始化视图解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initFlashMapManager(context);<span class="comment">//9、初始化lashMapManager策略组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 this.initHandlerMappings(context) 为例，进一步看一下初始化处理器映射器的细节：</p>
<blockquote>
<p>HandlerMapping就是controller上面的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义List容器存储HandlerMapping</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"><span class="comment">//初始化HandlerMapping的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;<span class="comment">//初始化集合为null</span></span><br><span class="line">    <span class="comment">//detectAllHandlerMappings默认为true，代表是否从所有容器中(父子容器)检测HandlerMapping</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">//从Spring容器中去匹配HandlerMapping</span></span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">            context,</span><br><span class="line">            HandlerMapping.class, </span><br><span class="line">            <span class="literal">true</span>, </span><br><span class="line">            <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//如果从容器中获取的HandlerMapping不为null就加入到事先定义好的handlerMappings容器中</span></span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(matchingBeans.values());</span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果从容器中没有获得HandlerMapping，意味着handlerMappings集合是空的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加载默认的HandlerMapping，就是加载DispatcherServlet.properties文件中的键值对</span></span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="built_in">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683116872603-00504fd5-0abf-4d84-b197-19065ed9e225.png#averageHue=%23faf8f7&clientId=u9f0bcf28-5dac-4&from=paste&height=719&id=u04e6d73e&originHeight=719&originWidth=1659&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=368548&status=done&style=shadow&taskId=u849ae62b-09fa-4a7e-a731-debfc651f79&title=&width=1659" alt="imagepng"></p>
<h3 id="前端控制器执行主流程"><a href="#前端控制器执行主流程" class="headerlink" title="前端控制器执行主流程"></a>前端控制器执行主流程</h3><p>上面讲解了一下，当服务器启动时，DispatcherServlet 会执行初始化操作，接下来，每次访问都会执行service 方法，我们先宏观的看一下执行流程，在去研究源码和组件执行细节<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27086425/1683116990247-a75fcba5-4c1c-4629-85c7-dd37a9cb81fb.png#averageHue=%23f2efef&clientId=u9f0bcf28-5dac-4&from=paste&height=700&id=uaf12a2f4&originHeight=700&originWidth=1245&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=171771&status=done&style=shadow&taskId=u3513daaa-bdd0-4e85-9e01-d3731b34781&title=&width=1245" alt="imagepng"> FrameworkServlet 复写了service(HttpServletRequest request, HttpServletResponse response) 、 doGet(HttpServletRequest request, HttpServletResponse response)、doPost(HttpServletRequest request, HttpServletResponse response)等方法，这些方法都会调用processRequest方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.doService(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步调用了doService方法，该方法内部又调用了doDispatch方法，而SpringMVC 主流程最核心的方法就是 doDispatch 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doDispatch方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义处理器执行链对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义模型视图对象</span></span><br><span class="line">    <span class="comment">//匹配处理器映射器HandlerMapping，返回处理器执行链对象</span></span><br><span class="line">    <span class="comment">//注意这里，是一个执行链对象</span></span><br><span class="line">    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">    <span class="comment">//匹配处理器适配器HandlerAdapter，返回处理器适配器对象</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的前置方法preHandle</span></span><br><span class="line">    mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line">    <span class="comment">//HandlerAdapter处理器适配器执行控制器Handler，返回模型视图对象</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的后置方法postHandle</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    <span class="comment">//获取视图渲染视图</span></span><br><span class="line">    <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小白菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/12/Spring%E8%AF%A6%E8%A7%A3/">http://example.com/2023/05/12/Spring%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">是小白菜哦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/13/HTML5-CSS3-%E7%A7%BB%E5%8A%A8web/"><img class="prev-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML5+CSS3+移动web</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/05/SpringBoot2/"><img class="next-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小白菜</div><div class="author-info__description">头发多多</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xiaobaicai350"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Xiaobaicai350" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1499487526@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阳光斑斓 微风含香 爱与四季 皆是向往 <img height="230" lengh="230" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1.gif"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">Spring的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">工厂实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">静态工厂实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">实例工厂实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">FactoryBean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">spring的标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">默认标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">自定义标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Spring的Bean实例实例化的基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">总结流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">spring的后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-number">1.4.1.</span> <span class="toc-text">BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">1.4.2.</span> <span class="toc-text">BeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.</span> <span class="toc-text">Spring的Bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Bean实例属性填充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Aware%E6%8E%A5%E5%8F%A3%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Aware接口属性注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">Spring IoC容器生命周期过程总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">Spring整合其他框架的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.1.</span> <span class="toc-text">不需要自定义命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E6%95%B4%E5%90%88Spring"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">MyBatis整合Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis%E7%9A%84%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">1.7.1.1.1.</span> <span class="toc-text">Spring整合MyBatis的原理剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SqlSessionFactoryBean"><span class="toc-number">1.7.1.1.1.1.</span> <span class="toc-text">SqlSessionFactoryBean</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MapperScannerConfigurer"><span class="toc-number">1.7.1.1.1.2.</span> <span class="toc-text">MapperScannerConfigurer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ClassPathMapperScanner"><span class="toc-number">1.7.1.1.1.3.</span> <span class="toc-text">ClassPathMapperScanner</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ClassPathBeanDefinitionScanner"><span class="toc-number">1.7.1.1.1.4.</span> <span class="toc-text">ClassPathBeanDefinitionScanner</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MapperFactoryBean"><span class="toc-number">1.7.1.1.1.5.</span> <span class="toc-text">MapperFactoryBean</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.7.2.</span> <span class="toc-text">需要引入第三方框架命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A0%87%E7%AD%BE"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">自定义命名空间标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Spring%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">基于注解的Spring应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.1.</span> <span class="toc-text">bean标签属性的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Primary%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.2.</span> <span class="toc-text">@Primary注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">@Profile 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.4.</span> <span class="toc-text">Spring注解的解析原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">xml配置组件扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">使用配置类配置组件扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">两者对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">1.9.</span> <span class="toc-text">Spring注解方式整合第三方框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringAOP"><span class="toc-number">1.10.</span> <span class="toc-text">SpringAOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">基于JDK动态代理实现AOP的原始案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E7%9A%84AOP"><span class="toc-number">1.10.2.</span> <span class="toc-text">基于xml配置的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9Aaspect"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">第一种方式：aspect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.10.2.1.1.</span> <span class="toc-text">通知方法的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JoinPoint-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.2.1.1.1.</span> <span class="toc-text">JoinPoint 对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ProceedingJoinPoint%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.2.1.1.2.</span> <span class="toc-text">ProceedingJoinPoint对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Throwable%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.2.1.1.3.</span> <span class="toc-text">Throwable对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9Aadvice"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">第二种方式：advice</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MethodBeforeAdvice%E5%92%8CAfterReturningAdvice"><span class="toc-number">1.10.2.2.1.</span> <span class="toc-text">MethodBeforeAdvice和AfterReturningAdvice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MethodInterceptor"><span class="toc-number">1.10.2.2.2.</span> <span class="toc-text">MethodInterceptor</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">二者区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.10.2.3.1.</span> <span class="toc-text">1）配置语法不同：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%80%9A%E7%9F%A5%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E8%A6%81%E6%B1%82%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.10.2.3.2.</span> <span class="toc-text">2）通知类的定义要求不同：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84%E5%88%87%E9%9D%A2%E6%95%B0%E9%87%8F%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.10.2.3.3.</span> <span class="toc-text">3）可配置的切面数量不同：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.10.2.3.4.</span> <span class="toc-text">4）使用场景不同：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E6%96%B9%E5%BC%8FAOP%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">xml方式AOP原理剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cglib%E5%9F%BA%E4%BA%8E%E8%B6%85%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">Cglib基于超类的动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84AOP"><span class="toc-number">1.10.4.</span> <span class="toc-text">基于注解配置的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8FAOP%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">注解方式AOP原理剖析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E5%9F%BA%E4%BA%8EAOP%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">1.11.</span> <span class="toc-text">Spring的基于AOP的声明式事务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Exml%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">1.11.1.</span> <span class="toc-text">基于xml声明式事务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#name"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isolation"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">isolation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-only"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">read-only</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeout"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#propagation"><span class="toc-number">1.11.1.5.</span> <span class="toc-text">propagation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xml%E6%96%B9%E5%BC%8F%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90"><span class="toc-number">1.11.2.</span> <span class="toc-text">xml方式声明式事务控制的原理浅析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">1.11.3.</span> <span class="toc-text">基于注解声明式事务控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC"><span class="toc-number">2.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">三个核心组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E6%B5%85%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">SpringMVC关键组件浅析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.</span> <span class="toc-text">请求静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">静态资源请求的三种解决方案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">出现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8mvc-annotation-driven%E6%A0%87%E7%AD%BE"><span class="toc-number">2.3.3.</span> <span class="toc-text">注解驱动mvc:annotation-driven标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">SpringMVC的拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">拦截器 Interceptor 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">拦截器的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">拦截器执行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">前端控制器原理剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">前端控制器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%89%A7%E8%A1%8C%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">前端控制器执行主流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantLock/" title="深入理解ReentrantLock">深入理解ReentrantLock</a><time datetime="2023-08-20T12:31:06.000Z" title="发表于 2023-08-20 20:31:06">2023-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/19/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/" title="线程八锁">线程八锁</a><time datetime="2023-08-19T08:50:12.000Z" title="发表于 2023-08-19 16:50:12">2023-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/18/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a><time datetime="2023-08-18T07:12:06.000Z" title="发表于 2023-08-18 15:12:06">2023-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%85%A8%E9%9D%A2%E6%8F%AD%E7%A7%98/" title="Redis网络模型全面揭秘">Redis网络模型全面揭秘</a><time datetime="2023-08-08T03:29:32.000Z" title="发表于 2023-08-08 11:29:32">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/" title="彻底弄懂Redis的内存策略">彻底弄懂Redis的内存策略</a><time datetime="2023-08-08T03:05:02.000Z" title="发表于 2023-08-08 11:05:02">2023-08-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 小白菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到小白菜的blog~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>