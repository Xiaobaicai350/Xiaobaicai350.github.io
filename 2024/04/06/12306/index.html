<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>12306 | 是小白菜哦</title><meta name="author" content="小白菜"><meta name="copyright" content="小白菜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简历上描述**项目名称:**12306铁路购票系统**项目描述:**12306 铁路购票系统，帮助用户完成互联网在线购票，提高居民买票效率以及减少售票人员工作。项目基础架构采用 JDK17、SpringBoot3 和SpringCloud Alibaba 构建，完成会员注册、车票查询、车票下单以及支付等业务。底层采用缓存、消息队列以及分库分表等技术支持海量用户购票以及数据存储。**核心技术: **">
<meta property="og:type" content="article">
<meta property="og:title" content="12306">
<meta property="og:url" content="http://example.com/2024/04/06/12306/index.html">
<meta property="og:site_name" content="是小白菜哦">
<meta property="og:description" content="简历上描述**项目名称:**12306铁路购票系统**项目描述:**12306 铁路购票系统，帮助用户完成互联网在线购票，提高居民买票效率以及减少售票人员工作。项目基础架构采用 JDK17、SpringBoot3 和SpringCloud Alibaba 构建，完成会员注册、车票查询、车票下单以及支付等业务。底层采用缓存、消息队列以及分库分表等技术支持海量用户购票以及数据存储。**核心技术: **">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg">
<meta property="article:published_time" content="2024-04-06T10:03:01.000Z">
<meta property="article:modified_time" content="2024-04-06T10:05:12.317Z">
<meta property="article:author" content="小白菜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/132124.png"><link rel="canonical" href="http://example.com/2024/04/06/12306/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '12306',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-06 18:05:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/autoload.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">是小白菜哦</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">12306</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-06T10:03:01.000Z" title="发表于 2024-04-06 18:03:01">2024-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-06T10:05:12.317Z" title="更新于 2024-04-06 18:05:12">2024-04-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="12306"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简历上描述"><a href="#简历上描述" class="headerlink" title="简历上描述"></a>简历上描述</h1><p>**项目名称:**12306铁路购票系统<br>**项目描述:**12306 铁路购票系统，帮助用户完成互联网在线购票，提高居民买票效率以及减少售票人员工作。项目基础架构采用 JDK17、SpringBoot3 和SpringCloud Alibaba 构建，完成会员注册、车票查询、车票下单以及支付等业务。底层采用缓存、消息队列以及分库分表等技术支持海量用户购票以及数据存储。<br>**核心技术: **SpringBoot + SpringCloudAlibaba + RocketMQ + ShardingSphere + Redis + MySQL+ Sentine+ Hippo4j<br><strong>功能描述：</strong></p>
<ul>
<li>使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。</li>
<li>通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。</li>
<li>封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。</li>
<li>通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。</li>
<li>通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。</li>
<li>封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。</li>
<li>负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。</li>
<li>引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。</li>
<li>使用 BinLog 配合 RocketMQ 消息队列完成 MySQ数据库与 Redis 缓存之间的数据最终一致性。</li>
<li>通过 Redis Lua 脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。</li>
<li>通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。</li>
<li>创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。</li>
</ul>
<h1 id="使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。"><a href="#使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。" class="headerlink" title="使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。"></a>使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。</h1><h2 id="学习设计模式有什么用？"><a href="#学习设计模式有什么用？" class="headerlink" title="学习设计模式有什么用？"></a>学习设计模式有什么用？</h2><p>设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性<br>什么是责任链模式？<br>举个很经常用的例子，在springmvc中可以定义拦截器，而且可以定义多个，当一个用户发起请求的时候，顺利的话请求会经过所有拦截器（请求不满足拦截器自定义规则会被打回），最终到达业务代码逻辑，SpringMVC的拦截器设计就是使用了责任链设计模式</p>
<p>责任链模式中多个处理器形成的处理器链在进行处理请求时，有两种处理方式：<br>1请求会被所有的处理器都处理一遍，不存在中途终止的情况，比如MyBatis 拦截器，这种类型的链路重点在于对请求过程中的数据或者行为进行改变，比如MyBatis 中的分页语句就是经过拦截器进行加工之后实现的。<br>2二则是处理器链执行请求中，某一处理器执行时，如果不符合自制定规则的话，停止流程，并且剩下未执行处理器就不会被执行，比如 SpringMvc 拦截器，一个例子就是token拦截器，如果token失效就不能继续访问系统，拦截器会将请求打回。</p>
<h2 id="查询购票"><a href="#查询购票" class="headerlink" title="查询购票"></a>查询购票</h2><p>在实际购票业务场景中，用户发起一次购票请求后，购票接口在真正完成创建订单和扣减余票行为前，需要验证当前请求中的参数是否正常请求，或者说是否满足购票情况。<br>1购票请求用户传递的参数是否为空，比如：车次 ID、乘车人、出发站点、到达站点等。<br>2购票请求用户传递的参数是否正确，比如：车次 ID 是否存在、出发和到达站点是否存在等。<br>3需要购票的车次是否满足乘车人的数量，也就是列车对应座位的余量是否充足。<br>4乘客是否已购买当前车次，或者乘客是否已购买当天时间冲突的车次。</p>
<h2 id="购买车票"><a href="#购买车票" class="headerlink" title="购买车票"></a>购买车票</h2><p>只要是跟购买车票区间有交集或者是说有重叠的车站，余票都需要扣减<br>购买车票时候座位分配逻辑：<br>如果购票人数为两人，购买同一车厢，座位优先检索两人相邻座位并并排分配。<br>假设当前正在检索的车厢不满足两人并排，就执行搜索全部满足两人并排的车厢<br>如果搜索了所有车厢还是没有两人并排坐的位置，就执行同车箱不相邻座位。<br>如果所有车厢都是仅有一个座位，最后执行降级操作，进行不同车厢的分配。</p>
<h1 id="通过-RocketMQ-延时消息特性，完成用户购票-10-分钟后未支付情况下取消订单功能。"><a href="#通过-RocketMQ-延时消息特性，完成用户购票-10-分钟后未支付情况下取消订单功能。" class="headerlink" title="通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。"></a>通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。</h1><p>订单延时关闭功能技术选型&#x2F;为什么选择rocketmq来实现这个功能？</p>
<ol>
<li>定时任务&#x2F;xxl-job 他的原理是根据订单的创建时间扫描所有到期的订单，并对过期的执行关闭的操作。 但是这也导致了一个问题，他是每隔一段时间来进行扫描的，比如说一分钟，这就可以导致有1-59s的时间误差，也就是延迟的时间不够精确<br>而且这种实现方式在高并发场景下，可能导致大量的定时任务同时执行，造成系统负载过大<br>而且还存在分库分表问题：拿 12306 来说，订单表按照用户标识和订单号进行了分库分表，那这样的话，和上面说的根据订单创建时间去扫描一批订单进行关闭，自然就行不通。因为根据创建时间查询没有携带分片键，存在读扩散问题。</li>
<li>RabbitMQ（延迟插件） rabbitmq的架构导致了没有rocketmq和kafka做的可靠性那么好</li>
<li>Redis过期监听 可用性，可能会宕机，可能会丢数据，不存在mq的那种ack机制，专业的能力交给专业的人去做，就直接上mq就行</li>
<li>Redission</li>
<li>RocketMQ 重复消息（用幂等注解去做）<br>高并发的时候引入动态线程池hippo4j，消费不过来，说明是两种情况，一种是生产者生产的太快了，一种是消费者消费的太慢了，前者是不可控的。所以就后者而言，有两种解决方案，一种就是添加客户端的数量，去消费。另一种是提高单个客户端的消费速度，通过动态线程池去提高消费速度</li>
</ol>
<h1 id="封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。"><a href="#封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。" class="headerlink" title="封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。"></a>封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。</h1><p>缓存穿透问题：用户注册时，需要验证用户名是否已经存在，这通常需要去查询缓存和数据库，如果缓存没有就会去数据库查询，如果数据库也没有，说明这个用户名可用。<br>在高并发情况下，可能有大量新用户同时注册，这将导致缓存中没有这个新用户名，都去查询数据库，造成缓存穿透。<br>为了防止缓存穿透，可以有以下的处理方式：</p>
<ol>
<li>对不存在的key进行缓存，值设置为null，并且设置短暂的过期时间。这种办法的好处就是实现简单，缺点就是对用户体验不友好（因为缓存空对象就意味着这个用户名在这段过期时间中不可用了）。而且如果有大量并发请求查询不存在的用户名，仍然可能会导致缓存穿透。</li>
<li>使用布隆过滤器，将所有已注册的用户名存入布隆过滤器，判断时先判断是否在布隆过滤器中（不在的话一定不存在用户使用这个用户名），这样可以避免请求过多打到数据库。但是，布隆过滤器无法删除元素，所以这个业务无法使用到生产，我了解过一些布隆过滤器，底层是bit数组，利用几个hash函数进行运算，然后把标志位给标志成1，因为使用到了hash函数，所以有误判的可能和hash冲突的可能，这也是为什么布隆过滤器说存在但是数据库里可能不存在的原因，而且布隆过滤器对元素的删除不太支持，因为hash冲突存在，所以删除不会太方便。而且因为存储的是二进制数据，存储的是0&amp;1，所以保密性很好，并且我们可以自己设计误差率，误差率是根据二进制数据的大小和使用hash函数的个数决定的</li>
<li>使用redis的set集合来存储用户名，判断时检查是否在集合中。这个的缺点就是把用户数据全部存在了内存中，消耗了大量内存资源</li>
</ol>
<p>12306 如何解决注册穿透<br>如果没有用户名注销后可以重复使用的需求，布隆过滤器无疑是最好的解决方案，但是考虑到需求的多样化，设计的时候就要做好全方面的准备。<br>所以我们可以通过布隆过滤器+一层缓存来解决这个问题，也就是上面提到的2和3组合起来使用。<br>具体的流程是这样的：</p>
<p>1.用户名 “haohao” 成功注册后，将其添加至布隆过滤器。<br>2当其他用户查询”haohao”是否已被使用时，首先检查布隆过滤器是否包含该用户名。<br>3如果布隆过滤器中不存在该用户名，根据布隆过滤器的特点，可以确认该用户名一定没有被使用过，因此返回成功，证明该用户名可用。<br>4如果布隆过滤器中存在该用户名，进一步检查Redis Set结构中是否包含该用户名。如果存在，表示该用户名已被注销，同样可被再次使用。<br>5如果布隆过滤器中存在该用户名，但 Redis Set 结构中不存在，说明该用户名已被使用且尚未被注销，因此不可用。</p>
<p>但是使用这种方法也会有缺点，比如查询性能会降低，因为查询的时候会进行两次查询，第一次查询布隆过滤器，第二次查询set结构。另一个是会增加存储损耗，需要多存储一个set结构，不过为了需求这些也是必要的。</p>
<p>不过这个需求仍然会有一些问题：<br>如果用户频繁的注销用户名，导致set结构变得很庞大，导致bigkey问题<br>为了防止这种情况，可以采取以下措施：</p>
<ol>
<li>对异常行为进行限制：每次用户注销后，记录用户的证件号，并且限制证件号仅可以注销5次，超过五次就会被封号。</li>
<li>进行分片处理：把一个bigkey通过用户名进行hash运算，分散到1024个set中，可以有效解决这个问题。</li>
</ol>
<h1 id="通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。"><a href="#通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。" class="headerlink" title="通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。"></a>通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。</h1><p>在登录功能中，用户一栏明确标出可以使用用户名、邮箱或者手机号中的任意一个搭配密码进行登录，并且在用户表的分库分表中，我们是把用户名当成分片键进行分片的，随意，如果在查询用户信息的时候不带用户名，就会触发读扩散的问题。由于去查询用户信息的时候没带用户名，导致无法确定用户的信息在哪个分片上（分片指的是某个库的某个表上），只能对全部的相关数据库和表进行全表扫描（如果携带了分片键，可以直接找到对用的分片，直接只查询对应的分片就可以了），这就是读扩散。这种情况的话会导致用户的请求响应时间变长。<br>为了解决这个问题，我们引入了两张路由表：用户手机号表和用户邮箱表，他们存储的内容分别是手机号和用户名、邮箱和用户名。他们的分片键分别是手机号和邮箱，这样能方便我们找到分片。<br>思考一下，我们怎么区分这是手机号还是用户名还是邮箱，其实我们最终还是要得到用户名，所以可以先从手机号和邮箱中去查询，那么谁最好区分，肯定是邮箱了，他有@标识，所以我们可以通过一个判断标记看这个字符串里是否有@，就说明这个字符串是邮箱还是其他，如果不是邮箱，直接去手机号表中去查（因为这时候这个字符串只可能是手机号和用户名）如果是用户名的话，查不出来内容，就还用原来的字符串当成username就可以了，这样的话就不会造成读扩散了，之后得到了username，就可以去查询username主表进行登录了。<br>路由表很像一个中间层，通过这个中间层得到我们想要的东西，之后再去查询就可以了，不过引入路由表也有一定的坏处，比如会对查询性能造成影响，因为多加了一次访问数据库的请求。而且增加了维护成本，因为多引入了表，不过为了实现需求，做这些工作也是可以接受的。</p>
<h1 id="通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。"><a href="#通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。" class="headerlink" title="通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。"></a>通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。</h1><h1 id="封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。"><a href="#封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。" class="headerlink" title="封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。"></a>封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。</h1><p>我们为什么使用雪花算法不使用UUID，因为UUID一般都是无序的，这样的话会对数据库性能有影响<br>雪花算法生成后是一个64bit的数值，组成部分因为有时间戳，所以基本可以保持自增，可以提高索引效率。<br>雪花算法的组成部分<br>不使用：1bit，最高位是符号位，0 表示正，1 表示负，固定为 0。<br>时间戳：41bit，毫秒级的时间戳（41 位的长度可以使用 69 年）。<br>标识位：<br>5bit 数据中心 ID<br>5bit 工作机器 ID，<br>序列号：12bit 防止同一个机器同一毫秒生成重复，所以有这个。<br>这样的结构保证了他在索引结构下有高性能。<br>但是这样的雪花算法存在可能生成重复id。<br>比如有三个节点，他们部署在同一个k8s机器上，机器号相同，数据中心也相同，而且在同一时刻生成id，就有可能相同，因为是不同的节点，所以没法保证序列号一定不一致。<br>所以这是一种比较潜在的风险，如果节点少并发少这个雪花算法还可以进行使用，但是如果节点多并发多的话就可能会出现重复id，造成很严重的事故，所以我们自定义了分布式雪花算法。<br>主要是对标志位进行的分配，因为mybatis是通过mac和进程pid进行生成标志位的，但是这样做会有风险进行重复。<br>为了生成不重复的标志位，我们有两种方案，一种是进行预分配，也就是人工去申请标识位置，但是这样做的话会有坏处，比如数以万计的节点，都去申请吗。<br>第二种是进行动态分配，就是通过redis来分配标志位，比如都用一个redis来生成数据中心id和机器号id，这其实已经偏离了原来这个名字的意思了，只是做一个标志的意思，然后每个节点通过使用lua脚本去redis进行申请这两个，并且不会出现并发问题，具体逻辑是：<br>1.第一个服务节点在获取时，Redis 可能是没有 snowflake_work_id_key 这个 Hash 的，应该先判断 Hash 是否存在，不存在初始化 Hash，dataCenterId、workerId 初始化为 0。<br>2.在进行分配时，先分配 workerId。<br>3.判断 workerId 是否 !&#x3D; 31，条件成立对 workerId 自增，并返回；如果 workerId &#x3D; 31，自增 dataCenterId 并将 workerId 设置为 0。</p>
<h1 id="负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。"><a href="#负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。" class="headerlink" title="负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。"></a>负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>涉及一些客户安全的数据或者一些商业性的敏感数据，如身份证号、手机号等个人信息按照有关部门的规定，需要对数据加密<br>在实际的业务场景里需要把这些数据进行加密然后存储到数据库中，在使用的时候再进行解密处理。<br>这里我们使用的是ShardingSphere进行的加密存储，通过修改shardingsphere的配置文件，进行配置需要加密的字段，然后选择加密算法，他自带的有许多加密算法，我们使用的是里面的aes加密算法，然后把加密密钥进行填入进去就可以了，当我们需要把这些加密数据从数据库中查询出来的时候，shardingsphere会自定帮我们把加密数据转换成明文数据，形成一个加密敏感信息落库闭环。<br>他的实现原理其实就是对用户发起的sql进行拦截，然后对sql语句进行解析，再根据我们在配置文件中配置的加密规则以及密钥等等，找出需要加密的字段，用加密算法进行加密处理后，再去请求数据库。解密也是同样的道理。<br>这样通过屏蔽对数据的加密解密处理，使用户无感知在使用加密数据，就像和使用普通数据一样使用加密数据。<br>如何防止配置文件敏感信息泄漏？</p>
<ol>
<li>使用环境变量代替明文配置信息，而不是把明文写到配置文件中。</li>
<li>加密配置文件，可以使用对称加密或者非对称加密来加密配置文件，以保护敏感信息，在加密配置文件的时候，需要指定加密算法和密钥，以及解密时使用的密钥。</li>
<li>禁止将配置文件提交到代码仓库，可以添加gitignore</li>
<li>限制配置文件的权限，防止修改和访问，可以使用操作系统的权限控制功能，比如linux中的文件权限。</li>
</ol>
<h2 id="脱敏"><a href="#脱敏" class="headerlink" title="脱敏"></a>脱敏</h2><p>比如说我们在查看乘车人的时候，把一些数据返回给前端的时候要进行脱敏处理，这样可以保证信息泄漏的风险，并且可以保护用户的隐私，同时保证一定用户信息的可读性。<br>这里最简单的其实就是前端进行处理，但是有些人会绕过前端，直接获取数据，所以我们必须从后端接口进行处理。<br>我们这里的实现思路是：在返回数据的时候，通过对序列化器进行替换，也就是在实体类上加上一个JsonSerialize注解来指定这个字段用的序列化器，之后我们就可以进行无感知的替换了，这个序列化器可以根据我们的需求对这个字段的数据进行处理。<br>但是这样的化还有一个问题，万一我们不想要脱敏后的数据呢，我们想要脱敏前的数据，我们的解决办法是再创建一个DTO实体类，然后这个类的字段上不添加自定义的序列化器，之后再创建一个接口，专门用于返回不脱敏的数据，这样的话，我们就可以自己选取是得到脱敏后的数据还是脱敏前的数据了。</p>
<h1 id="引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。"><a href="#引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。" class="headerlink" title="引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。"></a>引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。</h1><p>这里之前的场景是，如果一个用户购买了多种类型的车座，比如同一订单购买了2个一等座和3个二等座，那么就要按照不同的座位逻辑进行选座（也就是对这个订单的一等座的2个人进行分配座位，之后在对二等座的3个人分配座位）这个流程是串行的，但是这个逻辑是可以并行的，如果这个是并行的话，可以极大程度上提高执行效率，提高系统的吞吐量。<br>所以我们后来引入了动态可监控线程池<a target="_blank" rel="noopener" href="https://github.com/opengoofy/hippo4j">Hippo4</a>，把这些工作变成异步多线程进行执行，但是还存在一些问题，也就是多线程问题，我们得到的结果是用arraylist存储的，这个集合类在多线程下会存在并发问题，所以我们采用了CopyOnWriteArrayList这个类来存储返回结果，这个类的原理是：再写操作的时候复制数组来保证线程安全，具体一点来说的话，在执行写操作的时候，他会先复制一下原来的数组，并且让写操作在新数组上进行修改，最后再将新数组替换老数组。如果写的时候有一个读线程过来了，读取的还是老数组。换句话说，就是读操作和写操作发生在不同的数组上，所以不会出现线程安全问题，所以他是线程安全集合。<br>又因为是异步执行嘛，所以有可能我们购票流程都结束了，还没执行完那个分配座位的逻辑，所以，我们需要拿到线程池执行的结果后再继续执行后续的提交订单逻辑，这里我们使用的是Future类，它有一个get方法，是一个阻塞方法，之后等到线程池里面所有的任务结束之后，他才会停止阻塞，我们再进一步执行下面的提交订单逻辑就可以了。<br>这样做的话还有一个问题，就是如果用户下单的话如果仅选择一种座位的话，还通过线程池进行执行的话会额外增加性能消耗，因为一种座位的话用单线程就可以了，所以我们可以提前一步进行判断下单的是一种座位还是多种座位，然后再判断是否采用线程池进行优化就可以了。</p>
<p>Hippo4j主要做的功能<br>动态线程池：核心线程数、最大线程数、阻塞队列容量、拒绝策略<br>监控：查看线程池运行时的数据<br>运行报警：线程池线程活跃度、任务执行时间</p>
<h1 id="使用-BinLog-配合-RocketMQ-消息队列完成-MySQ数据库与-Redis-缓存之间的数据最终一致性。"><a href="#使用-BinLog-配合-RocketMQ-消息队列完成-MySQ数据库与-Redis-缓存之间的数据最终一致性。" class="headerlink" title="使用 BinLog 配合 RocketMQ 消息队列完成 MySQ数据库与 Redis 缓存之间的数据最终一致性。"></a>使用 BinLog 配合 RocketMQ 消息队列完成 MySQ数据库与 Redis 缓存之间的数据最终一致性。</h1><p>先写缓存再写数据库：<br>这种情况无法保证数据的最终一致性，因为在多请求多并发的场景下，执行的结果和预期的不符<br>比如写请求A去redis更新缓存为16，然后B请求来了，先把Redis改成15，再去更新Mysql，更新数据库余票为15，之后A又去更新数据库更新余票为16，这导致数据库本该是15的时候又变成了16。<br>先写数据库再写缓存：<br>跟上面的这种情况一样，都会导致无法最终一致。<br>先删除缓存再写数据库：<br>这种情况也不能保证数据的最终一致性，比如有两个请求，一个写请求一个读请求。首先写请求去删除余票为16的缓存，然后读请求去redis中读取，发现为空，然后去mysql读取发现余票为16，之后写请求更新车站余票更新为15，然后读请求回写缓存余票为16，仍然没有保证最终一致性。</p>
<p>下面的是能保证最终一致性的方案：<br>延迟双删：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/27086425/1712397642265-67473ae8-582b-4ac4-bcf5-1b9080b87392.png#averageHue=%23fbfaf8&clientId=u710a71bf-ace1-4&from=paste&height=533&id=u9a1c3906&originHeight=533&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21176&status=done&style=none&taskId=u34779312-e4fd-4461-ab4c-626435e9829&title=&width=747" alt="image.png"><br>其实比上面那个就多了最后一步的删除，但是我们无法保证删除车站余票（也就是最后一步操作）在回写缓存之前，那我们就需要吧这个第二次的删除操作进行延迟，比如说睡眠500ms再删除，这个操作我们可以用消息队列来实现，所以上图就可以变成以下<br><img src="https://cdn.nlark.com/yuque/0/2024/png/27086425/1712397649964-a851a1fc-9c17-4afd-82b5-9bad03954f34.png#averageHue=%23fbfaf8&clientId=u710a71bf-ace1-4&from=paste&height=533&id=u7010e5f3&originHeight=533&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21176&status=done&style=none&taskId=u310d36da-215f-4414-a2bf-001bf0bb2ae&title=&width=747" alt="image.png"></p>
<p>先写数据库，再删除缓存：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/27086425/1712397660008-70c23635-7c9a-48c0-808a-6db36e532818.png#averageHue=%23faf9f7&clientId=u710a71bf-ace1-4&from=paste&height=533&id=ud82fca61&originHeight=533&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24340&status=done&style=none&taskId=u0c8e49c8-db23-4d37-bc4b-acdd8fdda42&title=&width=747" alt="image.png"></p>
<p>这种模型缓存与数据库不一致会存在一个很小周期，不过对于绝大多数的情况来说，是可以容忍的。除去一些电商库存、列车余票等对数据比较敏感的情况，比较适合绝大多数业务场景。<br>先写数据库，再通过Binlog异步更新缓存：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/27086425/1712397666258-69a3bd3a-2a46-453c-aeaf-f4464b58466c.png#averageHue=%23fbf8f7&clientId=u710a71bf-ace1-4&from=paste&height=447&id=ub19a76ac&originHeight=447&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21538&status=done&style=none&taskId=u2c256443-dd52-439c-8711-956476ceee1&title=&width=747" alt="image.png"></p>
<p>如果是扣减库存的方案，比如说你将列车余票扣减为 16，但是同时又有一个请求将列车余票扣减为 15，这个时候，扣减为 15 的这个请求先到消息队列执行，将缓存更新为余票 15，但是随之而来的是第一个请求余票为 16，会将缓存余票为 15 给覆盖掉。<br>类似于这种逻辑，会存在一些数据一致性的问题，需要我们通过其它技术手段完善，比如数据库添加版本号，或者根据最后修改时间等技术规避这些问题。</p>
<h1 id="通过-Redis-Lua-脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。"><a href="#通过-Redis-Lua-脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。" class="headerlink" title="通过 Redis Lua 脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。"></a>通过 Redis Lua 脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。</h1><p>之前我们的购票流程是：<br>首先通过责任链进行参数校验，比如说传入的参数是否合法，是否还有余票之类的。之后再去获取分布式锁，进行座位分配和选座，再去调用订单服务，之后返回订单号，再扣减票数，再释放锁。这个版本存在一些问题，比如说：SpringBoot Tomcat 容器默认情况下，同一时间最多能处理 200 个请求。如果要应对上千万的 TPS 明显是不可能的。大量请求会因为分布式锁的申请而发生阻塞，这会导致后续的请求长时间被阻塞，使系统陷入假死状态，此外随着请求的积累，还会存在内存溢出的风险。更糟糕的是，如果tomcat线程池全部被分布式锁占用（因为锁的是列车的id）查询请求也将无法得到响应。<br>所以我们必须要进行限流操作，12306的限流算法类似于令牌桶，但是令牌桶会以固定的速率生成令牌，但是我们这个不是这样的，是将没有出现的座位当成一个个令牌放到一个容器中，这个容器可以称作是令牌容器。如果用户来购票，根据所选择的乘车人数量以及座位类型去令牌容器中获取，如果获取成功则证明余票充足，可以进入之后的座位分配和选座的扣减 下订单环节，如果是获取失败的话会直接进行返回。加入令牌容器之后，只有少量拿到令牌的用户请求可以获取分布式锁<br>但是在这之前还有一个问题，也就是我们之前使用固定分布式锁是不公平的（因为默认的就是不公平的），虽然我们之前使用了令牌容器来限流，但是仍然可能购票失败，比如两个用户选择同一个座位然后提交，这时候后提交的会购票失败，然后再去获取令牌，所以我们要使用公平锁，因为公平锁的特点就是公平吗，也就是说他维护了一个等待队列，然后记录等待锁的线程，并按照顺序分配锁，先到先得，虽然他在高并发下性能可能会相比于非公平锁比较低，但是我们业务需要所以就使用了公平锁。具体的改造就是改一个方法就行了、或者改一个参数就是公平锁了，默认不公平。公平锁的缺点就是他维护一个等待队列嘛。肯定会增加锁的管理开销，而且涉及到线程的状态切换。我之前有在想过一个问题，为什么大家如此偏爱非公平锁，他肯定有他的优点，通过我的研究，非公平锁的性能比公平锁高很多，原因就是线程的状态进行相互切换，非公平锁会优先选择处于醒着的状态的线程，因为唤醒阻塞的线程需要耗费很多资源。但是这样对于某种业务会造成线程饥饿，可以用调整优先级或者超时机制来解决线程饥饿的问题。再一个，因为都是集群化部署，这里我们做的优化是先去竞争单个服务的内部锁（本地锁），竞争成功后再去竞争分布式锁，这样做的好处是可以减轻redis分布式锁的压力。具体实现是用一个currenthashmap进行存储ReentrantLock，key为根据列车id构建的，value为那个ReentrantLock类，但是这样的话又出现了一些问题，因为列车id随着天数增加一直在改变，所以这个map里面的数据一直在增加，没有清除，因为没有任何的过期策略和内存溢出策略，所以会内存溢出。所以我们采用了caffeine创建本地的安全锁容器，指定这个key在一天后会过期。这样就解决了这个问题。但是加本地锁还有可能存在一些问题，也就是说全局的购票顺序会变成局部顺序。我们必须要在下面的问题做些折中：是要通过分布式锁来确保完全的有序性，还是通过本地锁+分布式锁的组合来牺牲一部分有序性提升性能呢？<br>得出的结论是需要根据具体的业务需求和系统规模来选择合适的锁策略，在购票人数较多且缓存压力较大的情况下，本地锁和分布式锁的组合可以在一定程度上平衡性能和购票顺序，如果是业务规定一定要按照顺序，那就直接只上分布式锁就可以了。<br>还有一个可以优化的点：<br>也就是优化锁的粒度，之前是锁定的是列车的id值，现在我们可以优化到锁定到具体的列车座位类型，但是有一个问题，购票过程中可以为多个乘车人选择不同的座位，这种情况我们可以加多把锁，锁全部获取到才可以执行购票流程，就比如说张三购买了三个座，分别是商务座、一等座、二等座，按之前的流程来看，张三需要获取六把锁（本地三把、分布式三把）这样可能会出现一些死锁问题，但是我们只要破坏形成死锁的四个条件就好了，比如可以规定获取锁的顺序只能是这样，或者如果没有得到锁立即释放就可以了。在这种情况下，理想状态下会提升300%的性能，但是由于座位的问题，多申请了锁，会带来一些性能上的开销。</p>
<h1 id="通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。"><a href="#通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。" class="headerlink" title="通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。"></a>通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。</h1><p>这里我们参考了阿里的订单号设计，采用了基因法，基因法其实就是我们把用户id的后六位数据给冗余到了订单号里，这样的话，我们就可以根据用户id后六位进行分库分表，因为订单号和用户id里面都有这六位，所以我们分片键定为用户id和订单号，只要查询中携带这两个字段中的一个，我们就可以通过这六位找到分片表的位置，而不至于导致读扩散问题导致全表全库扫描。<br>这里我们使用了自定义的分片算法：<br>如果传入用户id或者订单号，我们就直接截取后六位进行分片映射。</p>
<h1 id="创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。"><a href="#创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。" class="headerlink" title="创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。"></a>创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。</h1><p>对于订单管理，我们一共有三张表：<br>一张是订单的主表，记录12306用户购买的车票订单，但是这个订单中会有多个乘车人，所以还有订单明细表。<br>第二张表是订单明细表：一个订单有多个乘车人，多个乘车人对应多个订单明细，和第一张表是一对多的关系，跟第一张表的分库分表规则是根据订单号&#x2F;用户id进行的复合分片，采用复合分片的原因是因为业务的需求，一个分片键只能支持单个查询场景，用户 ID 可以支持查询当前用户下所有订单，订单 ID 支持查询明细。这两张表互为绑定表的关系。<br>第三张表是订单明细乘车人表：<br>这张表是关联表，通过证件号关联订单，因为订单表和订单明细表通过用户ID和订单号进行复合分片，所以导致乘车人无法查看本人车票，为什么不能看呢，因为没有分片字段参与sql，会执行全路由，性能较差，所以为了满足这个需求，创建了这个表，方便乘车人可以进行查看自己的车票<br>那么为什么通过乘车人的证件号进行关联呢？因为用户在添加乘车人进行购票的时候，有可能乘车人是没有注册账号的，但是他肯定有证件号，所以就用证件号来关联自己本人的车票</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小白菜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/06/12306/">http://example.com/2024/04/06/12306/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">是小白菜哦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/21/JUC%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"><img class="next-cover" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC中的原子类</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小白菜</div><div class="author-info__description">头发多多</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xiaobaicai350"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Xiaobaicai350" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1499487526@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阳光斑斓 微风含香 爱与四季 皆是向往 <img height="230" lengh="230" src="https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/1.gif"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8E%86%E4%B8%8A%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">简历上描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%9E%84%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%87%86%E7%A1%AE%E6%80%A7%E6%A3%80%E9%AA%8C%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%B4%AD%E7%A5%A8%E3%80%81%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8%E4%B8%8B%E5%8D%95%E4%BB%A5%E5%8F%8A%E6%94%AF%E4%BB%98%E7%BB%93%E6%9E%9C%E5%9B%9E%E8%B0%83%E7%AD%89%E4%B8%9A%E5%8A%A1%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">学习设计模式有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%B4%AD%E7%A5%A8"><span class="toc-number">2.2.</span> <span class="toc-text">查询购票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8"><span class="toc-number">2.3.</span> <span class="toc-text">购买车票</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-RocketMQ-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AE%8C%E6%88%90%E7%94%A8%E6%88%B7%E8%B4%AD%E7%A5%A8-10-%E5%88%86%E9%92%9F%E5%90%8E%E6%9C%AA%E6%94%AF%E4%BB%98%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%96%E6%B6%88%E8%AE%A2%E5%8D%95%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6%E5%BA%93%E9%81%BF%E5%85%8D%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7%E6%97%B6%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%8C%E5%87%8F%E8%BD%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E5%8E%8B%E5%8A%9B%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%95%E5%85%A5%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%97%B6%E4%B8%8D%E5%B8%A6%E5%88%86%E7%89%87%E9%94%AE%E5%B0%86%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%9A%84%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98%E3%80%82%E5%AE%8C%E6%88%90%E9%80%9A%E8%BF%87%E4%B8%8D%E5%90%8C%E7%9A%84%E7%99%BB%E9%99%86%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">通过引入路由表解决查询用户信息时不带分片键将会触发的读扩散问题。完成通过不同的登陆方式进行登录的功能。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%80%E5%8F%91%E9%98%B2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82"><span class="toc-number">6.</span> <span class="toc-text">通过开发防重复提交注解，实现了接口幂等和消息队列消费幂等，实现了数据一致性。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%8C%E8%A7%A3%E5%86%B3Mybatis-Plus%E7%9A%84%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%9C%A8%E9%9B%86%E7%BE%A4%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%94%9F%E6%88%90%E9%87%8D%E5%A4%8Did%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">封装分布式雪花算法组件库，解决Mybatis-Plus的雪花算法在集群条件下可能会生成重复id的问题。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%9F%E8%B4%A3%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E6%96%BD%E4%BA%86%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%84%B1%E6%95%8F%E6%9C%BA%E5%88%B6%EF%BC%8C%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">负责设计和实施了敏感数据加密与脱敏机制，确保用户的个人信息安全。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86"><span class="toc-number">8.1.</span> <span class="toc-text">加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%B1%E6%95%8F"><span class="toc-number">8.2.</span> <span class="toc-text">脱敏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%85%A5Hippo4j%E5%8A%A8%E6%80%81%E5%8F%AF%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%B4%AD%E4%B9%B0%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%A6%E5%BA%A7%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%9E%81%E5%A4%A7%E7%A8%8B%E5%BA%A6%E4%B8%8A%E8%8A%82%E7%9C%81%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%8C%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F%E3%80%82"><span class="toc-number">9.</span> <span class="toc-text">引入Hippo4j动态可监控线程池，优化一个用户购买多种类型的车座功能，极大程度上节省执行效率，提升系统吞吐量。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-BinLog-%E9%85%8D%E5%90%88-RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%8C%E6%88%90-MySQ%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E-Redis-%E7%BC%93%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82"><span class="toc-number">10.</span> <span class="toc-text">使用 BinLog 配合 RocketMQ 消息队列完成 MySQ数据库与 Redis 缓存之间的数据最终一致性。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Redis-Lua-%E8%84%9A%E6%9C%AC%E5%8E%9F%E5%AD%90%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AE%8C%E6%88%90%E7%94%A8%E6%88%B7%E8%B4%AD%E7%A5%A8%E4%BB%A4%E7%89%8C%E5%88%86%E9%85%8D%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BB%A4%E7%89%8C%E9%99%90%E6%B5%81%E4%BB%A5%E5%BA%94%E5%AF%B9%E6%B5%B7%E9%87%8F%E7%94%A8%E6%88%B7%E8%B4%AD%E7%A5%A8%E8%AF%B7%E6%B1%82%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">通过 Redis Lua 脚本原子特性，完成用户购票令牌分配，通过令牌限流以应对海量用户购票请求。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%92%8C%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A4%8D%E5%90%88%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95%E5%AE%8C%E6%88%90%E8%AE%A2%E5%8D%95%E6%95%B0%E6%8D%AE%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%8C%E6%94%AF%E6%8C%81%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%92%8C%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BB%B4%E5%BA%A6%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86%E4%B8%8E%E4%B9%98%E8%BD%A6%E4%BA%BA%E7%9A%84%E5%85%B3%E8%81%94%E8%A1%A8%EF%BC%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%84%E5%88%99%E5%90%8C%E8%AE%A2%E5%8D%95%EF%BC%8C%E5%AE%8C%E6%88%90%E4%B9%98%E8%BD%A6%E4%BA%BA%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E6%9F%A5%E8%AF%A2%E6%9C%AC%E4%BA%BA%E8%BD%A6%E7%A5%A8%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-number">13.</span> <span class="toc-text">创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/06/12306/" title="12306">12306</a><time datetime="2024-04-06T10:03:01.000Z" title="发表于 2024-04-06 18:03:01">2024-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/21/JUC%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/" title="JUC中的原子类">JUC中的原子类</a><time datetime="2023-08-21T13:30:52.000Z" title="发表于 2023-08-21 21:30:52">2023-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantLock/" title="深入理解ReentrantLock">深入理解ReentrantLock</a><time datetime="2023-08-20T12:31:06.000Z" title="发表于 2023-08-20 20:31:06">2023-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/19/%E7%BA%BF%E7%A8%8B%E5%85%AB%E9%94%81/" title="线程八锁">线程八锁</a><time datetime="2023-08-19T08:50:12.000Z" title="发表于 2023-08-19 16:50:12">2023-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/18/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/" title="Java集合详解">Java集合详解</a><time datetime="2023-08-18T07:12:06.000Z" title="发表于 2023-08-18 15:12:06">2023-08-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/Xiaobaicai350/picBed/master/xiaobaicai/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220806101221.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 小白菜</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到小白菜的blog~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159611061656" m="1"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>