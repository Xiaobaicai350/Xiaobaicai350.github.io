<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/04/MySQL/" class="article-date">
  <time class="dt-published" datetime="2022-08-04T13:28:13.572Z" itemprop="datePublished">2022-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 你是猪猪<br>date: 2022-08-04 21:25:04<br>tags: 嘿嘿</p>
<hr>
<h1 id="sql、DB、DBMS之间的关系"><a href="#sql、DB、DBMS之间的关系" class="headerlink" title="sql、DB、DBMS之间的关系"></a>sql、DB、DBMS之间的关系</h1><table>
<thead>
<tr>
<th>DB:</th>
<th>DBMS:</th>
<th>SQL:</th>
</tr>
</thead>
<tbody><tr>
<td>DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）</td>
<td>DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer…）</td>
<td>结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。<br/>	SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。<br/>	SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。）</td>
</tr>
</tbody></table>
<p>DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。<br>DBMS -(执行)-&gt; SQL -(操作)-&gt; DB</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><strong>表：table</strong></p>
<p>表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</p>
<p>一个表包括行和列：<br>    行：被称为数据&#x2F;记录(data)<br>    列：被称为字段(column)</p>
<pre><code>学号(int)	   姓名(varchar)	  年龄(int)
------------------------------------
110			张三				20
120			李四				21
</code></pre>
<p>每一个字段应该包括哪些属性？<br>字段名、数据类型、相关的约束。</p>
<h1 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h1><p>DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。<br>DML（数据操作语言）：insert delete update，对<strong>表当中的数据</strong>进行增删改。<br>DDL（数据定义语言）：create drop alter，对<strong>表结构</strong>的增删改。<br>TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)<br>DCL（数据控制语言）: grant授权、revoke撤销权限等。</p>
<h1 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h1><pre><code>第一步：登录mysql数据库管理系统
    dos命令窗口：
        mysql -uroot -p333
第二步：查看有哪些数据库
    show databases; (这个不是SQL语句，属于MySQL的命令。)
第三步：创建属于我们自己的数据库
    create database bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
第四步：使用bjpowernode数据
    use bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
第五步：查看当前使用的数据库中有哪些表？
    show tables; (这个不是SQL语句，属于MySQL的命令。)
第六步：初始化数据（导入外部数据）
    mysql&gt; source D:\course\05-MySQL\resources\bjpowernode.sql（这个是外部数据的地址）
</code></pre>
<h1 id="sql脚本"><a href="#sql脚本" class="headerlink" title="sql脚本"></a>sql脚本</h1><p>bjpowernode.sql，这个文件以sql结尾，这样的文件被称为“sql脚本”。什么是sql脚本呢？</p>
<p>​	当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。<br>​	注意：直接使用source命令可以执行sql脚本。</p>
<p><strong>格式</strong></p>
<p><strong>mysql&gt;source (sql脚本的绝对路径)</strong></p>
<p>​	sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。</p>
<h1 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h1><p>drop database 数据库名;</p>
<h1 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h1><p>desc 表名;</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p> select database(); 查看当前使用的是哪个数据库</p>
<p>select version(); 查看mysql的版本号。</p>
<p>\c   命令，结束一条语句。</p>
<p>exit 命令，退出mysql。</p>
<h1 id="简单的查询语句（DQL）"><a href="#简单的查询语句（DQL）" class="headerlink" title="简单的查询语句（DQL）"></a>简单的查询语句（DQL）</h1><p>语法格式：<br>    select 字段名1,字段名2,字段名3,…. from 表名;</p>
<p>提示：<br>    1、任何一条sql语句以“;”结尾。<br>    2、sql语句不区分大小写。</p>
<p><strong>查询员工的年薪？</strong>（字段可以参与数学运算。）<br>select ename,sal * 12 from emp;</p>
<p> <strong>给查询结果的列 重命名？</strong><br>    select ename,sal * 12 as yearsal from emp;<br><strong>别名中有中文，但是需要单引号括起来，（实测不用单引号仍然可以使用）</strong><br>    select ename,sal * 12 as 年薪 from emp; &#x2F;&#x2F; 错误<br>    select ename,sal * 12 as ‘年薪’ from emp;<br>    注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。	<br><strong>as关键字可以省略</strong>（可以 加一个空格）<br>    mysql&gt; select empno,ename,sal * 12 yearsal from emp;</p>
<p><strong>查询所有字段？</strong><br>    select * from emp; &#x2F;&#x2F; 实际开发中不建议使用*，效率较低。</p>
<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><p>​	语法格式：<br>​		select<br>​			字段,字段…<br>​		from<br>​			表名<br>​		where<br>​			条件;</p>
<p>执行顺序：先from，然后where，最后select</p>
<h2 id="等于-x3D"><a href="#等于-x3D" class="headerlink" title="等于&#x3D;"></a>等于&#x3D;</h2><p>查询工资等于5000的员工姓名？<br>        select ename from emp where sal &#x3D; 5000;</p>
<p>查询SMITH的工资？<br>        select sal from emp where ename &#x3D; ‘SMITH’; &#x2F;&#x2F; 字符串使用单引号括起来。</p>
<p>找出工资高于3000的员工？<br>        select ename,sal from emp where sal &gt; 3000;</p>
<h2 id="不等于！-lt-gt"><a href="#不等于！-lt-gt" class="headerlink" title="不等于！&lt;&gt;"></a>不等于！&lt;&gt;</h2><p>找出工资不等于3000的？<br>        select ename,sal from emp where sal &lt;&gt; 3000;<br>        select ename,sal from emp where sal !&#x3D; 3000;</p>
<h2 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h2><p>找出工资在1100和3000之间的员工，包括1100和3000？<br>        select ename,sal from emp where sal &gt;&#x3D; 1100 and sal &lt;&#x3D; 3000;<br>        select ename,sal from emp where sal between 1100 and 3000; &#x2F;&#x2F; between…and…是闭区间 [1100 ~ 3000]</p>
<p>​		select ename,sal from emp where sal between 3000 and 1100; &#x2F;&#x2F; 查询不到任何数据</p>
<p><em>between and在使用的时候必须左小右大。</em></p>
<p>between and除了可以使用在数字方面之外，还可以使用在字符串方面。<br>        select ename from emp where ename between ‘A’ and ‘C’;</p>
<h2 id="为null"><a href="#为null" class="headerlink" title="为null"></a>为null</h2><p><strong>找出哪些人津贴为NULL？</strong><br>            在数据库当中NULL不是一个值，代表什么也没有，为空。<br>            空不是一个值，不能用等号衡量。<br>            必须使用 is null或者is not null</p>
<p>select ename,sal,comm from emp where comm is null;</p>
<h2 id="不是is-not"><a href="#不是is-not" class="headerlink" title="不是is not"></a>不是is not</h2><p>找出哪些人津贴不为NULL？<br>            select ename,sal,comm from emp where comm is not null;</p>
<p>找出哪些人没有津贴？<br>            select ename,sal,comm from emp where comm is null or comm &#x3D; 0;</p>
<h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>找出工作岗位是MANAGER和SALESMAN的员工？<br>            select ename,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’;</p>
<p>and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。<br>            select ename,sal,deptno from emp where sal &gt; 1000 and deptno &#x3D; 20 or deptno &#x3D; 30; &#x2F;&#x2F; 错误的<br>            select ename,sal,deptno from emp where sal &gt; 1000 and (deptno &#x3D; 20 or deptno &#x3D; 30); &#x2F;&#x2F; 正确的。<br>            注意：当运算符的优先级不确定的时候加小括号。</p>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>in等同于or：找出工作岗位是MANAGER和SALESMAN的员工？<br>            select ename,job from emp where job &#x3D; ‘SALESMAN’ or job &#x3D; ‘MANAGER’;<br>            select ename,job from emp where job in(‘SALESMAN’, ‘MANAGER’)；</p>
<p>​			select ename,job from emp where sal in(800, 5000); &#x2F;&#x2F; in后面的值不是区间，是具体的值。</p>
<h2 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h2><p>not in: 不在这几个值当中。<br>            select ename,job from emp where sal not in(800, 5000);</p>
<h2 id="模糊查询like"><a href="#模糊查询like" class="headerlink" title="模糊查询like"></a>模糊查询like</h2><p>​			找出名字当中含有O的？<br>​				（在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是_）<br>​				%代表任意多个字符，_代表任意1个字符。<br>​				select ename from emp where ename like ‘%O%’;</p>
<p>找出名字中第二个字母是A的？<br>                select ename from emp where ename like ‘_A%’;</p>
<p>找出名字中有下划线的？</p>
<p>select name from t_user where name like ‘%_%’;（这样是错误的）</p>
<p>需要转义字符</p>
<p>select name from t_user where name like ‘%\_%’;</p>
<p>找出名字中最后一个字母是T的？<br>                select ename from emp where ename like ‘%T’;</p>
<h1 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h1><p>按照工资升序，找出员工名和薪资？<br>    select<br>        ename,sal<br>    from<br>        emp<br>    order by<br>        sal;</p>
<p>注意：默认是升序。怎么指定升序或者降序呢？asc表示升序，desc表示降序。<br>    select ename , sal from emp order by sal; &#x2F;&#x2F; 升序<br>    select ename , sal from emp order by sal asc; &#x2F;&#x2F; 升序<br>    select ename , sal from emp order by sal desc; &#x2F;&#x2F; 降序。</p>
<p>按照工资的降序排列，当工资相同的时候再按照名字的升序排列。<br>    select ename,sal from emp order by sal desc;<br>    select ename,sal from emp order by sal desc , ename asc;<br>    注意：<strong>越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段</strong>。</p>
<p>找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。<br>    select<br>        ename,job,sal<br>    from<br>        emp<br>    where<br>        job &#x3D; ‘SALESMAN’<br>    order by<br>        sal desc;</p>
<h1 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h1><p>什么是单行处理函数？<br>        输入一行，输出一行。</p>
<p>计算每个员工的年薪？<br>        select ename,(sal+comm)<em>12 as yearsal from emp;<br>        重点：*<em>所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。</em></em></p>
<h2 id="now"><a href="#now" class="headerlink" title="now"></a>now</h2><p>可以获取系统的当前时间</p>
<h2 id="ifnull"><a href="#ifnull" class="headerlink" title="ifnull"></a>ifnull</h2><p>​		使用ifnull函数：<br>​		select ename,(sal+ifnull(comm,0))12 as yearsal from emp;</p>
<p>ifnull() 空处理函数？<br>        ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。<br>        select ename,ifnull(comm,0) as comm from emp；</p>
<p>ifnull函数的用法ifnull（数据，被当作哪个值）</p>
<p>如果“数据”为null的时候，把这个数据结构当作哪个值</p>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>格式化数字 ：format(数字，’格式’)</p>
<p>select ename ,format(sal,’$999,999’)as sal from emp</p>
<h2 id="str-to-data"><a href="#str-to-data" class="headerlink" title="str_to_data"></a>str_to_data</h2><table>
<thead>
<tr>
<th>MySQL日期格式</th>
</tr>
</thead>
<tbody><tr>
<td>%Y   年</td>
</tr>
<tr>
<td>%m  月</td>
</tr>
<tr>
<td>%d  日</td>
</tr>
<tr>
<td>%h 时</td>
</tr>
<tr>
<td>%i 分</td>
</tr>
<tr>
<td>%s 秒</td>
</tr>
</tbody></table>
<p>将字符串varchar类型转换乘date类型</p>
<p>str_to_data(‘字符串日期’,‘日期格式’)</p>
<p>如果你提供的日期字符串是这个格式，str_to_data函数就不需要啦，也就是说直接在插入的时候就是这个格式’2003-01-12’这个格式，会进行自动类型转换</p>
<h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a>date_format</h2><p>将data类型转换成具有一定格式的varchar字符串类型</p>
<p>data_format（日期类型数据，’日期格式’） 通常在查询日期时使用</p>
<p>select id,name,data_format(birth,’%m&#x2F;%d&#x2F;%Y’)as birth from t_user;</p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220418224249555.png" alt="image-20220418224249555"></p>
<h1 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h1><p>分组函数还有另一个名字：多行处理函数。<br>    多行处理函数的特点：输入多行，最终输出的结果是1行。	</p>
<p>​	count 计数<br>​	sum 求和<br>​	avg 平均值<br>​	max 最大值<br>​	min 最小值</p>
<p><strong>所有的分组函数都是对“某一组”数据进行操作的，分组函数在使用的时候必须先进行分组，然后才能使用</strong></p>
<p><strong>如果没有对数据进行分组整张表默认为一组</strong></p>
<p>找出工资总和？<br>    select sum(sal) from emp;<br>找出最高工资？<br>    select max(sal) from emp;<br>找出最低工资？<br>    select min(sal) from emp;<br>找出平均工资？<br>    select avg(sal) from emp;<br>找出总人数？<br>    select count(*) from emp;<br>    select count(ename) from emp;</p>
<p>分组函数一共5个。</p>
<p><strong>分组函数自动忽略NULL。</strong></p>
<p><font color="red"><strong>分组函数不能直接使用在where子句中</strong></font></p>
<p>select ename,sal from emp where sal &gt; avg(sal); &#x2F;&#x2F;ERROR 1111 (HY000): Invalid use of group function<br>            思考以上的错误信息：无效的使用了分组函数？<br>                原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why????<br>                怎么解释？<br>                    因为group by是在where执行之后才会执行的。</p>
<p>为什么select sum（comm）from emp 可以用</p>
<p>因为默认分为了一张表，select最后执行，已经分好组了</p>
<p>count(*)和count(具体的某个字段)，他们有什么区别？<br>    count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关），可以算上null</p>
<p>因为每一行记录不可能都为null，一列数据中有一列不为null，则这行数据就是有效的</p>
<p>​	count(comm): 表示统计comm字段中不为NULL的数据总数量。</p>
<p><strong>分组函数也能组合起来用：</strong><br>    select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;  </p>
<p>找出工资高于平均工资的员工？<br>        第一步：找出平均工资<br>            select avg(sal) from emp;</p>
<p>第二步：找出高于平均工资的员工<br>            select ename,sal from emp where sal &gt; 2073.214286;</p>
<p>select ename,sal from emp where sal &gt; (select avg(sal) from emp);</p>
<h1 id="group-by-和-having"><a href="#group-by-和-having" class="headerlink" title="group by 和 having"></a>group by 和 having</h1><p>group by ： 按照某个字段或者某些字段进行分组。<br>    having : having是对分组之后的数据进行再次过滤。但是having不能单独使用</p>
<p>where和having的区别，where是筛选出来再分组，having是分组之后再筛选</p>
<p><strong>having不可以单独使用</strong></p>
<p>优化策略：where和having，优先选择where，where实在完成不了了，再使用having  </p>
<p>找出每个工作岗位的最高薪资。<br>    select max(sal),job from emp group by job;</p>
<p>注意：分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。<br>    &#x3D;&#x3D;&#x3D;<strong>并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。</strong>&#x3D;&#x3D;<br>    当一条sql语句没有group by的话，整张表的数据会自成一组。</p>
<p>select ename,max(sal),job from emp group by job;<br>以上在mysql当中，查询结果是有的，但是结果没有意义，在Oracle数据库当中会报错。语法错误。<br>Oracle的语法规则比MySQL语法规则严谨。<br>记住一个规则<strong>：当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段(就是根据某个字段分组那个字段)</strong></p>
<p>每个工作岗位的平均薪资？<br>    select job,avg(sal) from emp group by job;</p>
<p>多个字段能不能联合起来一块分组？</p>
<p>​	案例：找出每个部门不同工作岗位的最高薪资。<br>​		select<br>​			deptno,job,max(sal)<br>​		from<br>​			emp<br>​		group by<br>​			deptno,job;</p>
<p>技巧：两个字段联合分组（在分组中分组）也就是套娃</p>
<p>找出每个部门的最高薪资，要求显示薪资大于2900的数据。</p>
<p>​	第一步：找出每个部门的最高薪资<br>​	select max(sal),deptno from emp group by deptno;</p>
<p>第二步：找出薪资大于2900<br>        select max(sal),deptno from emp group by deptno having max(sal) &gt; 2900; &#x2F;&#x2F; 这种方式效率低。</p>
<p>select max(sal),deptno from emp where sal &gt; 2900 group by deptno;  &#x2F;&#x2F; 效率较高，建议能够使用where过滤的尽量使用where。</p>
<p>找出每个部门的平均薪资，要求显示薪资大于2000的数据。</p>
<p>第一步：找出每个部门的平均薪资<br>select deptno,avg(sal) from emp group by deptno;</p>
<p>第二步：要求显示薪资大于2000的数据<br>    select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;	</p>
<p>where后面不能使用分组函数：<br>        select deptno,avg(sal) from emp where avg(sal) &gt; 2000 group by deptno;	&#x2F;&#x2F; 错误了。<br>        这种情况只能使用having过滤。</p>
<h1 id="一个完整的DQL语句怎么写"><a href="#一个完整的DQL语句怎么写" class="headerlink" title="一个完整的DQL语句怎么写"></a>一个完整的DQL语句怎么写</h1><p>​	select		5<br>​		..<br>​	from			1	<br>​		..<br>​	where			2<br>​		..<br>​	group by		3<br>​		..<br>​	having		4<br>​		..<br>​	order by		6<br>​		..</p>
<h1 id="查询结果集的去重（distinct）"><a href="#查询结果集的去重（distinct）" class="headerlink" title="查询结果集的去重（distinct）"></a>查询结果集的去重（distinct）</h1><p>select distinct job from emp; &#x2F;&#x2F; distinct关键字去除重复记录。</p>
<p> select ename,distinct job from emp;<br>以上的sql语句是错误的。<br>记住：<strong>distinct只能出现在所有字段的最前面</strong>（所有记录联合起来去重复记录）</p>
<p>统计岗位的数量？<br>select count(distinct job) from emp;</p>
<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>​	在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。<br>​	在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。</p>
<h2 id="连接查询的分类"><a href="#连接查询的分类" class="headerlink" title="连接查询的分类"></a>连接查询的分类</h2><p>​	根据语法出现的年代来划分的话，包括：<br>​		SQL92（一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员）<br>​		SQL99（比较新的语法）<br>​	</p>
<p>根据表的连接方式来划分，包括：<br>    内连接：<br>        等值连接<br>        非等值连接<br>        自连接<br>    外连接：<br>        左外连接（左连接）<br>        右外连接（右连接）<br>    全连接（这个不讲，很少用！）</p>
<h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）</p>
<p>笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</p>
<p>关于表的别名：<br>    select </p>
<p>​		e.ename,d.dname </p>
<p>​		from emp e,dept d;<br>​	表的别名有什么好处？<br>​		第一：执行效率高。<br>​		第二：可读性好。</p>
<p>怎么避免笛卡尔积现象？当然是加条件进行过滤。<br>思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？<br>    不会，次数还是那么多次。只不过显示的是有效记录。</p>
<p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。<br>    select	<br>        e.ename,d.dname<br>    from<br>        emp e , dept d<br>    where<br>        e.deptno &#x3D; d.deptno; &#x2F;&#x2F;SQL92，以后不用。</p>
<h1 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h1><h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><p>等值连接：最大特点是：条件是等量关系。</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on</span><br><span class="line">		e.deptno = d.deptno;</span><br></pre></td></tr></table></figure>

<p>案例：查询每个员工的部门名称，要求显示员工名和部门名。</p>
<p>SQL92:（太老，不用了）</p>
<p>SQL92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放在了where后面</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e, dept d</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

<p>SQL99：（常用的）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">		e.ename,d.dname</span><br><span class="line">	<span class="keyword">from</span></span><br><span class="line">		emp e</span><br><span class="line">	<span class="keyword">join</span></span><br><span class="line">		dept d</span><br><span class="line">	<span class="keyword">on</span></span><br><span class="line">		e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; inner可以省略的，带着inner目的是可读性好一些。（这两个是等价的）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>





<p>sql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	A</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	B</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	连接条件</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	筛选条件</span><br></pre></td></tr></table></figure>

<p>SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。</p>
<h2 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h2><p>最大的特点是：连接条件中的关系是非等量关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。<br>select ename,sal from emp;  e<br>+——–+———+<br>| ename  | sal     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| ALLEN  | 1600.00 |<br>| WARD   | 1250.00 |<br>| JONES  | 2975.00 |<br>| MARTIN | 1250.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| SCOTT  | 3000.00 |<br>| KING   | 5000.00 |<br>| TURNER | 1500.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| FORD   | 3000.00 |<br>| MILLER | 1300.00 |<br>+——–+———+</p>
<p>mysql&gt; select * from salgrade; s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; inner可以省略</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SMITH  |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>最大的特点是：<strong>一张表看做两张表</strong>。自己连接自己。</p>
<p>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。<br> select empno,ename,mgr from emp;<br>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+<br>emp b 领导表<br>+——-+——–+<br>| empno | ename  |<br>+——-+——–+<br>|  7566 | JONES  |<br>|  7698 | BLAKE  |<br>|  7782 | CLARK  |<br>|  7788 | SCOTT  |<br>|  7839 | KING   |<br>|  7902 | FORD   |<br>+——-+——–+</p>
<p>员工的领导编号 &#x3D; 领导的员工编号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="keyword">as</span> <span class="string">&#x27;员工名&#x27;</span>,b.ename <span class="keyword">as</span> <span class="string">&#x27;领导名&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;<span class="operator">/</span><span class="operator">/</span>员工的领导编号等于领导的编号</span><br></pre></td></tr></table></figure>

<p>+——–+——–+<br>| 员工名 | 领导名 |<br>+——–+——–+<br>| SMITH  | FORD   |<br>| ALLEN  | BLAKE  |<br>| WARD   | BLAKE  |<br>| JONES  | KING   |<br>| MARTIN | BLAKE  |<br>| BLAKE  | KING   |<br>| CLARK  | KING   |<br>| SCOTT  | JONES  |<br>| TURNER | BLAKE  |<br>| ADAMS  | SCOTT  |<br>| JAMES  | BLAKE  |<br>| FORD   | JONES  |<br>| MILLER | CLARK  |<br>+——–+——–+</p>
<p>没有king</p>
<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><p>​	<br>什么是外连接，和内连接有什么区别？</p>
<p>内连接：<br>    假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。<br>    AB两张表没有主副之分，两张表是平等的。</p>
<p>外连接：<br>    假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中<br>    的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p>
<p>外连接的分类？<br>    左外连接（左连接）：表示左边的这张表是主表。<br>    右外连接（右连接）：表示右边的这张表是主表。</p>
<p>​	左连接有右连接的写法，右连接也会有对应的左连接的写法。</p>
<p>案例：找出每个员工的上级领导？（所有员工必须全部查询出来。）</p>
<p>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+<br>emp b 领导表<br>+——-+——–+<br>| empno | ename  |<br>+——-+——–+<br>|  7566 | JONES  |<br>|  7698 | BLAKE  |<br>|  7782 | CLARK  |<br>|  7788 | SCOTT  |<br>|  7839 | KING   |<br>|  7902 | FORD   |<br>+——-+——–+</p>
<p>内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>外连接：（左外连接&#x2F;左连接）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span><span class="operator">/</span><span class="operator">/</span><span class="keyword">left</span>代表将<span class="keyword">join</span>关键字左边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着查询右边的表</span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; join前面的outer是可以省略的。带着可读性强</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>外连接：（右外连接&#x2F;右连接）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; outer可以省略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	a.ename <span class="string">&#x27;员工&#x27;</span>, b.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp b</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">	emp a</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	a.mgr <span class="operator">=</span> b.empno;</span><br></pre></td></tr></table></figure>

<p>+——–+——-+<br>| 员工      | 领导    |<br>+——–+——-+<br>| SMITH  | FORD  |<br>| ALLEN  | BLAKE |<br>| WARD   | BLAKE |<br>| JONES  | KING  |<br>| MARTIN | BLAKE |<br>| BLAKE  | KING  |<br>| CLARK  | KING  |<br>| SCOTT  | JONES |<br>| KING   | NULL  |<br>| TURNER | BLAKE |<br>| ADAMS  | SCOTT |<br>| JAMES  | BLAKE |<br>| FORD   | JONES |<br>| MILLER | CLARK |<br>+——–+——-+</p>
<p>外连接最重要的特点是：主表的数据无条件的全部查询出来。</p>
<p>案例：找出哪个部门没有员工？<br>EMP表<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>DEPT<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	e.empno <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h2 id="三张表连接查询"><a href="#三张表连接查询" class="headerlink" title="三张表连接查询"></a>三张表连接查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	A</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	B</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">    A和B的连接条件</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	C</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	A和C的连接条件</span><br></pre></td></tr></table></figure>

<p>一条sql中内连接和外连接可以混合，都可以出现</p>
<p>案例：找出每一个员工的部门名称以及工资等级。<br>EMP e<br>+——-+——–+———+——–+<br>| empno | ename  | sal     | deptno |<br>+——-+——–+———+——–+<br>|  7369 | SMITH  |  800.00 |     20 |<br>|  7499 | ALLEN  | 1600.00 |     30 |<br>|  7521 | WARD   | 1250.00 |     30 |<br>|  7566 | JONES  | 2975.00 |     20 |<br>|  7654 | MARTIN | 1250.00 |     30 |<br>|  7698 | BLAKE  | 2850.00 |     30 |<br>|  7782 | CLARK  | 2450.00 |     10 |<br>|  7788 | SCOTT  | 3000.00 |     20 |<br>|  7839 | KING   | 5000.00 |     10 |<br>|  7844 | TURNER | 1500.00 |     30 |<br>|  7876 | ADAMS  | 1100.00 |     20 |<br>|  7900 | JAMES  |  950.00 |     30 |<br>|  7902 | FORD   | 3000.00 |     20 |<br>|  7934 | MILLER | 1300.00 |     10 |<br>+——-+——–+———+——–+<br>DEPT d<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+<br>SALGRADE s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+ </p>
<p>表示：A表和B表先进行表连接，连接之后A表继续和C表进行连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename,d.dname,s.grade</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal;</span><br></pre></td></tr></table></figure>

<p>+——–+————+——-+<br>| ename  | dname      | grade |<br>+——–+————+——-+<br>| SMITH  | RESEARCH   |     1 |<br>| ALLEN  | SALES      |     3 |<br>| WARD   | SALES      |     2 |<br>| JONES  | RESEARCH   |     4 |<br>| MARTIN | SALES      |     2 |<br>| BLAKE  | SALES      |     4 |<br>| CLARK  | ACCOUNTING |     4 |<br>| SCOTT  | RESEARCH   |     4 |<br>| KING   | ACCOUNTING |     5 |<br>| TURNER | SALES      |     3 |<br>| ADAMS  | RESEARCH   |     1 |<br>| JAMES  | SALES      |     1 |<br>| FORD   | RESEARCH   |     4 |<br>| MILLER | ACCOUNTING |     2 |<br>+——–+————+——-+</p>
<p>案例：找出每一个员工的部门名称、工资等级、以及上级领导。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	e.ename <span class="string">&#x27;员工&#x27;</span>,d.dname,s.grade,e1.ename <span class="string">&#x27;领导&#x27;</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	emp e</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	dept d</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	salgrade s</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span><span class="operator">/</span><span class="operator">/</span>注意这个<span class="keyword">left</span></span><br><span class="line">	emp e1</span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">	e.mgr <span class="operator">=</span> e1.empno;</span><br></pre></td></tr></table></figure>



<p>+——–+————+——-+——-+<br>| 员工      | dname      | grade | 领导    |<br>+——–+————+——-+——-+<br>| SMITH  | RESEARCH   |     1 | FORD  |<br>| ALLEN  | SALES      |     3 | BLAKE |<br>| WARD   | SALES      |     2 | BLAKE |<br>| JONES  | RESEARCH   |     4 | KING  |<br>| MARTIN | SALES      |     2 | BLAKE |<br>| BLAKE  | SALES      |     4 | KING  |<br>| CLARK  | ACCOUNTING |     4 | KING  |<br>| SCOTT  | RESEARCH   |     4 | JONES |<br>| KING   | ACCOUNTING |     5 | NULL  |<br>| TURNER | SALES      |     3 | BLAKE |<br>| ADAMS  | RESEARCH   |     1 | SCOTT |<br>| JAMES  | SALES      |     1 | BLAKE |<br>| FORD   | RESEARCH   |     4 | JONES |<br>| MILLER | ACCOUNTING |     2 | CLARK |<br>+——–+————+——-+——-+</p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>​	<strong>select语句当中嵌套select语句，被嵌套的select语句是子查询。</strong></p>
<p>思路：<strong>把查询到的结果也当成一张新表</strong></p>
<p>​	子查询可以出现在哪里？<br>​			这三个位置都是可以的</p>
<p>​		select<br>​			..(select).<br>​		from<br>​			..(select).<br>​		where<br>​			..(select).</p>
<h2 id="where子句中使用子查询"><a href="#where子句中使用子查询" class="headerlink" title="where子句中使用子查询"></a>where子句中使用子查询</h2><p>案例：找出高于平均薪资的员工信息。<br>select * from emp where sal &gt; avg(sal); &#x2F;&#x2F;错误的写法，where后面不能直接使用分组函数。</p>
<p>第一步：找出平均薪资<br>    select avg(sal) from emp;<br>    +————-+<br>    | avg(sal)    |<br>    +————-+<br>    | 2073.214286 |<br>    +————-+<br>第二步：where过滤<br>    select * from emp where sal &gt; 2073.214286;</p>
<p>​	+——-+——-+———–+——+————+———+——+——–+<br>​	| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |<br>​	+——-+——-+———–+——+————+———+——+——–+<br>​	|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |<br>​	|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |<br>​	|  7782 | CLARK | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |<br>​	|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |<br>​	|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |<br>​	|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |<br>​	+——-+——-+———–+——+————+———+——+——–+<br>第一步和第二步合并：<br>​	select * from emp where sal &gt; (select avg(sal) from emp);</p>
<h2 id="from后面嵌套子查询"><a href="#from后面嵌套子查询" class="headerlink" title="from后面嵌套子查询"></a>from后面嵌套子查询</h2><p>案例：找出每个部门平均薪水的等级。<br>第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) <span class="keyword">as</span> avgsal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>





<p>+——–+————-+<br>| deptno | avgsal      |<br>+——–+————-+<br>|     10 | 2916.666667 |<br>|     20 | 2175.000000 |<br>|     30 | 1566.666667 |<br>+——–+————-+<br>第二步：将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是：t.avgsal between s.losal and s.hisal<br>select<br>    t.*,s.grade<br>from<br>    (select deptno,avg(sal) as avgsal from emp group by deptno) t<br>join<br>    salgrade s<br>on<br>    t.avgsal between s.losal and s.hisal;</p>
<p>+——–+————-+——-+<br>| deptno | avgsal      | grade |<br>+——–+————-+——-+<br>|     30 | 1566.666667 |     3 |<br>|     10 | 2916.666667 |     4 |<br>|     20 | 2175.000000 |     4 |<br>+——–+————-+——-+</p>
<p>案例：找出每个部门平均的薪水等级。<br>第一步：找出每个员工的薪水等级。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.ename,e.sal,e.deptno,s.grade </span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">join</span> salgrade s </span><br><span class="line"><span class="keyword">on</span> e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisa</span><br></pre></td></tr></table></figure>


<p>l;<br>+——–+———+——–+——-+<br>| ename  | sal     | deptno | grade |<br>+——–+———+——–+——-+<br>| SMITH  |  800.00 |     20 |     1 |<br>| ALLEN  | 1600.00 |     30 |     3 |<br>| WARD   | 1250.00 |     30 |     2 |<br>| JONES  | 2975.00 |     20 |     4 |<br>| MARTIN | 1250.00 |     30 |     2 |<br>| BLAKE  | 2850.00 |     30 |     4 |<br>| CLARK  | 2450.00 |     10 |     4 |<br>| SCOTT  | 3000.00 |     20 |     4 |<br>| KING   | 5000.00 |     10 |     5 |<br>| TURNER | 1500.00 |     30 |     3 |<br>| ADAMS  | 1100.00 |     20 |     1 |<br>| JAMES  |  950.00 |     30 |     1 |<br>| FORD   | 3000.00 |     20 |     4 |<br>| MILLER | 1300.00 |     10 |     2 |<br>+——–+———+——–+——-+<br>第二步：基于以上结果，继续按照deptno分组，求grade平均值。<br>select<br>    e.deptno,avg(s.grade)<br>from<br>    emp e<br>join<br>    salgrade s<br>on<br>    e.sal between s.losal and s.hisal<br>group by<br>    e.deptno;</p>
<p>+——–+————–+<br>| deptno | avg(s.grade) |<br>+——–+————–+<br>|     10 |       3.6667 |<br>|     20 |       2.8000 |<br>|     30 |       2.5000 |<br>+——–+————–+</p>
<h2 id="在select后面嵌套子查询。"><a href="#在select后面嵌套子查询。" class="headerlink" title="在select后面嵌套子查询。"></a>在select后面嵌套子查询。</h2><p>（了解即可）</p>
<p>案例：找出每个员工所在的部门名称，要求显示员工名和部门名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename,d.dname</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno;</span><br></pre></td></tr></table></figure>

<p>这两个是等价的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname </span><br><span class="line">from </span><br><span class="line">	emp e;</span><br></pre></td></tr></table></figure>

<p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| SMITH  | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| JONES  | RESEARCH   |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| CLARK  | ACCOUNTING |<br>| SCOTT  | RESEARCH   |<br>| KING   | ACCOUNTING |<br>| TURNER | SALES      |<br>| ADAMS  | RESEARCH   |<br>| JAMES  | SALES      |<br>| FORD   | RESEARCH   |<br>| MILLER | ACCOUNTING |<br>+——–+————+</p>
<h1 id="union-（可以将查询结果集合并）"><a href="#union-（可以将查询结果集合并）" class="headerlink" title="union （可以将查询结果集合并）"></a>union （可以将查询结果集合并）</h1><p>union的效率要高一些，对于表连接来说，每连接一次新表，则匹配的次数要成倍的翻</p>
<p>但是union可以减少匹配的次数，再减少匹配的次数的情况下，还可以完成两个结果集的拼接</p>
<p>案例：找出工作岗位是SALESMAN和MANAGER的员工？</p>
<p>第一种：select ename,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’;<br>第二种：select ename,job from emp where job in(‘MANAGER’,’SALESMAN’);<br>+——–+———-+<br>| ename  | job      |<br>+——–+———-+<br>| ALLEN  | SALESMAN |<br>| WARD   | SALESMAN |<br>| JONES  | MANAGER  |<br>| MARTIN | SALESMAN |<br>| BLAKE  | MANAGER  |<br>| CLARK  | MANAGER  |<br>| TURNER | SALESMAN |<br>+——–+———-+<br>第三种：union<br>select ename,job from emp where job &#x3D; ‘MANAGER’<br>union<br>select ename,job from emp where job &#x3D; ‘SALESMAN’;<br>+——–+———-+<br>| ename  | job      |<br>+——–+———-+<br>| JONES  | MANAGER  |<br>| BLAKE  | MANAGER  |<br>| CLARK  | MANAGER  |<br>| ALLEN  | SALESMAN |<br>| WARD   | SALESMAN |<br>| MARTIN | SALESMAN |<br>| TURNER | SALESMAN |<br>+——–+———-+</p>
<p>两张不相干的表中的数据拼接在一起显示？<br>select ename from emp<br>union<br>select dname from dept;</p>
<p>+————+<br>| ename      |<br>+————+<br>| SMITH      |<br>| ALLEN      |<br>| WARD       |<br>| JONES      |<br>| MARTIN     |<br>| BLAKE      |<br>| CLARK      |<br>| SCOTT      |<br>| KING       |<br>| TURNER     |<br>| ADAMS      |<br>| JAMES      |<br>| FORD       |<br>| MILLER     |<br>| ACCOUNTING |<br>| RESEARCH   |<br>| SALES      |<br>| OPERATIONS |<br>+————+</p>
<p>union在进行结果集合并的时候，要求两个结果的结果集的列数相同，数据结构的类型也要相同</p>
<p>mysql&gt; select ename,sal from emp<br>    -&gt; union<br>    -&gt; select dname from dept;<br>ERROR 1222 (21000): The used SELECT statements have a different number of columns</p>
<h1 id="limit-分页查询"><a href="#limit-分页查询" class="headerlink" title="limit (分页查询)"></a>limit (分页查询)</h1><p>limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum）</p>
<p>limit取结果集中的部分数据，这时它的作用。</p>
<h2 id="语法机制："><a href="#语法机制：" class="headerlink" title="语法机制："></a>语法机制：</h2><p>​	limit startIndex, length<br>​		startIndex表示起始位置，从0开始，0表示第一条数据。<br>​		length表示取几个<br>​	也可以limit lenth </p>
<p>案例：取出工资前5名的员工（思路：降序取前5个）<br>    select ename,sal from emp order by sal desc;<br>    取前5个：<br>        select ename,sal from emp order by sal desc limit 0, 5;<br>        select ename,sal from emp order by sal desc limit 5;</p>
<h2 id="limit是sql语句最后执行的-一个环节："><a href="#limit是sql语句最后执行的-一个环节：" class="headerlink" title="limit是sql语句最后执行的 一个环节："></a><strong>limit是sql语句最后执行的 一个环节</strong>：</h2><p>​	select		5<br>​		…<br>​	from			1<br>​		…		<br>​	where			2<br>​		…	<br>​	group by		3<br>​		…<br>​	having		4<br>​		…<br>​	order by		6<br>​		…<br>​	limit			7<br>​		…;</p>
<p>案例：找出工资排名在第4到第9名的员工？</p>
<p>​	select ename,sal from emp order by sal desc limit 3,6;<br>​	+——–+———+<br>​	| ename  | sal     |<br>​	+——–+———+<br>​	| JONES  | 2975.00 |<br>​	| BLAKE  | 2850.00 |<br>​	| CLARK  | 2450.00 |<br>​	| ALLEN  | 1600.00 |<br>​	| TURNER | 1500.00 |<br>​	| MILLER | 1300.00 |<br>​	+——–+———+</p>
<h2 id="通用的标准分页sql"><a href="#通用的标准分页sql" class="headerlink" title="通用的标准分页sql"></a>通用的标准分页sql</h2><p>每页显示3条记录：<br>第1页：0, 3<br>第2页：3, 3<br>第3页：6, 3<br>第4页：9, 3<br>第5页：12, 3</p>
<p>每页显示pageSize条记录：<br>第pageNo页：(pageNo - 1) * pageSize, pageSize</p>
<p>pageSize是什么？是每页显示多少条记录<br>pageNo是什么？显示第几页</p>
<p>java代码{<br>    int pageNo &#x3D; 2; &#x2F;&#x2F; 页码是2<br>    int pageSize &#x3D; 10; &#x2F;&#x2F; 每页显示10条</p>
<p>} </p>
<p><strong>公式为</strong></p>
<pre><code>limit (pageNo - 1) * pageSize, pageSize
</code></pre>
<h1 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h1><p>​	</p>
<h2 id="建表语句的语法格式"><a href="#建表语句的语法格式" class="headerlink" title="建表语句的语法格式"></a>建表语句的语法格式</h2><p>​	create table 表名(<br>​		字段名1 数据类型,<br>​		字段名2 数据类型,<br>​		字段名3 数据类型,<br>​		….<br>​	);</p>
<h2 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h2><p>关于MySQL当中字段的数据类型？以下只说常见的<br>    int		整数型(java中的int)最长11位<br>    bigint	长整型(java中的long)<br>    float		浮点型(java中的float double)最长255<br>    char		定长字符串(String)最长255<br>    varchar	可变长字符串(StringBuffer&#x2F;StringBuilder)<br>    date		日期类型 （对应Java中的java.sql.Date类型）<br>    BLOB		二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object）<br>    CLOB		字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object）<br>    ……</p>
<h3 id="char和varcha"><a href="#char和varcha" class="headerlink" title="char和varcha"></a>char和varcha</h3><p>char和varchar怎么选择？<br>    在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char。<br>    当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。</p>
<p>表名在数据库当中一般建议以：t_或者tbl_开始。</p>
<h2 id="date和datetime"><a href="#date和datetime" class="headerlink" title="date和datetime"></a>date和datetime</h2><p>date是短日期，只包含年月日信息</p>
<p>datetime是长日期，包括年月日时分秒信息</p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220418225206478.png" alt="image-20220418225206478"></p>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><p>​	drop table 表名; &#x2F;&#x2F; 这个通用。<br>​	drop table if exists 表名; &#x2F;&#x2F; oracle不支持这种写法。</p>
<h1 id="insert语句插入数据"><a href="#insert语句插入数据" class="headerlink" title="insert语句插入数据"></a>insert语句插入数据</h1><p>​	语法格式：<br>​		insert into 表名(字段名1,字段名2,字段名3,….) </p>
<p>​		values(值1,值2,值3,….)；<br>​		要求：字段的数量和值的数量相同，并且数据类型要对应相同。<br>​	<strong>字段名和值要一一对应。</strong></p>
<p>insert into t_student(name) values(‘wangwu’); &#x2F;&#x2F; 除name字段之外，剩下的所有字段自动插入NULL。</p>
<p>需要注意的地方：<br>    当一条insert语句执行成功之后，表格当中必然会多一行记录。<br>    即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行<br>    insert语句插入数据了，只能使用update进行更新。</p>
<p>&#x2F;&#x2F; 字段可以省略不写，但是后面的value对数量和顺序都有要求。<br>insert into t_student values(1,’jack’,’0’,’gaosan2ban’,’1986-10-23’);</p>
<p>insert into t_student values(1,’jack’,’0’,’gaosan2ban’);<br>ERROR 1136 (21S01): Column count doesn’t match value count at row 1</p>
<p>&#x2F;&#x2F; 一次插入多行数据,用逗号隔开<br>insert into t_student<br>    (no,name,sex,classno,birth)<br>values<br>    (3,’rose’,’1’,’gaosi2ban’,’1952-12-14’),(4,’laotie’,’1’,’gaosi2ban’,’1955-12-14’);</p>
<h2 id="表的复制（快速创建表）"><a href="#表的复制（快速创建表）" class="headerlink" title="表的复制（快速创建表）"></a>表的复制（快速创建表）</h2><p>​	语法：<br>​		create table 表名 as select语句;<br>​		将查询结果当做表创建出来。 </p>
<h2 id="将查询结果插入到一张表中"><a href="#将查询结果插入到一张表中" class="headerlink" title="将查询结果插入到一张表中"></a>将查询结果插入到一张表中</h2><p>insert into dept1 select * from dept;</p>
<h1 id="修改数据：update"><a href="#修改数据：update" class="headerlink" title="修改数据：update"></a>修改数据：update</h1><p>语法格式：<br>    update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2… where 条件;</p>
<p>字段名如果是中文也不需要加单引号，直接用就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 让字段的值在原来的基础上加1</span><br><span class="line"></span><br><span class="line">set (字段名)=(字段名)+1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">案例：将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHIBU</span><br><span class="line">update dept1 set loc = &#x27;SHANGHAI&#x27;, dname = &#x27;RENSHIBU&#x27; where deptno = 10;</span><br><span class="line">	update dept1 set loc = &#x27;x&#x27;, dname = &#x27;y&#x27;;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>没有条件整张表数据全部更新。</strong></p>
<h1 id="删除数据：delete"><a href="#删除数据：delete" class="headerlink" title="删除数据：delete"></a>删除数据：delete</h1><p>​	语法格式：<br>​		delete from 表名 where 条件;<br>​	</p>
<p>注意：<strong>没有条件全部删除。</strong></p>
<p>删除10部门数据？<br>    delete from dept1 where deptno &#x3D; 10;</p>
<p>删除所有记录？<br>    delete from dept1;</p>
<h2 id="快速删除表中的数据"><a href="#快速删除表中的数据" class="headerlink" title="快速删除表中的数据"></a>快速删除表中的数据</h2><p>delete from dept1&#x2F;&#x2F;这种删除数据的方式比较慢</p>
<p>delete 语句删除数据的原理是 表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放</p>
<p>这种删除的缺点是：删除效率比较低</p>
<p>这种删除的优点是：支持回滚，后悔了可以再恢复</p>
<h3 id="物理删除（快速）"><a href="#物理删除（快速）" class="headerlink" title="物理删除（快速）"></a>物理删除（快速）</h3><p>truncate table 表名; &#x2F;&#x2F; 表被截断，不可回滚。永久丢失。</p>
<p>当我们想要清空某张表时，往往会使用truncate语句</p>
<p><strong>truncate截短的；被删节的</strong></p>
<p>truncate不能删除单条数据</p>
<p>delete属于dml </p>
<p>truncate 属于ddl</p>
<h1 id="对于表结构的修改，"><a href="#对于表结构的修改，" class="headerlink" title="对于表结构的修改，"></a>对于表结构的修改，</h1><p>使用工具完成即可，因为在实际开发中表一旦设计好之后，对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使<br>需要修改表结构，我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。<br>出现在java代码当中的sql包括：insert delete update select（这些都是表中的数据操作。）</p>
<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><p>CRUD操作<br>Create（增） Retrieve（检索） Update（修改） Delete（删除）</p>
<h1 id="约束-Constraint"><a href="#约束-Constraint" class="headerlink" title="约束(Constraint)"></a>约束(Constraint)</h1><p>​	在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的<br>​	合法性、有效性、完整性。</p>
<p>​	常见的约束<br>​		非空约束(not null)：约束的字段不能为NULL<br>​		唯一约束(unique)：约束的字段不能重复<br>​		主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）<br>​		外键约束(foreign key)：…（简称FK）<br>​		检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。</p>
<h2 id="非空约束-not-null"><a href="#非空约束-not-null" class="headerlink" title="非空约束 not null"></a>非空约束 not null</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user(id,password) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>​		ERROR 1364 (HY000): Field ‘username’ doesn’t have a default value</p>
<p>insert into t_user(id,username,password) values(1,’lisi’,’123’);&#x2F;&#x2F;这个是OK的</p>
<h2 id="唯一性约束（unique）"><a href="#唯一性约束（unique）" class="headerlink" title="唯一性约束（unique）"></a>唯一性约束（unique）</h2><p>​	</p>
<p><strong>唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。</strong>（可以有多个null）</p>
<p>案例：给某一列添加unique</p>
<p>注意：not null约束只有列级约束。没有表级约束。</p>
<h3 id="联合唯一"><a href="#联合唯一" class="headerlink" title="联合唯一"></a>联合唯一</h3><p>新需求：name和email两个字段联合起来具有唯一性</p>
<p>需要这样子创建表</p>
<p>create table t(</p>
<p>id int,</p>
<p>name varchar(255),</p>
<p>email varchar(255),</p>
<p>unique(name,email)&#x2F;&#x2F;<strong>约束没有添加到列的后面，这种约束被称为表级约束</strong></p>
<p>)</p>
<p>name 和email联合起来唯一！</p>
<p><strong>什么时候使用表级约束呢</strong></p>
<p>需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束</p>
<p>在mysql种，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的<strong>身份证号码</strong>一样。）	</p>
<p>任何一张表都应该有主键。 </p>
<p>给一张表添加主键约束呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">	id int primary key,  // 列级约束</span><br><span class="line">	username varchar(255),</span><br><span class="line">	email varchar(255)</span><br><span class="line">);</span><br><span class="line">insert into t_user(id,username,email) values(1,&#x27;zs&#x27;,&#x27;zs@123.com&#x27;);</span><br><span class="line">insert into t_user(id,username,email) values(2,&#x27;ls&#x27;,&#x27;ls@123.com&#x27;);</span><br><span class="line">insert into t_user(id,username,email) values(3,&#x27;ww&#x27;,&#x27;ww@123.com&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line">+----+----------+------------+</span><br><span class="line">| id | username | email      |</span><br><span class="line">+----+----------+------------+</span><br><span class="line">|  1 | zs       | zs@123.com |</span><br><span class="line">|  2 | ls       | ls@123.com |</span><br><span class="line">|  3 | ww       | ww@123.com |</span><br><span class="line">+----+----------+------------+</span><br><span class="line"></span><br><span class="line">insert into t_user(id,username,email) values(1,&#x27;jack&#x27;,&#x27;jack@123.com&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line">insert into t_user(username,email) values(&#x27;jack&#x27;,&#x27;jack@123.com&#x27;);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;id&#x27; doesn&#x27;t have a default value</span><br></pre></td></tr></table></figure>

<p>根据以上的测试得出：id是主键，因为添加了主键约束，主键字段中的数据不能为NULL，也不能重复。<br>主键的特点：不能为NULL，也不能重复。</p>
<ul>
<li><p>主键相关的术语？<br>  主键约束 : primary key<br>  主键字段 : id字段添加primary key之后，id叫做主键字段<br>  主键值 : id字段中的每一个值都是主键值。</p>
</li>
<li><p>主键有什么作用？</p>
<ul>
<li>表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。</li>
<li>主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。）</li>
</ul>
</li>
<li><p>主键的分类？<br>  根据主键字段的字段数量来划分：<br>  单一主键（推荐的，常用的。）<br>  复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）<br>  根据主键性质来划分：<br>  自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）<br>  业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）<br>                最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。</p>
</li>
<li><p>一张表的主键约束只能有1个。（必须记住）</p>
</li>
<li><p>使用表级约束方式定义主键：<br>  drop table if exists t_user;<br>  create table t_user(<br>  id int,<br>  username varchar(255),<br>  primary key(id)<br>  );<br>  insert into t_user(id,username) values(1,’zs’);<br>  insert into t_user(id,username) values(2,’ls’);<br>  insert into t_user(id,username) values(3,’ws’);<br>  insert into t_user(id,username) values(4,’cs’);<br>  select * from t_user;</p>
<p>  insert into t_user(id,username) values(4,’cx’);<br>  ERROR 1062 (23000): Duplicate entry ‘4’ for key ‘PRIMARY’</p>
<p>  以下内容是演示以下复合主键，不需要掌握：<br>  drop table if exists t_user;<br>  create table t_user(<br>      id int,<br>      username varchar(255),<br>      password varchar(255),<br>      primary key(id,username)<br>  );<br>  insert …….</p>
</li>
<li><p>mysql提供主键值自增：（非常重要。）<br>  drop table if exists t_user;<br>  create table t_user(<br>  id int primary key <strong>auto_increment,</strong> &#x2F;&#x2F; id字段自动维护一个自增的数字，从1开始，以1递增。<br>  username varchar(255)<br>  );<br>  insert into t_user(username) values(‘a’);<br>  insert into t_user(username) values(‘b’);<br>  insert into t_user(username) values(‘c’);<br>  insert into t_user(username) values(‘d’);<br>  insert into t_user(username) values(‘e’);<br>  insert into t_user(username) values(‘f’);<br>  select * from t_user;</p>
<p>  提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。</p>
</li>
</ul>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>​	</p>
<ul>
<li><p>关于外键约束的相关术语：<br>  外键约束: foreign key一种约束<br>  外键字段：添加有外键约束的字段<br>  外键值：外键字段中的每一个值。</p>
</li>
<li><p>业务背景：<br>  请设计数据库表，用来维护学生和班级的信息？<br>  第一种方案：一张表存储所有数据<br>  ​	no(pk)			name			classno			classname</p>
<p>  ​	1					zs1				101				北京大兴区经济技术开发区亦庄二中高三1班<br>  ​	2					zs2				101				北京大兴区经济技术开发区亦庄二中高三1班<br>  ​	3					zs3				102				北京大兴区经济技术开发区亦庄二中高三2班<br>  ​	4					zs4				102				北京大兴区经济技术开发区亦庄二中高三2班<br>  ​	5					zs5				102				北京大兴区经济技术开发区亦庄二中高三2班<br>  ​	缺点：冗余。【不推荐】</p>
<p>  ​	第二种方案：两张表（班级表和学生表）<br>  ​	t_class 班级表</p>
<p>  ​	cno(pk)		cname</p>
<p>  ​	101		北京大兴区经济技术开发区亦庄二中高三1班<br>  ​	102		北京大兴区经济技术开发区亦庄二中高三2班</p>
<p>  ​	t_student 学生表</p>
<p>  ​	sno(pk)		sname				classno(该字段添加外键约束fk)</p>
<p>  ​	1				zs1				101<br>  ​	2				zs2				101<br>  ​	3				zs3				102<br>  ​	4				zs4				102<br>  ​	5				zs5				102</p>
</li>
<li><p>将以上表的建表语句写出来：</p>
<p><strong>t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。</strong></p>
<p>子表用着父表的东西，所以要先删除子表</p>
<p>顺序要求：<br>删除数据的时候，先删除子表，再删除父表。<br>添加数据的时候，先添加父表，在添加子表。<br>创建表的时候，先创建父表，再创建子表。<br>删除表的时候，先删除子表，在删除父表。<br>drop table if exists t_student;<br>drop table if exists t_class;</p>
<p>create table t_class(<br>cno int,<br>cname varchar(255),<br>primary key(cno)<br>);</p>
<p>create table t_student(<br>sno int,<br>sname varchar(255),<br>classno int,<br>primary key(sno),<br><strong>foreign key(classno) references t_class(cno)</strong><br>);</p>
<p>insert into t_class values(101,’xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx’);<br>insert into t_class values(102,’yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy’);</p>
<p>insert into t_student values(1,’zs1’,101);<br>insert into t_student values(2,’zs2’,101);<br>insert into t_student values(3,’zs3’,102);<br>insert into t_student values(4,’zs4’,102);<br>insert into t_student values(5,’zs5’,102);<br>insert into t_student values(6,’zs6’,102);<br>select * from t_class;<br>select * from t_student;</p>
<p>insert into t_student values(7,’lisi’,103);&#x2F;&#x2F;没有这个班级<br>ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (<code>bjpowernode</code>.INT <code>t_student_ibfk_1</code> FOREIGN KEY (<code>classno</code>) REFERENCES <code>t_class</code> (<code>cno</code>))&#x2F;&#x2F;报错信息</p>
</li>
<li><p>外键值可以为NULL？<br>  外键可以为NULL。</p>
</li>
<li><p>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？<br>  注意：被引用的字段不一定是主键，但至少具有unique约束。</p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>​	（整个内容属于了解内容）</p>
<p>​	存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，<br>​	就是“表的存储方式”）</p>
<p>​	mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。<br>​	每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220419230054870.png" alt="image-20220419230054870"></p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220419230038249.png" alt="image-20220419230038249"></p>
<p>2.1、完整的建表语句<br>    CREATE TABLE <code>t_x</code> (<br>      <code>id</code> int(11) DEFAULT NULL<br>    ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>​	注意：在MySQL当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。</p>
<p>​	建表的时候可以指定存储引擎，也可以指定字符集。</p>
<p>​	mysql默认使用的存储引擎是InnoDB方式。<br>​	默认采用的字符集是UTF8</p>
<h2 id="Engine-MyISAM"><a href="#Engine-MyISAM" class="headerlink" title="Engine: MyISAM"></a>Engine: MyISAM</h2><p>​			  Support: YES<br>​			  Comment: MyISAM storage engine<br>​		Transactions: NO<br>​					 XA: NO<br>​		  Savepoints: NO<br>​		<br>​		MyISAM这种存储引擎不支持事务。<br>​		MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。<br>​		MyISAM采用三个文件组织一张表：<br>​			xxx.frm（存储格式的文件）<br>​			xxx.MYD（存储表中数据的文件）<br>​			xxx.MYI（存储表中索引的文件）</p>
<p><strong>对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引</strong></p>
<p>​		优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。<br>​		缺点：不支持事务。</p>
<hr>
<h2 id="Engine-InnoDB"><a href="#Engine-InnoDB" class="headerlink" title="Engine: InnoDB"></a>Engine: InnoDB</h2><p>​			  Support: DEFAULT<br>​			  Comment: Supports transactions, row-level locking, and foreign keys<br>​		Transactions: YES<br>​					 XA: YES<br>​		  Savepoints: YES<br>​			InnoDB存储引擎：提供一组用来记录事务性活动的日志文件<br>​		优点：支持<strong>事务</strong>、行级锁、外键等。这种存储引擎数据的安全得到保障。<br>​		InnoDB存储引擎的特点是：<strong>非常安全！！</strong><br>​		表的结构存储在xxx.frm文件中<br>​		数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。</p>
<p>​			（表空间是一个逻辑名称，表空间存储数据+索引）<br>​		这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。<br>​		InnoDB支持级联删除和级联更新。<br>​	</p>
<hr>
<h2 id="Engine-MEMORY"><a href="#Engine-MEMORY" class="headerlink" title="Engine: MEMORY"></a>Engine: MEMORY</h2><p>​			  Support: YES<br>​			  Comment: Hash based, stored in memory, useful for temporary tables<br>​		Transactions: NO<br>​					 XA: NO<br>​		  Savepoints: NO<br>​		<br>​		缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。（目的就是快）<br>​		优点：查询速度最快。<br>​		以前叫做HEPA(堆)引擎。</p>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>​	<strong>一个事务是一个完整的业务逻辑单元，是一个最小的工作单元,不可再分。</strong></p>
<p>什么是完整的业务逻辑：</p>
<p>​	比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：<br>​		update t_act set balance &#x3D; balance - 10000 where actno &#x3D; ‘act-001’;<br>​		update t_act set balance &#x3D; balance + 10000 where actno &#x3D; ‘act-002’;<br>​	<br>​	以上两条DML语句必须同时成功，或者同时失败，不可再分，这样才能保证钱是正确的，不允许出现一条成功，一条失败。</p>
<p>​	要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。</p>
<h2 id="mysql事务默认情况下是自动提交的。"><a href="#mysql事务默认情况下是自动提交的。" class="headerlink" title="mysql事务默认情况下是自动提交的。"></a><strong>mysql事务默认情况下是自动提交的。</strong></h2><p>（什么是自动提交？只要执行任意一条DML语句则提交一次。）</p>
<p>这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功后再提交，所以不能执行一条就提交一条</p>
<p>怎么关闭自动提交？start transaction;（开启事务）</p>
<p><strong>提交一次就需要开启一次事务</strong></p>
<h2 id="只有DML语句才有事务"><a href="#只有DML语句才有事务" class="headerlink" title="只有DML语句才有事务"></a>只有DML语句才有事务</h2><p>insert delete update	</p>
<p>为什么？</p>
<p>因为它们这三个语句都是和数据库表当中的“数据”相关的。</p>
<p>动数据的东西</p>
<p>​	事务的存在是为了保证数据的完整性，安全性。</p>
<h2 id="存在事务的目的"><a href="#存在事务的目的" class="headerlink" title="存在事务的目的"></a>存在事务的目的</h2><p>假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？<br>    <strong>不需要事务。</strong><br>    但实际情况不是这样的，通常一个“事儿（事务【业务】）”需要多条DML语句共同联合完成。</p>
<p>说到底，一个事务其实就是多条DML语句同时成功，或者同时失败</p>
<h2 id="事务是如何做到同时成功和同时失败的"><a href="#事务是如何做到同时成功和同时失败的" class="headerlink" title="事务是如何做到同时成功和同时失败的"></a>事务是如何做到同时成功和同时失败的</h2><p>InnoDB存储引擎：提供一组用来记录<strong>事务性活动的日志文件</strong></p>
<p>事务开始了；</p>
<p>insert</p>
<p>insert</p>
<p>update</p>
<p>事务结束了</p>
<p>在事务的执行过程中，每一条DML的操作都会记录到‘事务性活动的日志文件’中，在事务的执行过程中，我们可以提交事务，也可以回滚事务</p>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p><strong>commit;语句</strong></p>
<p>清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中，提交事务标志着事务的结束，并且是一种全部成功的结束</p>
<h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><p><strong>rollback;语句</strong></p>
<p>将之前的DML操作全部撤销，并且清空事务性活动的日志文件，回滚事务标志着事务的结束，并且是一种全部失败的结束</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>​	事务包括四大特性：ACID<br>​	A: 原子性：事务是最小的工作单元，不可再分。<br>​	C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。<br>​	I：隔离性：事务A与事务B之间具有隔离。A事务再操作一张表的时候，另一个事务B也操作这张表会怎摸样</p>
<p>隔离性涉及到隔离级别，具体看下一小节</p>
<p>​	D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。</p>
<h2 id="事务之间的隔离性"><a href="#事务之间的隔离性" class="headerlink" title="事务之间的隔离性"></a>事务之间的隔离性</h2><p>A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄，这就是事务的隔离级别，这道墙越厚，表示隔离级别越高	</p>
<p>事务隔离性存在隔离级别，理论上隔离级别包括4个：</p>
<h3 id="第一级别：读未提交（read-uncommitted）"><a href="#第一级别：读未提交（read-uncommitted）" class="headerlink" title="第一级别：读未提交（read uncommitted）"></a><strong>第一级别：读未提交（read uncommitted）</strong></h3><p>​			对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。<br>​			读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。</p>
<h3 id="第二级别：读已提交（read-committed）"><a href="#第二级别：读已提交（read-committed）" class="headerlink" title="第二级别：读已提交（read committed）"></a>第二级别：读已提交（read committed）</h3><p>​			对方<strong>事务提交</strong>之后的数据我方可以读取到。<br>​			这种隔离级别解决了: 脏读现象没有了。<br>​			读已提交存在的问题是：不可重复读。</p>
<p>不可重复读：</p>
<p>​		在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读的时候，读到的数据是4条，3不等于4，称为不可重复读取</p>
<p>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实</p>
<p>Oracle数据库默认的隔离级别就是read committed</p>
<h3 id="第三级别：可重复读（repeatable-read）"><a href="#第三级别：可重复读（repeatable-read）" class="headerlink" title="第三级别：可重复读（repeatable read）"></a>第三级别：可重复读（repeatable read）</h3><p>可重复读取：事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的，即使B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读.			</p>
<p>银行合计问题：从1点select到3点，得到的还是1点前的数据</p>
<p>​			这种隔离级别解决了：不可重复读问题。<br>​			这种隔离级别存在的问题是：读取到的数据是幻象。</p>
<h3 id="第四级别：序列化读-x2F-串行化读（serializable）"><a href="#第四级别：序列化读-x2F-串行化读（serializable）" class="headerlink" title="第四级别：序列化读&#x2F;串行化读（serializable）"></a>第四级别：序列化读&#x2F;串行化读（serializable）</h3><p>​			解决了所有问题。<br>​			效率低。需要事务排队。<br>synchronized，线程同步（这个是事务同步）		</p>
<p>这种隔离级别表示事务排队，不能并发</p>
<p>（不能两个客户端同时操作一张表）</p>
<p>​		oracle数据库默认的隔离级别是：读已提交。<br>​		mysql数据库默认的隔离级别是：可重复读。</p>
<p>3.6、演示事务</p>
<ul>
<li><p>准备表：<br>  drop table if exists t_user;<br>  create table t_user(<br>  id int primary key auto_increment,<br>  username varchar(255)<br>  );</p>
</li>
<li><p>演示：使用start transaction;关闭自动提交机制。<br>  mysql&gt; start transaction;<br>  Query OK, 0 rows affected (0.00 sec)</p>
<p>  mysql&gt; insert into t_user(username) values(‘lisi’);<br>  Query OK, 1 row affected (0.00 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  |  2 | lisi     |<br>  +—-+———-+<br>  2 rows in set (0.00 sec)</p>
<p>  mysql&gt; insert into t_user(username) values(‘wangwu’);<br>  Query OK, 1 row affected (0.00 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  |  2 | lisi     |<br>  |  3 | wangwu   |<br>  +—-+———-+<br>  3 rows in set (0.00 sec)</p>
<p>  mysql&gt; rollback;<br>  Query OK, 0 rows affected (0.02 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  +—-+———-+</p>
<p>  1 row in set (0.00 sec)</p>
<p>  mysql&gt; start transaction;<br>  Query OK, 0 rows affected (0.00 sec)</p>
<p>  mysql&gt; insert into t_user(username) values(‘wangwu’);<br>  Query OK, 1 row affected (0.00 sec)</p>
<p>  mysql&gt; insert into t_user(username) values(‘rose’);<br>  Query OK, 1 row affected (0.00 sec)</p>
<p>  mysql&gt; insert into t_user(username) values(‘jack’);<br>  Query OK, 1 row affected (0.00 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  |  4 | wangwu   |<br>  |  5 | rose     |<br>  |  6 | jack     |<br>  +—-+———-+<br>  4 rows in set (0.00 sec)</p>
<p>  mysql&gt; commit;<br>  Query OK, 0 rows affected (0.04 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  |  4 | wangwu   |<br>  |  5 | rose     |<br>  |  6 | jack     |<br>  +—-+———-+<br>  4 rows in set (0.00 sec)</p>
<p>  mysql&gt; rollback;<br>  Query OK, 0 rows affected (0.00 sec)</p>
<p>  mysql&gt; select * from t_user;<br>  +—-+———-+<br>  | id | username |<br>  +—-+———-+<br>  |  1 | zs       |<br>  |  4 | wangwu   |<br>  |  5 | rose     |<br>  |  6 | jack     |<br>  +—-+———-+<br>  4 rows in set (0.00 sec)</p>
</li>
<li><p>演示两个事务，假如隔离级别<br>  演示第1级别：读未提交<br>  set global transaction isolation level read uncommitted;<br>  演示第2级别：读已提交<br>  set global transaction isolation level read committed;<br>  演示第3级别：可重复读<br>  set global transaction isolation level repeatable read;</p>
</li>
<li><p>mysql远程登录：mysql -h192.168.151.18 -uroot -p444</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>注意：<strong>主键和具有unique约束的字段自动会添加索引。</strong><br>根据主键查询效率较高。尽量根据主键检索。</p>
<h2 id="创建索引对象-怎么删除索引对象"><a href="#创建索引对象-怎么删除索引对象" class="headerlink" title="创建索引对象,怎么删除索引对象"></a>创建索引对象,怎么删除索引对象</h2><p>​	创建索引对象：<br>​		create index 索引名称 on 表名(字段名);<br>​	删除索引对象：<br>​		drop index 索引名称 on 表名;</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>​	单一索引：给单个字段添加索引<br>​	复合索引: 给多个字段联合起来添加1个索引<br>​	主键索引：主键上会自动添加索引<br>​	唯一索引：有unique约束的字段上会自动添加索引<br>​	….</p>
<p>唯一性比较弱的字段上添加索引用处不大</p>
<p>越唯一，效率越高</p>
<h2 id="什么是索引？有什么用？"><a href="#什么是索引？有什么用？" class="headerlink" title="什么是索引？有什么用？"></a>什么是索引？有什么用？</h2><p>​	索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制，</p>
<p>一张表的一个字段可以添加一个索引，多个字段联合起来也可以添加索引</p>
<p><strong>索引就相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。通过目录可以快速的找到对应的资源。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于一本字典来说，查找某个汉字有两种方式：</span><br><span class="line"></span><br><span class="line">第一种方式：一页一页挨着找，知道找到为止，这种属于全表扫描，效率比较低</span><br><span class="line"></span><br><span class="line">第二种方式：先通过目录去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找这种属于根据索引检索，效率很高；</span><br></pre></td></tr></table></figure>







<p>​	在数据库方面，查询一张表的时候有两种检索方式：<br>​		第一种方式：全表扫描<br>​		第二种方式：根据索引检索（效率很高）</p>
<h2 id="什么时候考虑给字段添加索引？（满足什么条件）"><a href="#什么时候考虑给字段添加索引？（满足什么条件）" class="headerlink" title="什么时候考虑给字段添加索引？（满足什么条件）"></a>什么时候考虑给字段添加索引？（满足什么条件）</h2><ul>
<li>数据量庞大。（根据客户的需求，根据线上的环境）</li>
<li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护。DML之后，索引需要重新排序）</li>
<li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li>
</ul>
<p>	</p>
<h2 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h2><p>在任何数据库中，任何一张表的任何记录在硬盘存储上都有一个硬盘的物理存储编号</p>
<p>​	</p>
<p>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，<br>    最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率<br>    是最高的。<br>        select ename from emp where ename &#x3D; ‘SMITH’;<br>        通过索引转换为：<br>        select ename from emp where 物理地址 &#x3D; 0x3;</p>
<p><img src="D:\笔记\web笔记\image-20220429214915322.png" alt="image-20220429214915322"></p>
<p><strong>索引底层采用的数据结构是：B + Tree</strong>(多路搜索二叉树)</p>
<p>索引为什么可以提高检索效率呢？</p>
<p>​		<strong>其实最根本的原理是缩小了扫描的范围。</strong><br>​	</p>
<p>​	索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中<br>​	的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改<br>​	这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>​	添加索引是给某一个字段，或者说某些字段添加索引。</p>
<p>​	select ename,sal from emp where ename &#x3D; ‘SMITH’;<br>​	当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。<br>​	当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p>
<h2 id="索引什么时候失效？"><a href="#索引什么时候失效？" class="headerlink" title="索引什么时候失效？"></a>索引什么时候失效？</h2><p>​	select ename from emp where ename like ‘%A%’;<br>1.模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。</p>
<p>尽量避免模糊查询的时候以“%”开始</p>
<p>2.使用or的时候会失效，如果使用or，那么要求or两边的条件字段都要有索引，才能走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效</p>
<p>3.复合索引的时候没有使用左侧的列查找，索引失效</p>
<p>复合索引就是两个字段或者更多的字段联合起来添加一个索引，叫做复合索引</p>
<p>4.where当中索引列参加了数学运算，索引失效</p>
<p>字段参加数学运算！！</p>
<p>select * from emp where sal-1&#x3D;1000;</p>
<p>5.在where当中，索引列使用了函数</p>
<p>select * from emp where lower(ename);</p>
<h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h1><p><strong>站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。</strong></p>
<p>对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）<br>可以对视图进行CRUD操作。</p>
<p><strong>引用原表的数据，进行映射</strong></p>
<h2 id="创建视图，删除视图"><a href="#创建视图，删除视图" class="headerlink" title="创建视图，删除视图"></a>创建视图，删除视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> myview <span class="keyword">as</span> <span class="keyword">select</span> empno,ename <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> myview;</span><br></pre></td></tr></table></figure>

<p>​	注意：只有DQL语句才能以视图对象的方式创建出来。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>​	视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员<br>​	只对视图对象进行CRUD。</p>
<h1 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a>DBA命令</h1><p><strong>重点了解数据的备份</strong></p>
<h2 id="将数据库当中的数据导出"><a href="#将数据库当中的数据导出" class="headerlink" title="将数据库当中的数据导出"></a>将数据库当中的数据导出</h2><p>​	在windows的dos命令窗口中执行：（导出整个库）<br>​		mysqldump 数据库名&gt;D:文件名.sql -u 账号名 -p 密码</p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420153043126.png" alt="image-20220420153043126">	<br>    在windows的dos命令窗口中执行：（导出指定数据库当中的指定表)<br>        mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot –p123</p>
<h2 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a>导入数据</h2><p>需要先登录上mysql，</p>
<p>之后创建数据库	</p>
<p>create database bjpowernode;</p>
<p>使用数据库</p>
<p>​	use bjpowernode;</p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420153151250.png" alt="image-20220420153151250">	</p>
<p>source D:\文件名.sql</p>
<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式*"></a>数据库设计三范式*</h1><p>​	</p>
<h2 id="什么是设计范式？"><a href="#什么是设计范式？" class="headerlink" title="什么是设计范式？"></a>什么是设计范式？</h2><p>​	设计表的依据。按照这个三范式设计的表不会出现数据冗余。</p>
<h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p>​	<strong>任何一张表都应该有主键，并且每一个字段原子性不可再分。</strong></p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420153934118.png" alt="image-20220420153934118"></p>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p>​	<strong>建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。</strong></p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420154313748.png" alt="image-20220420154313748"> <img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420154722359.png" alt="image-20220420154722359"></p>
<h3 id="多对多怎么设计"><a href="#多对多怎么设计" class="headerlink" title="多对多怎么设计"></a>多对多怎么设计</h3><p>多对多，三张表，关系表两个外键</p>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>​	<strong>建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。</strong></p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420155526040.png" alt="image-20220420155526040"></p>
<p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420155604474.png" alt="image-20220420155604474"></p>
<h3 id="一对多怎么设计"><a href="#一对多怎么设计" class="headerlink" title="一对多怎么设计"></a>一对多怎么设计</h3><p> 一对多，两张表，多的表加外键</p>
<h2 id="一对一怎么设计"><a href="#一对一怎么设计" class="headerlink" title="一对一怎么设计"></a>一对一怎么设计</h2><p><img src="C:\Users\Xu\AppData\Roaming\Typora\typora-user-images\image-20220420160840832.png" alt="image-20220420160840832"></p>
<h1 id="牢记"><a href="#牢记" class="headerlink" title="牢记"></a>牢记</h1><p>数据库设计三范式是理论上的</p>
<p>实践和理论有时候有偏差</p>
<p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换速度</p>
<p>因为在sql中，表和表的连接次数越多，效率越低（笛卡尔积）</p>
<p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，</p>
<p>并且对于开发人员来说，<strong>sql语句的编写难度也会降低</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/04/MySQL/" data-id="cl6f2wxtw0000s86raxtfdgry" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-gyysz" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/04/gyysz/" class="article-date">
  <time class="dt-published" datetime="2022-08-04T13:25:04.000Z" itemprop="datePublished">2022-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/04/gyysz/">gyysz</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>hello</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/04/gyysz/" data-id="cl6f2q4ra00009g6r1fk8d39a" data-title="gyysz" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/123/" rel="tag">123</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/04/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-08-04T13:03:00.202Z" itemprop="datePublished">2022-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/04/hello-world/" data-id="cl6f2q4sa00019g6r4f8ia0rm" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/123/" rel="tag">123</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/123/" style="font-size: 10px;">123</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/04/MySQL/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/04/gyysz/">gyysz</a>
          </li>
        
          <li>
            <a href="/2022/08/04/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>